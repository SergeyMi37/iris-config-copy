<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2012.2.3 (Build 903U)" ts="2021-09-25 14:20:45">
<Class name="Api.Config.Developers.ClassGenerator">
<Description>
DON'T USE.  (class used for first code generation.)
Generator for 
- Swagger spec.
- REST Service implementation.
- Proxy class with Config package.
Classes in %SYS config package are pretty similar.
So, We can write easily an algorithm to generate needed classes.</Description>
<Super>%RegisteredObject</Super>
<TimeChanged>66011,29866.887291</TimeChanged>
<TimeCreated>66011,29866.887291</TimeCreated>

<Property name="class">
<Description>
Configuration class</Description>
<Type>%Dictionary.CompiledClass</Type>
</Property>

<Property name="generatedClassName">
<Type>%String</Type>
</Property>

<Property name="outClass">
<Type>%Dictionary.ClassDefinition</Type>
<InitialExpression>##class(%Dictionary.ClassDefinition).%New()</InitialExpression>
</Property>

<Property name="parameters">
<Type>%Binary</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="temp">
<Type>%Binary</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="swaggerSpec">
<Type>%DynamicObject</Type>
</Property>

<Property name="restApp">
<Type>%String</Type>
<InitialExpression>"Api.Config.REST"</InitialExpression>
</Property>

<Method name="test">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    ;d ##class(Api.Config.Developers.ClassGenerator).test()
    tro
    TSTART
    
    Set swagger = {
        "swagger":"2.0",
        "host":"localhost:32773",
        "basePath":"/api/config",
        "schemes":[
            "http","https"
        ],
        "info":{
            "title":"IRIS Config API",
            "version":"0.0.1",
            "description":"Config API.",
            "contact":{
            "name":"Lorenzo Scalese",
            "email":"lorenzo.scalese@gmail.com",
            "url":"https://github.com/lscalese/Iris-Deploy-Utils-API/"
            },
            "license":{
            "name":"MIT",
            "url":"https://github.com/lscalese/Iris-Deploy-Utils-API/blob/master/LICENSE"
            }
        },
        "produces":[
            "application/json"
        ],
        "paths":{
            "/":{
                "get":{
                    "tags":[
                        "Developer"
                    ],
                    "operationId":"GetSpecification",
                    "description":"Swagger 2.0 specification",
                    "responses":{
                        "200":{
                            "description":"OK"
                        }
                    }
                }
            }
        },
        "definitions":{}
    }

    Set outPKG = "Api.Config.Services.", ptr = 0
    Set clsList = ..getConfigClassList() ;$LISTBUILD("Config.MapGlobals","Config.Journal")
    ;Set clsList = $LISTBUILD("Config.Databases")

    While $LISTNEXT(clsList, ptr, v) {
        Set gen = ..%New(v, outPKG _ $Piece(v,".",*), swagger)
        Set sc = gen.generate()

    }

    Set formatter=##class(%JSON.Formatter).%New()
    Set swaggerString = ""
    Do formatter.FormatToString(swagger, .swaggerString)
    ;w !,swaggerString
    
    Set file=##class(%File).%New($Get(parameters("outSwaggerFile"),"/irisrun/repo/GENERATOR.json"))
    Do file.Open("WSN")
    Do file.Write(swaggerString)
    Do file.SaveStream()


    Quit
]]></Implementation>
</Method>

<Method name="getConfigClassList">
<ClassMethod>1</ClassMethod>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Set classes("Cluster")=""
    Set classes("ConfigFile")=""
    Set classes("Databases")=""
    Set classes("Debug")=""
    Set classes("DeviceSubTypes")=""
    Set classes("Devices")=""
    Set classes("ECP")=""
    Set classes("ECPServers")=""
    Set classes("IO")=""
    Set classes("Journal")=""
    Set classes("LicenseServers")=""
    Set classes("MagTapes")=""
    Set classes("MapGlobals")=""
    Set classes("MapMirrors")=""
    Set classes("MapPackages")=""
    Set classes("MapRoutines")=""
    Set classes("MapShadows")=""
    Set classes("MirrorMember")=""
    Set classes("Mirrors")=""
    Set classes("Miscellaneous")=""
    Set classes("Monitor")=""
    Set classes("Namespaces")=""
    Set classes("SQL")=""
    Set classes("Shadows")=""
    Set classes("SqlSysDatatypes")=""
    Set classes("SqlUserDatatypes")=""
    Set classes("Startup")=""
    Set classes("Telnet")=""
    Set classes("config")=""
    
    
    Set class = ""
    For  {
        Set class = $Order(classes(class))
        Quit:class=""
        Set $List(lst,*+1) = "Config."_class
        
    }
    Quit lst
]]></Implementation>
</Method>

<Method name="%OnNew">
<FormalSpec><![CDATA[configClassName:%String,generatedClassName:%String,swagger:%DynamicObject={{}},&parameters:%Binary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, ns = $NAMESPACE 
    
    New $NAMESPACE 
    Set $NAMESPACE= "%SYS"
    
    Set ..class = ##class(%Dictionary.CompiledClass).%OpenId(configClassName,,.sc)
    Quit:$$$ISERR(sc) sc
    
    Set $NAMESPACE= ns
    Set ..swaggerSpec = swagger
    If '$$$defClassDefined(generatedClassName) {
        Set ..outClass = ##class(%Dictionary.ClassDefinition).%New()
        Set ..outClass.Name = generatedClassName
        Set ..outClass.IncludeCode = "Api.Config.inc"
        Set ..outClass.ProcedureBlock = $$$YES
    } Else {
        Set ..outClass = ##class(%Dictionary.ClassDefinition).%OpenId(generatedClassName)
    }
    
    If $Data(parameters) {
        Merge ..parameters = parameters
    }
    Quit sc
]]></Implementation>
</Method>

<Method name="generate">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, ns = $NAMESPACE, key = "", template = {}
    
    Set swaggerDef = {
        "type" : "object",
        "properties" : {},
        "required" : []
    }

    New $NAMESPACE 
    
    Do ..log("Start Generating Class "_..outClass.Name)

    #define GETTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"number",:"string")
    #define GETSWAGGERTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"integer",:"string")

    $$$QuitOnError(..ToDynamic())
    $$$QuitOnError(..ToArray())
    $$$QuitOnError(..Get())
    $$$QuitOnError(..Exists())
    $$$QuitOnError(..Create())
    $$$QuitOnError(..Update())
    $$$QuitOnError(..Delete())
    $$$QuitOnError(..CheckModel())
    $$$QuitOnError(..ObjectToArray())
    $$$QuitOnError(..List())

    For  {
        Set $NAMESPACE= "%SYS", property = ..class.Properties.GetNext(.key), $NAMESPACE= ns

        Quit:key=""
        Continue:..skipProperty(property)

        Set dflt = ""
        If property.InitialExpression '= "" {
            Set $NAMESPACE= "%SYS"
            Try { ; attempt to evaluate InitialExpression
                XECUTE ("(out) SET out="_ property.InitialExpression, .dflt)
            } Catch(ex) { 
                Do ..log("Evaluate initial expression failed for "_property.Name_" : "_property.InitialExpression)
            }
            Set $NAMESPACE= ns
        }
        
        Set jsonType = $$$GETTYPE($Replace(property.Type, "Library.",""))
        Set swaggerType = $$$GETSWAGGERTYPE($Replace(property.Type, "Library.",""))

        Do ToDynamic, ToArray, CheckModel, SwaggerDefinition, ObjectToArray

    }

    
    
    Do ..wlMethod($CHAR(9)_"Quit model", "ToDynamic")
    Do ..wlMethod($CHAR(9)_"Quit", "ToArray")
        
    Do ..wlMethod($CHAR(9)_"Quit sc", "CheckModel")
    Do ..wlMethod($CHAR(9)_"Quit", "ObjectToArray")

    Set clsKey = $Piece(..class.Name, ".", *)
    ;Set clsKey = $s($e(clsKey,*)="s":$e(clsKey,1,*-1),1:clsKey)
    
    Set swaggerDef.example = template
    
    Set:'$ISOBJECT(..swaggerSpec.definitions) ..swaggerSpec.definitions = {}
    Do:swaggerDef.required.%Size()=0 swaggerDef.%Remove("required")

    Do ..swaggerSpec.definitions.%Set(clsKey, swaggerDef)

    If ..configQueryExists("List") {
        Set listOf = {
            "type":"object",
            "properties": {}
        }
        Do listOf.properties.%Set(clsKey, {
            "type":"array",
            "items":{
                "$ref":("#/definitions/"_clsKey)
            }
        })
        Set lisOfPropertyName = "ListOf"_$$$UPPER($Extract(clsKey))_$Extract(clsKey,2,*)
        Set ..temp("RESTGEN","listof") = lisOfPropertyName
        Do ..swaggerSpec.definitions.%Set(lisOfPropertyName, listOf)
    }

    Do ..Path(clsKey)
    Set sc = ##class(%REST.API).CreateApplication(..restApp,..swaggerSpec)
    Do ..log("Update CSP REST application : "_$SYSTEM.Status.GetOneErrorText(sc))
    Do ..addRestImpl()
    Set sc = ..outClass.%Save()
    
    Quit sc

ToDynamic
    Set line = $CHAR(9) _ $$$FormatText("Do:$Data(properties(""%1"")) model.%Set(""%1"", properties(""%1""), ""%2"")", property.Name, jsonType)
    Do ..wlMethod(line, "ToDynamic")
    Quit 1 ; Quit 1 for the pleasure of SonarQube :p

ToArray
    If 'property.ReadOnly {
        Set line = $CHAR(9) _ $$$FormatText("Set:$$$CanSetProperty(model,""%1"") properties(""%1"") = model.%1", property.Name)
        Do ..wlMethod(line, "ToArray")
    }
    Quit 1

CheckModel
    If dflt=""&&property.Required {
        Set line = $CHAR(9) _ $$$FormatText("Set:model.%1="""" sc = $$$ADDSC(sc,$$$ERROR(5001, ""%1 property is mandatory.""))",property.Name)
        Do ..wlMethod(line,"CheckModel")
    }
    Quit 1

SwaggerDefinition
    If dflt=""&&property.Required {
        Do swaggerDef.required.%Push(property.Name)
        Do template.%Set(property.Name, dflt, jsonType)
    }

    Set description = ..getPropertyDescription(property.Name)

    Do swaggerDef.properties.%Set(property.Name, {
        "type" : (swaggerType),
        "default" : (dflt),
        "description" : (description)
    })

    Quit 1

ObjectToArray
    Set line = $CHAR(9)_$$$FormatText("Set properties(""%1"") = pObj.%1",property.Name)
    Do ..wlMethod(line, "ObjectToArray")
    Quit 1
]]></Implementation>
</Method>

<Method name="wlMethod">
<FormalSpec>line:%String,methodName:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set method = $Get(..temp(methodName))
    Quit:'$ISOBJECT(method) $$$OK
    ;Do ..log(methodName _" "_line)
    Do method.Implementation.WriteLine(line)
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="Path">
<FormalSpec>clsKey:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    Set service = {}
    
    Set serviceKey = "/"_$$$LOWER(clsKey)_"/", serviceKeyLocation = "%request.Application_"""_serviceKey_""""

    If '..isCommonSingle() {
        Do ..GetFormalSpec("Get",.callString)
        Set lst = $LISTFROMSTRING(callString, ","), ptr = 0
        
        While $LISTNEXT(lst, ptr, param) {
            Set serviceKey = serviceKey _ $Select($Extract(serviceKey,*)'="/":"/",1:"") _ $Replace("{%1}","%1",$$$LOWER(param))
            Set serviceKeyLocation = serviceKeyLocation _ "_"_$$$LOWER(param) _"/"
            Set rmTrailing=1
        }
        Set:$Get(rmTrailing) serviceKeyLocation = $Extract(serviceKeyLocation,1,*-1)
    }

    Set ..temp("RESTGEN","location")=serviceKeyLocation

    Do service.%Set("get", ..SwaggerGet(clsKey,.operationId))
    Set ..temp("RESTMETHOD","RESTTemplateGET")=operationId
    Do service.%Set("put", ..SwaggerPut(clsKey,.operationId))
    Set ..temp("RESTMETHOD","RESTTemplatePUT")=operationId

    If '..isCommonSingle() {
        Do service.%Set("post", ..SwaggerPost(clsKey,.operationId))
        Set ..temp("RESTMETHOD","RESTTemplatePOST")=operationId
        Do service.%Set("delete", ..SwaggerDelete(clsKey,.operationId))
        Set ..temp("RESTMETHOD","RESTTemplateDELETE")=operationId
    }
    

    Do ..swaggerSpec.paths.%Set(serviceKey, service)

    ;If "/"_$$$LOWER(clsKey)_"/"'=serviceKey,..configQueryExists("List") {
    If '..isCommonSingle(),..configQueryExists("List") {
        If ..isCommonMapMethods() {
            Set serviceKey = "/"_$$$LOWER(clsKey)_"/{namespace}/" 
        } Else {
            Set serviceKey = "/"_$$$LOWER(clsKey)_"/"
        }
        Do ..swaggerSpec.paths.%Set(serviceKey, {"get":(..SwaggerGetList(clsKey,.operationId))})
        Set ..temp("RESTMETHOD","RESTTemplateGETList")=operationId
    }

    Quit $$$OK
]]></Implementation>
</Method>

<Method name="addRestImpl">
<FormalSpec>class:%String=..restApp_".impl"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Set cdef = ##class(%Dictionary.ClassDefinition).%OpenId(class)
    Set cdef.IncludeCode = "Api.Config.inc"
    Do cdef.%Save()

    #dim mdef As %Dictionary.MethodDefinition
    Set mTemplate = ""
    For  {
        Set mTemplate = $Order(..temp("RESTMETHOD",mTemplate),1,methodName)
        Quit:mTemplate=""
        
        Set mdef = ##class(%Dictionary.MethodDefinition).%OpenId(class _ "||" _ methodName)
        Set template=$METHOD(##this,mTemplate)
        Set buff = template.Read()
        Set replace = ""
        For  {
            Set replace = $Order(..temp("RESTGEN",replace),1,value)
            Quit:replace=""
            Set buff = $replace(buff, "{{"_replace_"}}", value)
        }
        w !,methodName
        Do mdef.Implementation.Clear()
        Do mdef.Implementation.Write(buff)
        Set sc2 = mdef.%Save()
        Do ..log("Add REST method implementation "_ methodName _ " "_$SYSTEM.Status.GetOneErrorText(sc2))
        Set:$$$ISERR(sc2) sc = $$$ADDSC(sc,sc2)
    }
    
    Quit sc
]]></Implementation>
</Method>

<Method name="SwaggerDelete">
<FormalSpec>clsKey:%String,*operationId</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[

    Set verb = "delete"
    Set operationId =($$$UPPER($Extract(verb)) _ $Extract(verb, 2, *) _ clsKey)
    Set parameters = ..SwggerGetCommonParam()

    Set responses = {
        "204": {
            "description" : (clsKey _" deleted.")
            
        },
        "400" : {
            "description" : "Bad request, can occurs if mandatory parameters are missing or empty"
        },
        "404" : {
            "description" : (clsKey _ " not found.")
        }
    }

    Set desc = "Delete "_clsKey _ "."
    Set method = {
        "operationId" : (operationId),
        "description": (desc),
        "parameters" : (parameters),
        "responses" : (responses)
    }

    Quit method
]]></Implementation>
</Method>

<Method name="SwaggerPut">
<FormalSpec>clsKey:%String,*operationId</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set verb = "put"
    Set parameters = ..SwggerGetCommonParam()
    Set operationId =($$$UPPER($Extract(verb)) _ $Extract(verb, 2, *) _ clsKey)
    Do parameters.%Push({
        "name": "model",
        "description" : (clsKey _ " to update."),
        "in": "body",
        "required":true,
        "schema": {
            "$ref": ("#/definitions/" _ clsKey)
        }
    })

    Set responses = {
        "204" : {
            "description": "Ressource updated."
        },
        "400" : {
            "description" : "Bad request, can occurs if mandatory parameters are missing or empty"
        },
        "404" : {
            "description" : (clsKey _ " to update not found.")
        }
    }

    Set desc = "Update "_clsKey _ "."
    Set method = {
        "operationId" : (operationId),
        "description": (desc),
        "parameters" : (parameters),
        "responses" : (responses)
    }

    Quit method
]]></Implementation>
</Method>

<Method name="SwaggerPost">
<FormalSpec>clsKey:%String,*operationId</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set verb = "post"
    Set operationId =($$$UPPER($Extract(verb)) _ $Extract(verb, 2, *) _ clsKey)
    Set parameters = ..SwggerGetCommonParam()
    
    Do parameters.%Push({
        "name": "model",
        "description" : (clsKey _ " to create."),
        "in": "body",
        "required":true,
        "schema": {
            "$ref": ("#/definitions/" _ clsKey)
        }
    })

    
    Set responses = {
        "201": {
            "description" : (clsKey _" created."),
            "headers": {
                "Location": {
                    "type":"string",
                    "description":"Created ressource location."
                }
            }
        },
        "400" : {
            "description" : "Bad request, can occurs if mandatory parameters are missing or empty"
        },
        "409" : {
            "description" : ( clsKey _ " already exists.")
        }
    }

    Set desc = "Create "_clsKey _ "."
    Set method = {
        "operationId" : (operationId),
        "description": (desc),
        "parameters" : (parameters),
        "responses" : (responses)
    }
    
    Quit method
]]></Implementation>
</Method>

<Method name="SwaggerGetList">
<FormalSpec>clsKey,*operationId</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set verb = "get"
    Set operationId =($$$UPPER($Extract(verb)) _ $Extract(verb, 2, *) _"List"_ clsKey)
    Set parameters = []

    Do:..isCommonMapMethods() parameters.%Push({
        "name": "namespace",
        "description" : "namespace.",
        "in": "path",
        "required":true,
        "type":"string"
    })
    
    Set responses = {
        "200": {
            "description" : "OK",
            "schema": {
                "$ref": ("#/definitions/ListOf" _ clsKey)
            }
        },
        "400" : {
            "description" : "Bad request, can occurs if mandatory parameters are missing or empty."
        }
    }
    Set desc = "Get List Of "_clsKey _ "."
    Set method = {
        "operationId" : (operationId),
        "description": (desc),
        "parameters" : (parameters),
        "responses" : (responses)
    }
    
    Quit method
]]></Implementation>
</Method>

<Method name="SwaggerGet">
<FormalSpec>clsKey:%String,*operationId</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set verb = "get"
    Set operationId =($$$UPPER($Extract(verb)) _ $Extract(verb, 2, *) _ clsKey)
    Set parameters = ..SwggerGetCommonParam()

    Set responses = {
        "200": {
            "description" : "OK",
            "schema": {
                "$ref": ("#/definitions/" _ clsKey)
            }
        },
        "400" : {
            "description" : "Bad request, can occurs if mandatory parameters are missing or empty."
        },
        "404" : {
            "description" : (clsKey _ " not found.")
        }
    }
    Set desc = "Get "_clsKey _ "."
    Set method = {
        "operationId" : (operationId),
        "description": (desc),
        "parameters" : (parameters),
        "responses" : (responses)
    }
    
    Quit method
]]></Implementation>
</Method>

<Method name="SwggerGetCommonParam">
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set parameters = []
    ;
    ;w !,"..isCommonSingle() : ",..isCommonSingle(),!
    Set ..temp("RESTGEN","params")="", ..temp("RESTGEN","getlistparams")=""

    If '..isCommonSingle() {
        Do ..GetFormalSpec("Get",.callString)
        ;w !,"call string " ,callString,!
        Set lst = $LISTFROMSTRING(callString, ","), ptr = 0, params=""
        
        While $LISTNEXT(lst, ptr, param) {
            Set description = ..getPropertyDescription(param)
            Do parameters.%Push({
                "name" : ($$$LOWER(param)),
                "description" : (description),
                "in" : "path",
                "type" : "string",
                "required" : true
            })
            Set params = params_","_$$$LOWER(param)
            ;w !,"desc ",description
        }
    
        Set ..temp("RESTGEN","params")=$Extract(params,2,*)
    
    } 
    
    If ..isCommonMapMethods() {
        Set ..temp("RESTGEN","getlistparams") = $Piece(..temp("RESTGEN","params"),",",1)
    }

    Quit parameters
]]></Implementation>
</Method>

<Method name="ToDynamic">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK

    Do ..log(" * Generate method ToDynamic : ")
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||ToDynamic" ) {
        Set mToDynamic = ##class(%Dictionary.MethodDefinition).%New()
        Set mToDynamic.Name = "ToDynamic"
        Set mToDynamic.ClassMethod = $$$YES
        Set mToDynamic.FormalSpec = "&properties:%Binary" ; "pObj:"_className
        Set mToDynamic.ReturnType = "%Library.DynamicObject"
        Do mToDynamic.Implementation.WriteLine($CHAR(9) _ "Set model = {}")
        Do ..outClass.Methods.Insert(mToDynamic)
        Set ..temp("ToDynamic")=mToDynamic
        Do ..log( "Initialized.", 0)
    } Else {
        Do ..log( "Already exists (skipped).", 0)
    }

    Quit sc
]]></Implementation>
</Method>

<Method name="ToArray">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Do ..log(" * Generate method ToArray : ")
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||ToArray") {
        Set mToArray = ##class(%Dictionary.MethodDefinition).%New()
        Set mToArray.Name = "ToArray"
        Set mToArray.ClassMethod = $$$YES
        Set mToArray.FormalSpec = "model:%Library.DynamicObject,*properties:%Binary"
        Set mToArray.ReturnType = ""
        Do ..outClass.Methods.Insert(mToArray)
        Set ..temp("ToArray")=mToArray
        Do ..log( "Initialized.", 0)
    } Else {
        Do ..log( "Already exists (skipped).", 0)
    }

    Quit sc
]]></Implementation>
</Method>

<Method name="Get">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Do ..log(" * Generate method Get : ")
    Set methodName = "Get"
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name_"||"_methodName) {
        #dim method As %Dictionary.MethodDefinition = ##class(%Dictionary.MethodDefinition).%New()
        Set method.Name = methodName
        Set method.ClassMethod = $$$YES
        Set method.ReturnType = "%Library.DynamicObject"
        If ..isCommonSingle() {
            Set args = ""
        } Else {
            Set method.FormalSpec = ..GetFormalSpec(methodName, .callString)
            Do method.Implementation.WriteLine($CHAR(9) _ "Quit:'..Exists(" _ callString _ ") """"")
            Set args = $Select(callString'="":callString_",",1:"")
        }
        Do method.Implementation.WriteLine($CHAR(9) _ "$$$switchNSSys")
        
        Do method.Implementation.WriteLine($CHAR(9) _ $$$FormatText("$$$ThrowOnError(##class(%1).Get("_args_".properties))", ..class.Name))
        Do method.Implementation.WriteLine($CHAR(9) _ "Quit ..ToDynamic(.properties)")
        Do ..outClass.Methods.Insert(method)
        Set ..temp(methodName)=method
        Do ..log("Initialized.", 0)
    } Else {
        Do ..log("Already exists (skipped).", 0)
    }
    Set ..temp("RESTGEN","get") = $$$FormatText("##class(%1).%2", ..outClass.Name, methodName)
    Quit sc
]]></Implementation>
</Method>

<Method name="Exists">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, methodName = "Exists"
    Quit:'..configMethodExists(methodName) sc

    Quit:..isCommonSingle() sc

    Do ..log(" * Generate method Exists : ")
    
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||"_methodName) {
        Set method = ##class(%Dictionary.MethodDefinition).%New()
        Set method.Name = methodName
        Set method.ClassMethod = $$$YES
        Set method.ReturnType = "%Boolean"
        Set method.FormalSpec = ..GetFormalSpec("Get", .callString) 
        Do method.Implementation.WriteLine($CHAR(9) _ "$$$switchNSSys")
        Do method.Implementation.WriteLine($CHAR(9) _ $$$FormatText("Quit ##class(%1).Exists("_callString_")", ..class.Name))
        Do ..outClass.Methods.Insert(method)
        Set ..temp(methodName)=method
        Do ..log("Initialized.", 0)
    } Else {
        Do ..log("Already exists (skipped).", 0)
    }
     Set ..temp("RESTGEN","exists") = $$$FormatText("##class(%1).%2", ..outClass.Name, methodName)
    Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, methodName = "Create"
    Quit:'..configMethodExists(methodName) sc
    
    Set ns = $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Quit:$CLASSMETHOD(..class.Name,"%Extends","Config.CommonSingleMethods") sc
    Set $NAMESPACE = ns

    Do ..log(" * Generate method Create : ")

    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||" _ methodName) {
        Set method = ##class(%Dictionary.MethodDefinition).%New()
        Set method.Name = methodName
        Set method.ClassMethod = $$$YES
        Set method.ReturnType = "%Status"
        Set method.FormalSpec = "model:%Library.DynamicObject"
        Do ..GetFormalSpec("Get", .callString, "model.")
        Do method.Implementation.WriteLine($CHAR(9) _ "Do ..ToArray(model,.properties)")
        Do method.Implementation.WriteLine($CHAR(9) _ "$$$switchNSSys")
        Set args = $Select(callString'="":callString_",",1:"")
        Do method.Implementation.WriteLine($CHAR(9) _ $$$FormatText("Quit ##class(%1).Create("_args_".properties)", ..class.Name))
        Do ..outClass.Methods.Insert(method)
        Set ..temp(methodName)=method
        Do ..log("Initialized.", 0)

    } Else {
        Do ..log("Already exists (skipped).", 0)
    }
    Set ..temp("RESTGEN","create") = $$$FormatText("##class(%1).%2", ..outClass.Name, methodName)
    Quit sc
]]></Implementation>
</Method>

<Method name="Update">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, methodName = "Update"
    Quit:'..configMethodExists("Modify") sc
    Do ..log(" * Generate method Update : ")
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||" _ methodName) {
        Set method = ##class(%Dictionary.MethodDefinition).%New()
        Set method.Name = methodName
        Set method.ClassMethod = $$$YES
        Set method.ReturnType = "%Status"
        Set method.FormalSpec = "model:%Library.DynamicObject"
        If '..isCommonSingle() {
            Do ..GetFormalSpec("Get", .callString, "model.") 
            Set args = $Select(callString'="":callString_",",1:"")
        } Else {
            Set args = ""
        }
        Do method.Implementation.WriteLine($CHAR(9) _ "Do ..ToArray(model,.properties)")
        Do method.Implementation.WriteLine($CHAR(9) _ "$$$switchNSSys")
       
        Do method.Implementation.WriteLine($CHAR(9) _ $$$FormatText("Quit ##class(%1).Modify("_args_".properties)", ..class.Name))
        Do ..outClass.Methods.Insert(method)
        Set ..temp(methodName)=method
        Do ..log("Initialized.", 0)
    } Else {
        Do ..log("Already exists (skipped).", 0)
    }
    Set ..temp("RESTGEN","update") = $$$FormatText("##class(%1).%2", ..outClass.Name, methodName)
    Quit sc
]]></Implementation>
</Method>

<Method name="Delete">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, methodName = "Delete"
    Quit:'..configMethodExists(methodName) sc
    Do ..log(" * Generate method Delete : ")
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||" _ methodName) {
        Set method = ##class(%Dictionary.MethodDefinition).%New()
        Set method.Name = methodName
        Set method.ClassMethod = $$$YES
        Set method.ReturnType = "%Status"
        Set method.FormalSpec = ..GetFormalSpec("Get", .callString) 
        Do method.Implementation.WriteLine($CHAR(9) _ "$$$switchNSSys")
        Do method.Implementation.WriteLine($CHAR(9) _ $$$FormatText("Quit ##class(%1).Delete("_callString_")", ..class.Name))
        Do ..outClass.Methods.Insert(method)
        Set ..temp(methodName)=method
        Do ..log("Initialized.", 0)
    } Else {
        Do ..log("Already exists (skipped).", 0)
    }
    Set ..temp("RESTGEN","delete") = $$$FormatText("##class(%1).%2", ..outClass.Name, methodName)
    Quit sc
]]></Implementation>
</Method>

<Method name="CheckModel">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, methodName =  "CheckModel"
    Do ..log(" * Generate method CheckModel : ")
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||" _methodName) {
        Set checkModelMethod = ##class(%Dictionary.MethodDefinition).%New()
        Set checkModelMethod.Name = methodName
        Set checkModelMethod.ClassMethod = $$$YES
        Set checkModelMethod.ReturnType = "%Status"
        Set checkModelMethod.FormalSpec = "model:%Library.DynamicObject"
        Do checkModelMethod.Implementation.WriteLine($CHAR(9)_"Set sc = $$$OK")
        Do ..outClass.Methods.Insert(checkModelMethod)
        Set ..temp(methodName)=checkModelMethod
        Do ..log("Initialized.", 0)
    } Else {
        Do ..log("Already exists (skipped).", 0)
    }
    Set ..temp("RESTGEN","checkmodel") = $$$FormatText("##class(%1).%2", ..outClass.Name, methodName)
    Quit sc
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, methodName = "ObjectToArray"
    Do ..log(" * Generate method ObjectToArray : ")
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||" _methodName) {
        Set mObjectToArray = ##class(%Dictionary.MethodDefinition).%New()
        Set mObjectToArray.Name = methodName
        Set mObjectToArray.ClassMethod = $$$YES
        Set mObjectToArray.ReturnType = ""
        Set mObjectToArray.FormalSpec = "&pObj,*properties:%Binary"
        Do ..outClass.Methods.Insert(mObjectToArray)
        Do ..outClass.Methods.Insert(mObjectToArray)
        Set ..temp(methodName)=mObjectToArray
        Do ..log("Initialized.", 0)
    } Else {
        Do ..log("Already exists (skipped).", 0)
    }
    Quit sc
]]></Implementation>
</Method>

<Method name="List">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, methodName = "List"
    Quit:'..configQueryExists(methodName) sc
    Set ns = $NAMESPACE
    New $NAMESPACE

    Do ..log(" * Generate method List : ")
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||" _ methodName) {
        Set method = ##class(%Dictionary.MethodDefinition).%New()
        Set method.Name = methodName
        Set method.ClassMethod = $$$YES
        Set method.ReturnType = "%DynamicArray"
        Set method.FormalSpec = ..GetFormalSpecList(.callString)
        Do method.Implementation.WriteLine($CHAR(9) _ "$$$switchNSSys")
        Do method.Implementation.WriteLine($CHAR(9) _ "Set list = []")
        Do method.Implementation.WriteLine($CHAR(9) _ "Try{")
        Do method.Implementation.WriteLine($CHAR(9,9) _ "Set rs=##class(%Library.ResultSet).%New("""_..class.Name_":List"")")
        Do method.Implementation.WriteLine($CHAR(9,9) _ "Do rs.Execute("_callString_")")
        Do method.Implementation.WriteLine($CHAR(9,9) _ "While rs.Next() {")
        
        Set $NAMESPACE = "%SYS"
        Set paramsGet = ""
        If $CLASSMETHOD(..class.Name, "%Extends", "Config.CommonSingleMethods") {
            Set paramsGet = ""
        } ElseIf $CLASSMETHOD(..class.Name, "%Extends", "Config.CommonMapMethods") {
            Set paramsGet = "Namespace, rs.Data(""Name"")"
        } ElseIf $CLASSMETHOD(..class.Name, "%Extends", "Config.CommonMultipleMethods") {
            Set paramsGet = "rs.Data(""Name"")"
        }
        Set $NAMESPACE = ns

        Do method.Implementation.WriteLine($CHAR(9,9,9) _ "Do list.%Push(..Get("_paramsGet_"))")
        Do method.Implementation.WriteLine($CHAR(9,9) _ "}")
        Do method.Implementation.WriteLine($CHAR(9,9) _ "Do rs.Close()")
        Do method.Implementation.WriteLine($CHAR(9,9) _ "$$$restoreNS")
        Do method.Implementation.WriteLine($CHAR(9) _"}Catch(ex) {")
        Do method.Implementation.WriteLine($CHAR(9,9) _"$$$restoreNS")
        Do method.Implementation.WriteLine($CHAR(9,9)_"Throw ex")
        Do method.Implementation.WriteLine($CHAR(9) _"}")
        Do method.Implementation.WriteLine($CHAR(9) _"Return list")
       
        Do ..outClass.Methods.Insert(method)
        Set ..temp(methodName)=method
        Do ..log("Initialized.", 0)
    } Else {
        Do ..log("Already exists (skipped).", 0)
    }

    Set ..temp("RESTGEN","getlist") = $$$FormatText("##class(%1).%2", ..outClass.Name, methodName)

    Quit sc
]]></Implementation>
</Method>

<Method name="GetFormalSpecList">
<FormalSpec>*callString:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS", callString = ""

    Set query = ##class(%Dictionary.CompiledQuery).%OpenId(..class.Name _ "||List")
    
    Set tmpList = $LISTFROMSTRING(query.FormalSpec), ptr = 0
    
    While $LISTNEXT(tmpList, ptr, v) {
        Set $Piece(callString, ",", *+1)= $Piece(v, ":")
    }
    Set callString = $Extract(callString, 2, *)
    
    Quit query.FormalSpec
]]></Implementation>
</Method>

<Method name="GetFormalSpec">
<FormalSpec>methodName:%String,*callString:%String,prefix:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS", callString = ""

    #dim cm As %Dictionary.CompiledMethod = ##class(%Dictionary.CompiledMethod).%OpenId(..class.Name _ "||" _ methodName,,.sc)
    Quit:$$$ISERR(sc) sc
    Set formalSpec = $Piece(cm.FormalSpec, ",&Properties")
    Set tmpList = $LISTFROMSTRING(formalSpec), ptr = 0
    
    While $LISTNEXT(tmpList, ptr, v) {
        Set $Piece(callString, ",", *+1)= prefix _ $Piece(v, ":")
    }
    Set callString = $Extract(callString, 2, *)

    Quit formalSpec
]]></Implementation>
</Method>

<Method name="configMethodExists">
<FormalSpec>methodName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Quit ##class(%Dictionary.CompiledMethod).%ExistsId(..class.Name _ "||" _ methodName)
]]></Implementation>
</Method>

<Method name="configQueryExists">
<FormalSpec>queryName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Quit ##class(%Dictionary.CompiledQuery).%ExistsId(..class.Name _ "||" _ queryName)
]]></Implementation>
</Method>

<Method name="log">
<Description>
write message to the current device if verbose is enabled</Description>
<FormalSpec>message:%String,newLine:%Boolean=1,dateTime:%Boolean=1</FormalSpec>
<Implementation><![CDATA[
    Quit:'..verbose()
    Write:newLine !, $zdt($h,3,1), " "
    Write message
    Quit
]]></Implementation>
</Method>

<Method name="isCommonSingle">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Quit $CLASSMETHOD(..class.Name,"%Extends","Config.CommonSingleMethods")
]]></Implementation>
</Method>

<Method name="isCommonMapMethods">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Quit $CLASSMETHOD(..class.Name,"%Extends","Config.CommonMapMethods")
]]></Implementation>
</Method>

<Method name="isCommonMultipleMethods">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Quit $CLASSMETHOD(..class.Name,"%Extends","Config.CommonMultipleMethods")
]]></Implementation>
</Method>

<Method name="getPropertyDescription">
<FormalSpec>property:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"

    Set desc = ""

    #dim cProp As %Dictionary.CompiledProperty = ##class(%Dictionary.CompiledProperty).%OpenId(..class.Name _ "||" _property,,.sc)
    Quit:$$$ISERR(sc) ""
    Set desc = cProp.Description
    ;Set desc = $Replace(desc,"<br>","\n")
    ;Set desc = $Replace(desc,"<br/>","\n")
    
    Quit desc
]]></Implementation>
</Method>

<Method name="verbose">
<CodeMode>expression</CodeMode>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[$Get(..parameters("verbose"),1)
]]></Implementation>
</Method>

<Method name="skipProperty">
<FormalSpec>property:%Dictionary.CompiledProperty</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    Quit:property.Internal $$$YES
    Quit:$Get(parameters("excludePercent"), $$$YES)&&($EXTRACT(property.Name)="%") $$$YES
    Quit:$Get(parameters("excludePrivate"), $$$YES)&&property.Private $$$YES
    Quit $$$NO
]]></Implementation>
</Method>

<Method name="RESTTemplateGET">
<ReturnType>%Stream.GlobalCharacter</ReturnType>
<Implementation><![CDATA[
    Set stream = ##class(%Stream.GlobalCharacter).%New()

    If ..configMethodExists("Exists") {
        Do stream.WriteLine($c(9)_ "If '{{exists}}({{params}}) {")
        Do stream.WriteLine($c(9,9)_ "Do ..%SetStatusCode($$$HTTP404)")
        Do stream.WriteLine($c(9,9)_ "Quit """"")
        Do stream.WriteLine($c(9)_ "}")
        Do stream.WriteLine("")
    }

    Do stream.WriteLine($c(9)_"Set model = {{get}}({{params}})")
    Do stream.WriteLine($c(9)_"Do ..%SetStatusCode($$$HTTP200)")
    Do stream.WriteLine($c(9)_"Do ..%SetContentType(""application/json"")")
    Do stream.WriteLine($c(9)_"Quit model")
    
    Quit stream
]]></Implementation>
</Method>

<Method name="RESTTemplatePUT">
<ReturnType>%Stream.GlobalCharacter</ReturnType>
<Implementation><![CDATA[
    Set stream = ##class(%Stream.GlobalCharacter).%New()
    Do stream.WriteLine($c(9)_ "Set dModel = {}.%FromJSON(.model)")
    Do stream.WriteLine($c(9)_ "Set sc ={{checkmodel}}(dModel)")
    Do stream.WriteLine($c(9)_ "If $$$ISERR(sc) {")
    Do stream.WriteLine($c(9,9)_ "Do ..%SetStatusCode($$$HTTP400)")
    Do stream.WriteLine($c(9,9)_ "Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)")
    Do stream.WriteLine($c(9,9)_ "Quit jsonSC")
    Do stream.WriteLine($c(9)_ "}")
    Do stream.WriteLine($c(9)_ "")
    If ..configMethodExists("Exists") {
        Do stream.WriteLine($c(9)_ "If '{{exists}}({{params}}) {")
        Do stream.WriteLine($c(9,9)_ "Do ..%SetStatusCode($$$HTTP404)")
        Do stream.WriteLine($c(9)_ "}")
    }
    Do stream.WriteLine($c(9)_ "")
    Do stream.WriteLine($c(9)_ "$$$ThrowOnError({{update}}(dModel))")
    Do stream.WriteLine($c(9)_ "Do ..%SetStatusCode($$$HTTP204)")
    Do stream.WriteLine($c(9)_ "Quit """"")   
    Quit stream
]]></Implementation>
</Method>

<Method name="RESTTemplatePOST">
<ReturnType>%Stream.GlobalCharacter</ReturnType>
<Implementation><![CDATA[
    Set stream = ##class(%Stream.GlobalCharacter).%New()
    Do stream.WriteLine($c(9)_ "Set dModel = {}.%FromJSON(.model)")
    Do stream.WriteLine($c(9)_ "Set sc ={{checkmodel}}(dModel)")
    Do stream.WriteLine($c(9)_ "If $$$ISERR(sc) {")
    Do stream.WriteLine($c(9,9)_ "Do ..%SetStatusCode($$$HTTP400)")
    Do stream.WriteLine($c(9,9)_ "Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)")
    Do stream.WriteLine($c(9,9)_ "Quit jsonSC")
    Do stream.WriteLine($c(9)_ "}")
    Do stream.WriteLine($c(9)_ "")
    Do stream.WriteLine($c(9)_ "If {{exists}}({{params}}) {")
    Do stream.WriteLine($c(9,9)_ "Do ..%SetStatusCode($$$HTTP409)")
    Do stream.WriteLine($c(9,9)_ "Quit """"")
    Do stream.WriteLine($c(9)_ "}")
    Do stream.WriteLine($c(9)_ "")
    Do stream.WriteLine($c(9)_ "$$$ThrowOnError({{create}}(dModel))")
    Do stream.WriteLine($c(9)_ "Do ..%SetStatusCode($$$HTTP201)")
    Do stream.WriteLine($c(9)_ "Do ..%SetHeader(""Location"", {{location}})")
    Do stream.WriteLine($c(9)_ "Quit """"")
    Quit stream
]]></Implementation>
</Method>

<Method name="RESTTemplateDELETE">
<ReturnType>%Stream.GlobalCharacter</ReturnType>
<Implementation><![CDATA[
    Set stream = ##class(%Stream.GlobalCharacter).%New()
    Do stream.WriteLine($c(9)_ "If '{{exists}}({{params}}) {")
    Do stream.WriteLine($c(9,9)_ "Do ..%SetStatusCode($$$HTTP404)")
    Do stream.WriteLine($c(9,9)_ "Quit """"")
    Do stream.WriteLine($c(9)_ "}")
    Do stream.WriteLine($c(9)_ "")
    Do stream.WriteLine($c(9)_ "$$$ThrowOnError({{delete}}({{params}}))")
    Do stream.WriteLine($c(9)_ "Do ..%SetStatusCode($$$HTTP204)")
    Do stream.WriteLine($c(9)_ "Quit """"")
    Quit stream
]]></Implementation>
</Method>

<Method name="RESTTemplateGETList">
<ReturnType>%Stream.GlobalCharacter</ReturnType>
<Implementation><![CDATA[
    Set stream = ##class(%Stream.GlobalCharacter).%New()
    Do stream.WriteLine($c(9)_ "Set lst = {{getlist}}({{getlistparams}})")
    Do stream.WriteLine($c(9)_ "Do ..%SetStatusCode($$$HTTP200)")
    Do stream.WriteLine($c(9)_ "Do ..%SetContentType(""application/json"")")
    Do stream.WriteLine($c(9)_ "Quit {""{{listof}}"":(lst)}")
    Quit stream
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Developers.Helper">
<Description>
dev helper
zw ##class(Api.Config.Developers.Helper).GenCommonMethod("","")
zw ##class(Api.Config.Developers.Helper).GenObjectToArray("","")
zw ##class(Api.Config.Developers.Helper).GenToDynamic("","")
do ##class(Api.Config.Developers.Helper).ShowSwaggerDef("")</Description>
<System>2</System>
<TimeChanged>66011,29866.863563</TimeChanged>
<TimeCreated>66011,29866.863563</TimeCreated>

<Method name="GenCommonMethod">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,outClassName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Do ..GenToDynamic(className, outClassName)
    Do ..GenToArray(className, outClassName)
    Do ..GenObjectToArray(className, outClassName)
    Do ..ShowSwaggerDef(className)
    Return sc
]]></Implementation>
</Method>

<Method name="GenToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,outClassName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
        #define GETTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"number",:"string")
    #define GETSWAGGERTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"integer",:"string")

    Write !," * Generate method ToArray to "_outClassName _ " "
    Set sc = $$$OK, key=""
    
    ;Set outClass = ##class(%Dictionary.ClassDefinition).%OpenId(outClassName)
    Set methodName = "ToArray"
    
    Set method = ##class(%Dictionary.MethodDefinition).%OpenId(outClassName_"||"_methodName,,.sc)
    Set:'$ISOBJECT(method) method = ##class(%Dictionary.MethodDefinition).%New()
    Set method = ##class(%Dictionary.MethodDefinition).%New()
    Set method.Name = methodName
    Set method.ClassMethod = $$$YES
    Set method.FormalSpec = "model:%Library.DynamicObject,*properties:%Binary"
    Set method.ReturnType = ""
    Do method.parentSetObjectId(outClassName)

    New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS"
    
    
    #dim class As %Dictionary.CompiledClass = ##class(%Dictionary.CompiledClass).%OpenId(className)

    For  {
        Set property = class.Properties.GetNext(.key)
        Quit:key="" 
        Continue:..skipProperty(property)
        ; Set jsonType = $$$GETTYPE($Replace(property.Type, "Library.",""))
        ; Set swaggerType = $$$GETSWAGGERTYPE($Replace(property.Type, "Library.",""))
        Set line = $CHAR(9) _ $$$FormatText("Set:$$$CanSetProperty(model,""%1"") properties(""%1"") = model.%1", property.Name)
        Do method.Implementation.WriteLine(line)
    }
    Do method.Implementation.WriteLine($CHAR(9) _ "Quit")

    Set $NAMESPACE = ns
    Set sc = method.%Save()
    Write $SYSTEM.Status.GetOneErrorText(sc)
    Return sc
]]></Implementation>
</Method>

<Method name="GenToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,outClassName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #define GETTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"number",:"string")
    #define GETSWAGGERTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"integer",:"string")

    Write !," * Generate method ToDynamic to "_outClassName _ " "
    Set sc = $$$OK, key=""
    
    ;Set outClass = ##class(%Dictionary.ClassDefinition).%OpenId(outClassName)
    Set methodName = "ToDynamic"
    
    Set method = ##class(%Dictionary.MethodDefinition).%OpenId(outClassName_"||"_methodName,,.sc)
    Set:'$ISOBJECT(method) method = ##class(%Dictionary.MethodDefinition).%New()
    Set method.Name = "ToDynamic"
    Set method.ClassMethod = $$$YES
    Set method.FormalSpec = "&properties:%Binary" ; "pObj:"_className
    Set method.ReturnType = "%Library.DynamicObject"
    Do method.Implementation.WriteLine($CHAR(9) _ "Set model = {}")
    Do method.parentSetObjectId(outClassName)

    New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS"
    
    
    #dim class As %Dictionary.CompiledClass = ##class(%Dictionary.CompiledClass).%OpenId(className)

    For  {
        Set property = class.Properties.GetNext(.key)
        Quit:key="" 
        Continue:..skipProperty(property)
        Set jsonType = $$$GETTYPE($Replace(property.Type, "Library.",""))
        ; Set swaggerType = $$$GETSWAGGERTYPE($Replace(property.Type, "Library.",""))
        Do method.Implementation.WriteLine($CHAR(9) _ $$$FormatText("Do:$Data(properties(""%1"")) model.%Set(""%1"", properties(""%1""), ""%2"")", property.Name, jsonType))
    }
    Do method.Implementation.WriteLine($CHAR(9) _ "Quit model")

    Set $NAMESPACE = ns
    Set sc = method.%Save()
    Write $SYSTEM.Status.GetOneErrorText(sc)
    Return sc
]]></Implementation>
</Method>

<Method name="GenObjectToArray">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,outClassName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    ; zw ##class(PackageName.ClassName).GenObjectToArray("","")
    Write !," * Generate method ObjectToArray to "_outClassName _ " "
    Set sc = $$$OK, key=""
    
    Set methodName = "ObjectToArray"
    
    Set method = ##class(%Dictionary.MethodDefinition).%OpenId(outClassName_"||"_methodName)
    Set:'$ISOBJECT(method) method = ##class(%Dictionary.MethodDefinition).%New()
    Set method.Name = methodName
    Set method.ClassMethod = $$$YES
    Set method.ReturnType = ""
    Set method.FormalSpec = "&pObj,*properties:%Binary"
    
    Do method.parentSetObjectId(outClassName)

    New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS"
    
    
    #dim class As %Dictionary.CompiledClass = ##class(%Dictionary.CompiledClass).%OpenId(className)

    For  {
        Set property = class.Properties.GetNext(.key)
        Quit:key="" 
        Continue:..skipProperty(property)
        Do method.Implementation.WriteLine($CHAR(9)_$$$FormatText("Set properties(""%1"") = pObj.%1",property.Name))
    }

    Set $NAMESPACE = ns
    Set sc = method.%Save()
    Write $SYSTEM.Status.GetOneErrorText(sc)
    Return sc
]]></Implementation>
</Method>

<Method name="ShowSwaggerDef">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    #define GETTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"number",:"string")
    #define GETSWAGGERTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"integer",:"string")

    Set swaggerDef = {
        "type" : "object",
        "properties" : {},
        "required" : []
    }
    Set template = {}, key=""
    Set swaggerDef.example = template
    New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS"
    
    Set obj = $CLASSMETHOD(className, "%New")
    
    #dim class As %Dictionary.CompiledClass = ##class(%Dictionary.CompiledClass).%OpenId(className)

    For  {
        Set property = class.Properties.GetNext(.key)
        Quit:key="" 
        Continue:..skipProperty(property)
        Set jsonType = $$$GETTYPE($Replace(property.Type, "Library.",""))
        Set swaggerType = $$$GETSWAGGERTYPE($Replace(property.Type, "Library.",""))
    
        Set dflt = $PROPERTY(obj,property.Name)
        Set:$ISOBJECT(dflt) dflt=""
        If dflt=""&&property.Required {
            Do swaggerDef.required.%Push(property.Name)
            Do template.%Set(property.Name, dflt, jsonType)
        }

        Set description = ..getPropertyDescription(property.Name, className)

        Do swaggerDef.properties.%Set(property.Name, {
            "type" : (swaggerType),
            "default" : (dflt),
            "description" : (description)
        })
    
    }
    
    Set $NAMESPACE = ns
    
    Set defObj = {}
    Set pName = $tr(className,"%.")
    Do defObj.%Set(pName,swaggerDef)

    Set isSingle = ''$PARAMETER("Api.Config.Services."_$tr(className,"%"),"ISSINGLE")
    If 'isSingle {
        Do defObj.%Set("ListOf"_pName,{
            "type":"object",
            "properties":{
                "list" : {
                    "type":"array",
                    "items": {
                        "$ref": ("#/definitions/" _ pName)
                    }
                }
            }
        })
    }
    
    Do ##class(Api.Config.Developers.Utils).FormatJSON(defObj,.formatted)

    w !,formatted
    Quit swaggerDef
]]></Implementation>
</Method>

<Method name="getPropertyDescription">
<ClassMethod>1</ClassMethod>
<FormalSpec>property:%String,class:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"

    #dim cProp As %Dictionary.CompiledProperty = ##class(%Dictionary.CompiledProperty).%OpenId(class _ "||" _property,,.sc)
    Quit:$$$ISERR(sc) ""
    Quit cProp.Description
]]></Implementation>
</Method>

<Method name="skipProperty">
<ClassMethod>1</ClassMethod>
<FormalSpec>property:%Dictionary.CompiledProperty</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    Quit:property.Internal $$$YES
    Quit:$Get(parameters("excludePercent"), $$$YES)&&($EXTRACT(property.Name)="%") $$$YES
    Quit:$Get(parameters("excludePrivate"), $$$YES)&&property.Private $$$YES
    Quit $$$NO
]]></Implementation>
</Method>

<Method name="MDListServices">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    ; d ##class(Api.Config.Developers.Helper).MDListServices()
    #define METHODEXISTS(%name)    $s(##class(%Dictionary.MethodDefinition).%ExistsId(key_"||"_%name):"yes",1:"no")
    Write !,"| Service classes 	| List 	| Get 	| Update    | Create    | Delete    | Exists    |"
    Write !,"|-	|-	|-	|-	|-	|-	|-	|"

    Set list = 1, get = 1, update = 1, create = 1, delete=1, exists=1 
    Set key = "Api.Config.Services"
    For  {
        Set key = $Order(^oddDEF(key))
        Quit:key=""||(key'["Api.Config.Services.")
        CONTINUE:key="Api.Config.Services.Loader"

        Set list = $$$METHODEXISTS("List"), 
                    get = $$$METHODEXISTS("Get"), 
                    update = $$$METHODEXISTS("Update"), 
                    create = $$$METHODEXISTS("Create"), 
                    delete = $$$METHODEXISTS("Delete"), 
                    exists = $$$METHODEXISTS("Exists")
        Write !, $$$FormatText("| %1 | %2 | %3 | %4 | %5 | %6 | %7 |",key,list,get,update,create,delete,exists)
    }
]]></Implementation>
</Method>

<Method name="MDListRequest">
<ClassMethod>1</ClassMethod>
<FormalSpec>swagger:%DynamicObject</FormalSpec>
<Implementation><![CDATA[
    s swagger = {}.%FromJSON(##class(%Dictionary.CompiledXData).%OpenId("Api.Config.REST.spec||OpenAPI").Data)
    ; d ##class(Api.Config.Developers.Helper).MDListRequest()
    Write !,"| Method 	| Request 	| Summary  |"
    Write !,"|-	|-	|- |"
    Set iter = swagger.paths.%GetIterator()
    While iter.%GetNext(.key,.value) {
        For method = "get", "post", "put", "delete" {
            CONTINUE:'value.%IsDefined(method)
            Write !, $$$FormatText("| %1 | %2 | %3 |", method, key, $PROPERTY($PROPERTY(value,method),"summary"))
        }
        
    }
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Developers.Install">
<Description>
Description</Description>
<TimeChanged>66011,29866.869194</TimeChanged>
<TimeCreated>66011,29866.869194</TimeCreated>

<Method name="installRESTApp">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set cfg = {
        "Security.Applications" : {
            "/api/config": {
                "NameSpace" : ($NAMESPACE),
                "Enabled" : 1,
                "DispatchClass" : "Api.Config.REST.disp",
                "CSPZENEnabled" : 1,
                "AutheEnabled": 32
            }
        }
    }

    Set sc = ##class(Api.Config.Services.Loader).Load(cfg)

    Quit sc
]]></Implementation>
</Method>

<Method name="SetSwaggerUIDefaultPath">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>specUrl:%String="/api/config/",toReplace:%String="""http://localhost:52773/crud/_spec"""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Quit:'##class(Api.Config.Services.Security.Applications).Exists("/swagger-ui") $$$ERROR(5001, "/swagger-ui web app does not exists")
    
    Set app = ##class(Api.Config.Services.Security.Applications).Get("/swagger-ui")
    Set dir = ##class(%File).NormalizeDirectory(app.Path)
    
    Set newValue = "(window.location.protocol+'//'+window.location.host+'"_specUrl_"')"
    Set file = ##class(%Stream.FileCharacter).%New()
    Do file.LinkToFile(dir_"index.html")
    Set buff = file.Read()
    Set buff = $REPLACE(buff, toReplace, newValue)
    Do file.Clear()
    Do file.Rewind()
    Do file.Write(buff)
    Quit file.%Save()
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Developers.Samples">
<Description>
code samples
Description</Description>
<TimeChanged>66011,29866.925501</TimeChanged>
<TimeCreated>66011,29866.925501</TimeCreated>

<Method name="firstStep">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    /// zw ##class(Api.Config.Developers.Samples).firstStep()
    Set config = {
        "Security.Roles":{
            "MyAppRoleRO" : {
                "Descripion" : "MyApp SQL Read Only Role",
                "Resources" : "%Service_SQL:U",
                "GrantedRoles" : "%SQL"
            },
            "MyAppRoleRW" : {
                "Descripion" : "MyApp SQL Read\\Write Role",
                "Resources" : "%Service_SQL:U",
                "GrantedRoles" : "%SQL"
            }
        },
        "Security.SQLPrivileges": [{
            "Grantable" : 0,
            "Grantee": "MyAppRoleRO",
            "Grantor" : "_SYSTEM",
            "Namespace" : "${namespace}",
            "PrivList" : "s",
            "SQLObject" : "1,Api_*"
        },{
            "Grantable" : 0,
            "Grantee": "MyAppRoleRW",
            "Grantor" : "_SYSTEM",
            "Namespace" : "${namespace}",
            "PrivList" : "siud",
            "SQLObject" : "1,Api_*"
        }],
        "Security.Users": {
            "SQLUserRW": {
                "Description":"SQLUser1",
                "Password" : "$$test$$",
                "ChangePassword" : 1,
                "AccountNeverExpires": 1,
                "Roles":"MyAppRoleRW",
                "Namespace" : "${namespace}"
            },
            "SQLUserRO": {
                "Description":"SQLUserRO",
                "Password" : "$$test$$",
                "ChangePassword" : 0,
                "AccountNeverExpires": 1,
                "Roles":"MyAppRoleRO",
                "Namespace" : "${namespace}"
            }
        },
        "Security.SSLConfigs": {
            "SSLDefault":{}
        },
        "Library.SQLConnection": {
            "SQLConnection1" : {},
            "SQLConnection2" : {}
        },
        "Security.SQLAdminPrivilegeSet" : {
            "${namespace}": [{
                "CreateTable" : 1,
                "Grantee" : "SQLUserRW"
            }]
        },
        "azeruipo" : {
            
        }
    }
    Set sc = ##class(Api.Config.Services.Loader).Load(config)
    Quit sc
]]></Implementation>
</Method>

<Method name="firstAppEnvironment">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    /// zw ##class(Api.Config.Developers.Samples).firstAppEnvironment()
    Set config = {
        "Defaults":{
            "DBDIR" : "${MGRDIR}",
            "WEBAPPDIR" : "${CSPDIR}",
            "DBDATA" : "${DBDIR}myappdata/",
            "DBARCHIVE" : "${DBDIR}myapparchive/",
            "DBCODE" : "${DBDIR}myappcode/",
            "DBLOG" : "${DBDIR}myapplog/"
        },
        "SYS.Databases":{
            "${DBDATA}" : {"ExpansionSize":128},
            "${DBARCHIVE}" : {},
            "${DBCODE}" : {},
            "${DBLOG}" : {}
        },
        "Databases":{
            "MYAPPDATA" : {
                "Directory" : "${DBDATA}"
            },
            "MYAPPCODE" : {
                "Directory" : "${DBCODE}"
            },
            "MYAPPARCHIVE" : {
                "Directory" : "${DBARCHIVE}"
            },
            "MYAPPLOG" : {
                "Directory" : "${DBLOG}"
            }
        },
        "Namespaces":{
            "MYAPP": {
                "Globals":"MYAPPDATA",
                "Routines":"MYAPPCODE"
            }
        },
        "Security.Applications": {
            "/csp/zrestapp": {
                "DispatchClas" : "my.dispatch.class",
                "Namespace" : "MYAPP",
                "Enabled" : "1",
                "AuthEnabled": "64",
                "CookiePath" : "/csp/zrestapp/"
            },
            "/csp/zwebapp": {
                "Path": "${WEBAPPDIR}zwebapp/",
                "Namespace" : "MYAPP",
                "Enabled" : "1",
                "AuthEnabled": "64",
                "CookiePath" : "/csp/zwebapp/"
            }
        },
        "MapGlobals":{
            "MYAPP": [{
                "Name" : "Archive.Data",
                "Database" : "MYAPPARCHIVE"
            },{
                "Name" : "App.Log",
                "Database" : "MYAPPLOG"
            }]
        }
    }
    Set sc = ##class(Api.Config.Services.Loader).Load(config)
    Quit sc
]]></Implementation>
</Method>

<Method name="advanced">
<Description>
zw ##class(Api.Config.Developers.Samples).advanced()</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set config = {
        "Defaults":{
            "DBDIR" : "${MGRDIR}",
            "WEBAPPDIR" : "${CSPDIR}",
            "DBDATA" : "${DBDIR}myappdata/",
            "DBARCHIVE" : "${DBDIR}myapparchive/",
            "DBCODE" : "${DBDIR}myappcode/",
            "DBLOG" : "${DBDIR}myapplog/"
        },
        "SYS.Databases":{
            "${DBDATA}" : {"ExpansionSize":128},
            "${DBARCHIVE}" : {},
            "${DBCODE}" : {},
            "${DBLOG}" : {}
        },
        "Databases":{
            "MYAPPDATA" : {
                "Directory" : "${DBDATA}"
            },
            "MYAPPCODE" : {
                "Directory" : "${DBCODE}"
            },
            "MYAPPARCHIVE" : {
                "Directory" : "${DBARCHIVE}"
            },
            "MYAPPLOG" : {
                "Directory" : "${DBLOG}"
            }
        },
        "Namespaces":{
            "MYAPP": {
                "Globals":"MYAPPDATA",
                "Routines":"MYAPPCODE"
            }
        },
        "Security.Applications": {
            "/csp/zrestapp": {
                "DispatchClas" : "my.dispatch.class",
                "Namespace" : "MYAPP",
                "Enabled" : "1",
                "AuthEnabled": "64",
                "CookiePath" : "/csp/zrestapp/"
            },
            "/csp/zwebapp": {
                "Path": "${WEBAPPDIR}zwebapp/",
                "Namespace" : "MYAPP",
                "Enabled" : "1",
                "AuthEnabled": "64",
                "CookiePath" : "/csp/zwebapp/"
            }
        },
        "MapGlobals":{
            "MYAPP": [{
                "Name" : "Archive.Data",
                "Database" : "MYAPPARCHIVE"
            },{
                "Name" : "App.Log",
                "Database" : "MYAPPLOG"
            }]
        },
        "MapPackages": {
            "MYAPP": [{
                "Namespace" : "MYAPP",
                "Name" : "PackageName",
                "Database" : "USER"
            }]
        },
        "MapRoutines": {
            "MYAPP": [{
                "Namespace" : "MYAPP",
                "Name" : "RoutineName",
                "Database" : "USER"
            }]
        },
        "Journal": {
            "FreezeOnError":1
        },
        "Security.Services":{   
            "%Service_Mirror": {
                "Enabled" : 0
            }
        },
        "SQL": {
            "LockThreshold" : 2500
        },
        "config": {
            "locksiz" : 33554432
        },
        "Startup":{
            "SystemMode" : "DEVELOPMENT"
        }
    }
    Set sc = ##class(Api.Config.Services.Loader).Load(config)
    Quit sc
]]></Implementation>
</Method>

<Method name="TestExport">
<Description>
zw ##class(Api.Config.Developers.Samples).TestExport()
d ##class(Api.Config.Developers.Utils).Show(##class(Api.Config.Developers.Samples).TestExport())</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set filter = {
        "Namespaces": {   
            "${namespace}":""    /* Namespace to export */
        },
        "MapGlobals":{
            "${namespace}":""    /* Export all globals mapping for namespace MYAPP */
        },
        "MapPackages":{ 
            "${namespace}":""    /* Export all packages mapping for namespace MYAPP */
        },
        "MapRoutines":{
            "${namespace}":""    /* Export all routines mapping for namespace MYAPP */
        },
        "Security.Applications":{
            "/csp/zrestapp":"",   /* Export Web applications parameters /csp/zrestapp */
            "/csp/zwebapp":""     /* Export Web applications parameters /csp/zwebapp */
        },
        "Journal":"",  /* Export all journal setting.  *There is a trick to export only non default parameters(see below) */
        "config":"",   /* Export config parameters */
        "Library.SQLConnection":"",
        "Security.Users":"",
        "Security.SQLAdminPrivilegeSet":{
            "${namespace}":""
        },
        "Security.SQLPrivileges":""
    }
    Set OnlyNotDefaultValue = 1
    Set config = ##class(Api.Config.Services.Loader).export(filter,OnlyNotDefaultValue)
    Quit config
]]></Implementation>
</Method>

<Method name="TestExport2">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Set filter = {
        "Namespaces": {   
            "%SYS":""    /* Namespace to export */
        },
        "Journal":"",  /* Export all journal setting.  *There is a trick to export only non default parameters(see below) */
        "config":""   /* Export config parameters */
    }

    Set OnlyNotDefaultValue = 0
    Set config = ##class(Api.Config.Services.Loader).export(filter,OnlyNotDefaultValue)
    Do ##class(Api.Config.Developers.Utils).Show(config)
]]></Implementation>
</Method>

<Method name="TestZPM">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Set config = {
        "ZPM": {
            "${namespace}": [
                {
                    "install":"sslclient"
                }
            ]
        }
    }

    Set sc = ##class(Api.Config.Services.Loader).Load(config)
    W "sc ",$SYSTEM.Status.GetOneErrorText(sc)
    Quit
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Developers.UnitTestsClassGen">
<Description>
Dev helper to generate template UnitTests classes for services.</Description>
<TimeChanged>66011,29866.895887</TimeChanged>
<TimeCreated>66011,29866.895887</TimeCreated>

<Parameter name="PACKAGE">
<Default>UnitTests.Api.Config.Services.</Default>
</Parameter>

<Method name="Gen">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,*unitTestClass:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    ; zw ##class(Api.Config.Developers.UnitTestsClassGen).Gen("Api.Config.Services.Namespaces",.o)
    #define METHODEXISTS(%method)       ##class(%Dictionary.CompiledMethod).%ExistsId(className_"||"_%method)
    
    Set unitTestClass = ..#PACKAGE _ $PIECE(className,"Config.Services.",2)

    #dim class As %Dictionary.ClassDefinition = ##class(%Dictionary.ClassDefinition).%New()
    Set class.Name = unitTestClass
    Set class.ProcedureBlock = $$$YES
    Set class.Super = "%UnitTest.TestCase"

    If $$$METHODEXISTS("Get") {
        Do class.Methods.Insert(..GetMethod(className))
    }

    If $$$METHODEXISTS("Update") {
        Do class.Methods.Insert(..UpdateMethod(className))
    }

    If $$$METHODEXISTS("Create") {
        Do class.Methods.Insert(..CreateMethod(className))
    }

    If $$$METHODEXISTS("List") {
        Do class.Methods.Insert(..ListMethod(className))
    }



    Quit class.%Save()
]]></Implementation>
</Method>

<Method name="ListMethod">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Dictionary.MethodDefinition</ReturnType>
<Implementation><![CDATA[
    #dim method As %Dictionary.MethodDefinition = ##class(%Dictionary.MethodDefinition).%New()
    Set method.Name = "TestList"
    Set method.ReturnType = "%Status"

    Do method.Implementation.WriteLine($CHAR(9)_"Set sc = $$$OK")

    Set listLine = "Set list = ##class(%1).List(%2)"

    If $PARAMETER(className,"ISMAP") {
        Set arg = $PIECE($PARAMETER(className,"PIDENTIFIER"),",",1)
        Do method.Implementation.WriteLine($CHAR(9) _ "Set "_ arg _" = """"" )
        Set listLine = $$$FormatText(listLine, className, arg)

    } Else {
        Set listLine = $$$FormatText(listLine, className, "")
    }

    Do method.Implementation.WriteLine($CHAR(9)_ listLine)
    
    
    
    Do method.Implementation.WriteLine($CHAR(9)_"Quit sc")

    Quit method
]]></Implementation>
</Method>

<Method name="CreateMethod">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Dictionary.MethodDefinition</ReturnType>
<Implementation><![CDATA[
    #dim method As %Dictionary.MethodDefinition = ##class(%Dictionary.MethodDefinition).%New()
    Set method.Name = "TestCreateAndDelete"
    Set method.ReturnType = "%Status"

    Do method.Implementation.WriteLine($CHAR(9)_"Set sc = $$$OK")

    Do method.Implementation.WriteLine($CHAR(9)_"Set model = {}")

    Do method.Implementation.WriteLine($CHAR(9)_ $Replace("Set sc = ##class(%1).Create(model)", "%1",className))

    Do method.Implementation.WriteLine($CHAR(9)_ "Do $$$AssertStatusOK(sc,""Create status"")")

    Set delLine = $Replace("Set sc = ##class(%1).Delete(%2)","%1",className)

    If $PARAMETER(className,"ISMAP") {
        Set args = $PARAMETER(className,"PIDENTIFIER")
        For i=1:1:$LENGTH(args,",") {
            Do method.Implementation.WriteLine($CHAR(9) _ "Set "_$Piece(args,",",i) _" = """"" )
        }
        Set delLine = $$$FormatText(delLine, className, args)

    } Else {
        Set pName = $PARAMETER(className,"PNAME")
        Set:pName="" pName="Name"
        Do method.Implementation.WriteLine($CHAR(9) _ "Set "_pName _" = """"" )
        Set delLine = $$$FormatText(delLine, className, pName)
    }

    Do method.Implementation.WriteLine($CHAR(9)_ delLine)
    Do method.Implementation.WriteLine($CHAR(9)_ "Do $$$AssertStatusOK(sc,""Delete created ressource"")")
    
    
    Do method.Implementation.WriteLine($CHAR(9)_"Quit sc")

    Quit method
]]></Implementation>
</Method>

<Method name="UpdateMethod">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Dictionary.MethodDefinition</ReturnType>
<Implementation><![CDATA[
    #dim method As %Dictionary.MethodDefinition = ##class(%Dictionary.MethodDefinition).%New()
    Set method.Name = "TestUpdate"
    Set method.ReturnType = "%Status"

    Do method.Implementation.WriteLine($CHAR(9)_"Set sc = $$$OK")

    Do method.Implementation.WriteLine($CHAR(9)_"Set model = {}")

    Do method.Implementation.WriteLine($CHAR(9)_ $Replace("Set sc = ##class(%1).Update(model)", "%1",className))

    Do method.Implementation.WriteLine($CHAR(9)_ "Do $$$AssertStatusOK(sc)")

    Do method.Implementation.WriteLine($CHAR(9)_"Quit sc")

    Quit method
]]></Implementation>
</Method>

<Method name="GetMethod">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Dictionary.MethodDefinition</ReturnType>
<Implementation><![CDATA[
    #dim method As %Dictionary.MethodDefinition = ##class(%Dictionary.MethodDefinition).%New()
    Set method.Name = "TestGet"
    Set method.ReturnType = "%Status"

    Do method.Implementation.WriteLine($CHAR(9)_"Set sc = $$$OK")

    Set getLine = $CHAR(9) _ "Set model = ##class(%1).Get(%2)"

    If $PARAMETER(className,"ISSINGLE") {
        Set getLine = $$$FormatText(getLine, className, "")

    } ElseIf $PARAMETER(className,"ISMAP") {

        Set args = $PARAMETER(className,"PIDENTIFIER")
        For i=1:1:$LENGTH(args,",") {
            Do method.Implementation.WriteLine($CHAR(9) _ "Set "_$Piece(args,",",i) _" = """"" )
        }
        Set getLine = $$$FormatText(getLine, className, args)

    } Else {

        Set pName = $PARAMETER(className,"PNAME")
        Set:pName="" pName="Name"
        Do method.Implementation.WriteLine($CHAR(9) _ "Set "_pName _" = """"" )

        Set getLine = $$$FormatText(getLine, className, pName)
        
    }

    
    
    Do method.Implementation.WriteLine(getLine)
    For i=1:1:3 {
        Do method.Implementation.WriteLine($CHAR(9) _ "Set expected = """"")
        Do method.Implementation.WriteLine($CHAR(9) _ "Do $$$AssertTrue(model.%IsDefined(expected),$replace(""Check if property %1 is defined"",""%1"",expected))")
    }
    Do method.Implementation.WriteLine($CHAR(9)_"Quit sc")

    Quit method
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Developers.Utils">
<Description>
Description</Description>
<System>2</System>
<TimeChanged>66011,29866.889698</TimeChanged>
<TimeCreated>66011,29866.889698</TimeCreated>

<Method name="Show">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%DynamicObject</FormalSpec>
<Implementation><![CDATA[
    Set str = ""
    Do ..FormatJSON(model,.str)
    Write !,str
]]></Implementation>
</Method>

<Method name="FormatJSON">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%DynamicObject,*formatted</FormalSpec>
<Implementation><![CDATA[
    If '##class(%Dictionary.CompiledClass).%ExistsId("%JSON.Formatter") { ; hs 2018 compatibility ...
	Set formatted = model.%ToJSON()
	Quit
    }
    Set formatter=##class(%JSON.Formatter).%New()
    Set formatted = ""
    Do formatter.FormatToString(model, .formatted)
    Quit
]]></Implementation>
</Method>

<Method name="buildXmlRelease">
<Description>
zw ##class(Api.Config.Developers.Utils).buildXmlRelease()</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String="/irisrun/repo/dist/config-api_with_dependencies.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    Do:##class(%File).Exists(filename) ##class(%File).Delete(filename)
    Set items = ""
    Set items("Api.Config.inc.INC")=""
    Set items("IORedirect.INC")=""
    Set items("Api.Config.*.CLS")=""
    Set items("IORedirect.*.CLS")=""
    Quit $SYSTEM.OBJ.Export(.items,filename)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Cluster">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29866.968643</TimeChanged>
<TimeCreated>66011,29866.968643</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.Cluster</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.Common.Methods">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.MethodsObjectGenerator</Super>
<TimeChanged>66011,29867.302875</TimeChanged>
<TimeCreated>66011,29867.302875</TimeCreated>

<Parameter name="SYSCLASS">
</Parameter>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit $CLASSMETHOD(..#SYSCLASS, "Exists", Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Name) ""
	$$$switchNSSys
	$$$ThrowOnError($CLASSMETHOD(..#SYSCLASS, "Get", Name,.properties))
	Set properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit $CLASSMETHOD(..#SYSCLASS, "Create",model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit $CLASSMETHOD(..#SYSCLASS, "Modify", model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit $CLASSMETHOD(..#SYSCLASS, "Delete",Name)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Names:%String="*"</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	Set list = [], tmp=0
	Try{
		Do ..ExecQry(Names,.tmp)
	}Catch(ex) {
		
		Throw ex
	}
	
	Set k = ""
	For  {
		Set k = $order(tmp(k),1,v)
		Quit:k=""
		Do list.%Push(..Get(v))
	}
	Return list
]]></Implementation>
</Method>

<Method name="ExecQry">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Names,&tmp]]></FormalSpec>
<Implementation><![CDATA[
	$$$switchNSSys
	Try{
		Set tStatement = ##class(%SQL.Statement).%New()
		Set sc = tStatement.%PrepareClassQuery(..#SYSCLASS,"List")
		If $$$ISERR(sc) $$$ThrowStatus(sc)
		Set tResult = tStatement.%Execute(Names)
		If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
		While tResult.%Next() {
			Set tmp($i(tmp))=tResult.%Get("Name")
		}
		Kill tResult,tStatement
	} Catch(ex) {
		Throw ex
	}

	Quit
]]></Implementation>
</Method>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Common.MethodsObjectGenerator">
<IncludeCode>Api.Config.inc</IncludeCode>
<TimeChanged>66011,29867.296361</TimeChanged>
<TimeCreated>66011,29867.296361</TimeCreated>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<ForceGenerate>1</ForceGenerate>
<Implementation><![CDATA[
	Quit:$get(%parameter("SYSCLASS"))="" 1

	New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS", key = ""

	#dim class As %Dictionary.CompiledClass = ##class(%Dictionary.CompiledClass).%OpenId(%parameter("SYSCLASS"))

    For  {
        Set property = class.Properties.GetNext(.key)
        Quit:key="" 
		Set $NAMESPACE = ns, canContinue = ##class(Api.Config.Developers.Helper).skipProperty(property), $NAMESPACE = "%SYS"
		CONTINUE:canContinue
        Do %code.WriteLine($CHAR(9)_$$$FormatText("Set properties(""%1"") = pObj.%1",property.Name))
    }
	Set $NAMESPACE = ns
	Quit 1
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<ForceGenerate>1</ForceGenerate>
<Implementation><![CDATA[
	;Quit:$lf($lfs(%parameter("NOTIN"),","),%class.Name)>0 1
    Quit:$get(%parameter("SYSCLASS"))="" 1

	New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS", key = ""
    
    
    #dim class As %Dictionary.CompiledClass = ##class(%Dictionary.CompiledClass).%OpenId(%parameter("SYSCLASS"))

    For  {
        Set property = class.Properties.GetNext(.key)
        Quit:key="" 
        Set $NAMESPACE = ns, canContinue = ##class(Api.Config.Developers.Helper).skipProperty(property), $NAMESPACE = "%SYS"
		CONTINUE:canContinue
        Set line = $CHAR(9) _ $$$FormatText("Set:$$$CanSetProperty(model,""%1"") properties(""%1"") = model.%1", property.Name)
        Do %code.WriteLine(line)
    }

    Set $NAMESPACE = ns
	
	Quit 1
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<ForceGenerate>1</ForceGenerate>
<Implementation><![CDATA[
	Quit:$get(%parameter("SYSCLASS"))="" 1

	#define GETTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"number",:"string")
    #define GETSWAGGERTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"integer",:"string")

	New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS", key = ""
    
    
    #dim class As %Dictionary.CompiledClass = ##class(%Dictionary.CompiledClass).%OpenId(%parameter("SYSCLASS"))
	Do %code.WriteLine($CHAR(9) _ "Set model = {}")
    For  {
        Set property = class.Properties.GetNext(.key)
        Quit:key="" 
        Set $NAMESPACE = ns, canContinue = ##class(Api.Config.Developers.Helper).skipProperty(property), $NAMESPACE = "%SYS"
		CONTINUE:canContinue
        Set jsonType = $$$GETTYPE($Replace(property.Type, "Library.",""))
        Do %code.WriteLine($CHAR(9) _ $$$FormatText("Do:$Data(properties(""%1"")) model.%Set(""%1"", properties(""%1""), ""%2"")", property.Name, jsonType))
    }
    Do %code.WriteLine($CHAR(9) _ "Quit model")
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Common.Single">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.MethodsObjectGenerator</Super>
<TimeChanged>66011,29867.315817</TimeChanged>
<TimeCreated>66011,29867.315817</TimeCreated>

<Parameter name="SYSCLASS">
</Parameter>

<Parameter name="ISSINGLE">
<Default>1</Default>
</Parameter>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	$$$ThrowOnError($CLASSMETHOD(..#SYSCLASS, "Get", .properties))
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit $CLASSMETHOD(..#SYSCLASS, "Modify", .properties)
]]></Implementation>
</Method>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Common.SwaggerGenerator">
<Description>
Description</Description>
<TimeChanged>66011,29867.334993</TimeChanged>
<TimeCreated>66011,29867.334993</TimeCreated>

<Method name="GetSwaggerDefinition">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<ReturnType>%DynamicObject</ReturnType>
<ForceGenerate>1</ForceGenerate>
<Implementation><![CDATA[
    Set className = $Get(%parameter("SYSCLASS"))
    Quit:className="" 1

    #define GETTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"number",:"string")
    #define GETSWAGGERTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"integer",:"string")

    Set swaggerDef = {
        "type" : "object",
        "properties" : {},
        "required" : []
    }

    Set template = {}, key=""
    Set swaggerDef.example = template
    New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS"
    
    Set obj = $CLASSMETHOD(className, "%New")
    
    #dim class As %Dictionary.CompiledClass = ##class(%Dictionary.CompiledClass).%OpenId(className)

    For  {
        Set property = class.Properties.GetNext(.key)
        Quit:key="" 
        
        Set $NAMESPACE = ns, skip = ##class(Api.Config.Developers.Helper).skipProperty(property), $NAMESPACE = "%SYS"
        Continue:skip
        Set jsonType = $$$GETTYPE($Replace(property.Type, "Library.",""))
        Set swaggerType = $$$GETSWAGGERTYPE($Replace(property.Type, "Library.",""))
    
        Set dflt = $PROPERTY(obj,property.Name)
        Set:$ISOBJECT(dflt) dflt=""
        ;If dflt=""&&property.Required {
            Do:property.Required swaggerDef.required.%Push(property.Name)
            Do template.%Set(property.Name, dflt, jsonType)
        ;}

        Set $NAMESPACE = ns, description = ##class(Api.Config.Developers.Helper).getPropertyDescription(property.Name, className), $NAMESPACE = "%SYS"

        Do swaggerDef.properties.%Set(property.Name, {
            "type" : (swaggerType),
            "default" : (dflt),
            "description" : (description)
        })
    
    }
    
    

    Set $NAMESPACE = ns

    Set defObj = {}
    Set pName = $tr(className,"%.")
    Do defObj.%Set(pName,swaggerDef)

    If '$Get(%parameter("ISSINGLE"),0) {
        Do defObj.%Set("ListOf"_pName,{
            "type":"object",
            "properties":{
                "list" : {
                    "type":"array",
                    "items": {
                        "$ref": ("#/definitions/" _ pName)
                    }
                }
            }
        })
    }
    Do ##class(Api.Config.Developers.Utils).FormatJSON(defObj,.formatted)
    
    Do %code.WriteLine($char(9) _ "Quit "_$Piece(formatted,$$$NL,1))
    For i=2:1:$l(formatted,$$$NL) {
        Do %code.WriteLine($char(9) _ $Piece(formatted,$$$NL,i))
    }
    
    Quit 1
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.ConfigFile">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29867.009815</TimeChanged>
<TimeCreated>66011,29867.009815</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.ConfigFile</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Version="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Version property is mandatory."))
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Databases">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.034557</TimeChanged>
<TimeCreated>66011,29867.034557</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.Databases</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Directory="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Directory property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Debug">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.044653</TimeChanged>
<TimeCreated>66011,29867.044653</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.Debug</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.DeviceSubTypes">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.067526</TimeChanged>
<TimeCreated>66011,29867.067526</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.DeviceSubTypes</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Devices">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.059279</TimeChanged>
<TimeCreated>66011,29867.059279</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.Devices</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Set:model.PhysicalDevice="" sc = $$$ADDSC(sc,$$$ERROR(5001, "PhysicalDevice property is mandatory."))
	Set:model.SubType="" sc = $$$ADDSC(sc,$$$ERROR(5001, "SubType property is mandatory."))
	Set:model.Type="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Type property is mandatory."))
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.ECP">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29867.080889</TimeChanged>
<TimeCreated>66011,29867.080889</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.ECP</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.ECPServers">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.10247</TimeChanged>
<TimeCreated>66011,29867.10247</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.ECPServers</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Address="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Address property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.IO">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29867.092528</TimeChanged>
<TimeCreated>66011,29867.092528</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.IO</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.Journal">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29867.118342</TimeChanged>
<TimeCreated>66011,29867.118342</TimeCreated>

<Parameter name="SYSCLASS">
<Description>
Description</Description>
<Default>Config.Journal</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.Library.SQLConnection">
<Description>
Description</Description>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.322402</TimeChanged>
<TimeCreated>66011,29867.322402</TimeCreated>

<Parameter name="SYSCLASS">
<Default>%Library.SQLConnection</Default>
</Parameter>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
    Quit ##class(%Library.SQLConnection).NameIndexExists(Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Name) ""
	$$$switchNSSys
	Set obj = ##class(%Library.SQLConnection).NameIndexOpen(Name)
    Do ..ObjectToArray(obj,.properties)
    Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..Update(model)
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
    Set obj = ##class(%Library.SQLConnection).NameIndexOpen(model.Name)
    Set:'$ISOBJECT(obj) obj = ##class(%Library.SQLConnection).%New()
	Set:(model.%IsDefined("DSN")&&($Ascii(model.%Get("DSN"))'=0)) obj.DSN = model.DSN
	Set:(model.%IsDefined("Name")&&($Ascii(model.%Get("Name"))'=0)) obj.Name = model.Name
	Set:(model.%IsDefined("OnConnectStatement")&&($Ascii(model.%Get("OnConnectStatement"))'=0)) obj.OnConnectStatement = model.OnConnectStatement
	Set:(model.%IsDefined("ReverseOJ")&&($Ascii(model.%Get("ReverseOJ"))'=0)) obj.ReverseOJ = model.ReverseOJ
	Set:(model.%IsDefined("URL")&&($Ascii(model.%Get("URL"))'=0)) obj.URL = model.URL
	Set:(model.%IsDefined("Usr")&&($Ascii(model.%Get("Usr"))'=0)) obj.Usr = model.Usr
	Set:(model.%IsDefined("bUnicodeStream")&&($Ascii(model.%Get("bUnicodeStream"))'=0)) obj.bUnicodeStream = model.bUnicodeStream
	Set:(model.%IsDefined("bindTSasString")&&($Ascii(model.%Get("bindTSasString"))'=0)) obj.bindTSasString = model.bindTSasString
	Set:(model.%IsDefined("classpath")&&($Ascii(model.%Get("classpath"))'=0)) obj.classpath = model.classpath
	Set:(model.%IsDefined("driver")&&($Ascii(model.%Get("driver"))'=0)) obj.driver = model.driver
	Set:(model.%IsDefined("isJDBC")&&($Ascii(model.%Get("isJDBC"))'=0)) obj.isJDBC = model.isJDBC
	Set:(model.%IsDefined("needlongdatalen")&&($Ascii(model.%Get("needlongdatalen"))'=0)) obj.needlongdatalen = model.needlongdatalen
	Set:(model.%IsDefined("noconcat")&&($Ascii(model.%Get("noconcat"))'=0)) obj.noconcat = model.noconcat
	Set:(model.%IsDefined("nodefq")&&($Ascii(model.%Get("nodefq"))'=0)) obj.nodefq = model.nodefq
	Set:(model.%IsDefined("nofnconv")&&($Ascii(model.%Get("nofnconv"))'=0)) obj.nofnconv = model.nofnconv
	Set:(model.%IsDefined("nvl")&&($Ascii(model.%Get("nvl"))'=0)) obj.nvl = model.nvl
	Set:(model.%IsDefined("properties")&&($Ascii(model.%Get("properties"))'=0)) obj.properties = model.properties
	Set:(model.%IsDefined("pwd")&&($Ascii(model.%Get("pwd"))'=0)) obj.pwd = model.pwd
	Set:(model.%IsDefined("useCAST")&&($Ascii(model.%Get("useCAST"))'=0)) obj.useCAST = model.useCAST
	Set:(model.%IsDefined("useCASTCHAR")&&($Ascii(model.%Get("useCASTCHAR"))'=0)) obj.useCASTCHAR = model.useCASTCHAR
	Set:(model.%IsDefined("useCOALESCE")&&($Ascii(model.%Get("useCOALESCE"))'=0)) obj.useCOALESCE = model.useCOALESCE
	Set:(model.%IsDefined("xadriver")&&($Ascii(model.%Get("xadriver"))'=0)) obj.xadriver = model.xadriver
    Quit obj.%Save()
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
    Quit ##class(%Library.SQLConnection).NameIndexDelete(Name)
]]></Implementation>
</Method>

<Method name="ExecQry">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Names,&tmp]]></FormalSpec>
<Implementation><![CDATA[
	$$$switchNSSys
	Try{
		Set tStatement = ##class(%SQL.Statement).%New()
		Set sc = tStatement.%PrepareClassQuery(..#SYSCLASS,"ByName")
		If $$$ISERR(sc) $$$ThrowStatus(sc)
		Set tResult = tStatement.%Execute(Names)
		If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
		While tResult.%Next() {
			Set tmp($i(tmp))=tResult.%Get("Connection_Name")
		}
		Kill tResult,tStatement
	} Catch(ex) {
		Throw ex
	}

	Quit
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.LicenseServers">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.116361</TimeChanged>
<TimeCreated>66011,29867.116361</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.LicenseServers</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Loader">
<Description>
Description</Description>
<TimeChanged>66011,29867.135413</TimeChanged>
<TimeCreated>66011,29867.135413</TimeCreated>

<Method name="test">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    ;d ##class(Api.Config.Services.Loader).test()
    

    Set cfg2 = {
        "Defaults":{
            "DBDIR" : "${MGRDIR}",
            "WEBAPPDIR" : "${CSPDIR}",
            "DBDATA" : "${DBDIR}myappdata/",
            "DBARCHIVE" : "${DBDIR}myapparchive/",
            "DBCODE" : "${DBDIR}myappcode/",
            "DBLOG" : "${DBDIR}myapplog/"
        },
        "SYS.Databases":{
            "${DBDATA}" : {"ExpansionSize":128},
            "${DBARCHIVE}" : {},
            "${DBCODE}" : {},
            "${DBLOG}" : {}
        },
        "Databases":{
            "MYAPPDATA" : {
                "Directory" : "${DBDATA}"
            },
            "MYAPPCODE" : {
                "Directory" : "${DBCODE}"
            },
            "MYAPPARCHIVE" : {
                "Directory" : "${DBARCHIVE}"
            },
            "MYAPPLOG" : {
                "Directory" : "${DBLOG}"
            }
        },
        "Namespaces":{
            "MYAPP": {
                "Globals":"MYAPPDATA",
                "Routines":"MYAPPCODE"
            }
        },
        "Security.Applications": {
            "/csp/zrestapp": {
                "DispatchClas" : "my.dispatch.class",
                "Namespace" : "MYAPP",
                "Enabled" : "1",
                "AuthEnabled": "64",
                "CookiePath" : "/csp/zrestapp/"
            },
            "/csp/zwebapp": {
                "Path": "${WEBAPPDIR}",
                "Namespace" : "MYAPP",
                "Enabled" : "1",
                "AuthEnabled": "64",
                "CookiePath" : "/csp/zwebapp/"
            }
        },
        "MapGlobals":{
            "MYAPP": [{
                "Name" : "Archive.Data",
                "Database" : "MYAPPARCHIVE"
            },{
                "Name" : "App.Log",
                "Database" : "MYAPPLOG"
            }]
        },
        "MapPackages": {
            "MYAPP": [{
                "Namespace" : "MYAPP",
                "Name" : "PackageName",
                "Database" : "USER"
            }]
        },
        "MapRoutines": {
            "MYAPP": [{
                "Namespace" : "MYAPP",
                "Name" : "RoutineName",
                "Database" : "USER"
            }]
        },
        "Journal": {
            "FreezeOnError":1
        },
        "Security.Services":{   
            "%Service_Mirror": {
                "Enabled" : 0
            }
        },
        "SQL": {
            "LockThreshold" : 2500
        },
        "config": {
            "locksiz" : 33554432
        },
        "Startup":{
            "SystemMode" : "DEVELOPMENT"
        }
    }
    zw ..Load(cfg2)
]]></Implementation>
</Method>

<Method name="Load">
<Description>
Model can be : 
* a %String with the path to the JSON Document.
* a stream contain JSON Document
* a %DynamicObject</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[model:%DynamicObject,&params]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set params=""
    Set:'$d(params("IFEXISTS")) params("IFEXISTS")="Update"
    Try {
        Set sc = ..commonLoad(model, "Create",.params)
    } Catch(ex) {
        Set sc = ex.AsStatus()
        Do $SYSTEM.Status.DecomposeStatus(sc,.err)
        Zw err
    }
    
    Return sc
]]></Implementation>
</Method>

<Method name="LoadFromInvoke">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%DynamicObject,args...</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set params=""
    If +$g(args)>0 {
        For i=1:2:args {
            Set params(args(i))=$GET(args(i+1))
        }
    }
    ;Set:'$d(params("IFEXISTS")) params("IFEXISTS")="Update"
    Try {
        Set sc = ..commonLoad(model, "Create",.params)
    } Catch(ex) {
        Set sc = ex.AsStatus()
        Do $SYSTEM.Status.DecomposeStatus(sc,.err)
        Zw err
    }
    
    Return sc
]]></Implementation>
</Method>

<Method name="Delete">
<Description>
Delete all namespaces, database, mapping, ... in configuration document.
Be careful...  (return an error on System mode LIVE.)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set startup = ##class(Api.Config.Services.Startup).Get()
    If startup.SystemMode = "LIVE" {
        Quit $$$ERROR(5001, "Not allowed on LIVE system")
    }
    Set params = ""
    Quit ..commonLoad(model, "Delete", .params)
]]></Implementation>
</Method>

<Method name="commonLoad">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[model:%DynamicObject,action:%String,&params:%Binary]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #def1arg    log(%arg)       Do ..log(%arg)
    #define     CFGCLASS(%cls)  "Api.Config.Services."_%cls    
    New $NAMESPACE
    Set sc = $$$OK, sc2 = $$$OK

    If '$ISOBJECT(model) {  ; filename
        Do ..log("Load from file "_model_" ... ")
        If '##class(%File).Exists(model) {
            Do ..log("file not found.",0)
            Quit $$$ERROR(5001, "File not found.")
        }
        #dim file As %Stream.FileCharacter = ##class(%Stream.FileCharacter).%New()
        Do file.LinkToFile(model)
        Set model = {}.%FromJSON(file)
    } ElseIf model.%IsA("%Stream.Object") {
        Do ..log("Load from stream ... ")
        Set model = {}.%FromJSON(model)
    }

    
    ;If model.%IsA()
    
    $$$log("Start load configuration")
    
    Set processedConfig = ..processConfig(model,.params)

    Do ##class(Api.Config.Developers.Utils).FormatJSON(processedConfig, .swaggerString)
    
    $$$log(swaggerString)

    Set iter = processedConfig.%GetIterator()

    While iter.%GetNext(.key,.value) {
        $$$log(" * "_key)
        
        If '##class(%Dictionary.CompiledClass).%ExistsId($$$CFGCLASS(key)) {
            $$$log(" Class not found (skipped)",0)
            CONTINUE
        }
        
        If $$$LOWER(key) = "zpm" {
            Set iterLvl2 = value.%GetIterator()
            While iterLvl2.%GetNext(.keyLvl2,.valueLvl2) {
                Try {
                    Set iterLvl3 = valueLvl2.%GetIterator()
                    While iterLvl3.%GetNext(.keyLvl3,.valueLvl3) { 
                        If $ISOBJECT(valueLvl3) {
                            Set iterLvl4 = valueLvl3.%GetIterator()
                            While iterLvl4.%GetNext(.keyLvl4,.valueLvl4) {
                                $$$log("   + Execute "_keyLvl4 _" "_valueLvl4_" ... ")
                                Set sc2 = ##class(Api.Config.Services.ZPM).Execute(keyLvl2, keyLvl4, valueLvl4, $Get(args("pTerminateOnError"),0))
                                Set:$$$ISERR(sc2) sc = $$$ADDSC(sc,sc2)
                            }
                        } Else {
                            $$$log("   + Execute "_valueLvl3_" ... ")
                            Set sc2 = ##class(Api.Config.Services.ZPM).Execute(keyLvl2,"",valueLvl3, $Get(args("pTerminateOnError"), 0))
                        }
                        
                        Set:$$$ISERR(sc2) sc = $$$ADDSC(sc,sc2)
                    }

                } Catch(ex) {
                    Set sc = $$$ADDSC(sc,ex.AsStatus())
                }
                
            }
            CONTINUE
        }

        Set rAction = action
        Set isSingle = $PARAMETER($$$CFGCLASS(key),"ISSINGLE")=1
        Set isMap = $PARAMETER($$$CFGCLASS(key),"ISMAP")=1

        If isSingle { ; singleton params (only update allowed)
            
            Set:action="Create" rAction = "Update"

            $$$log("   + "_rAction _" "_key_" ... ")

            If action = "Delete" {
                $$$log("Not Allowed (skipping)",0)
                CONTINUE
            }
            
            Set sc2 = $CLASSMETHOD($$$CFGCLASS(key), rAction, value)
            Set sc = $$$ADDSC(sc,sc2)
            $$$log($SYSTEM.Status.GetOneErrorText(sc2),0)
            CONTINUE
        }

        If value.%IsA("%DynamicArray") {
            Set iterLvl2 = value.%GetIterator()
            While iterLvl2.%GetNext(.keyLvl3,.valueLvl2) {
                $$$log("   + "_rAction _" " _ valueLvl2.%ToJSON() _ " ... ")
                If rAction = "Delete" {
                    ; Set sc2 = $CLASSMETHOD($$$CFGCLASS(key), rAction, id1, id2)
                } Else {
                    Set sc2 = $CLASSMETHOD($$$CFGCLASS(key), rAction, valueLvl2)
                }
                Set sc = $$$ADDSC(sc,sc2)
                $$$log($SYSTEM.Status.GetOneErrorText(sc2),0)
            }
            CONTINUE
        }

        Set iterLvl2 = value.%GetIterator()
        While iterLvl2.%GetNext(.keyLvl2,.valueLvl2) {
            Set rAction = action

            If $PARAMETER($$$CFGCLASS(key),"UPDATEONLY") {
                Set:rAction="Create" rAction = "Update"
                If rAction="Delete" {
                    $$$log("Not Allowed (skipping)",0)
                     CONTINUE
                }
               
            }
            

            If isMap {  ; identifier with 2 properties
                
                Set pIDS = $PARAMETER($$$CFGCLASS(key),"PIDENTIFIER")
                ;Set id1 = valueLvl2.%Get($PIECE(pIDS,",",1))
                Set id1 = keyLvl2
                
                Set iterLvl3 = valueLvl2.%GetIterator()
                While iterLvl3.%GetNext(.keyLvl3,.valueLvl3) {
                    Do valueLvl3.%Set($PIECE(pIDS,",",1),id1)
                    Set id2 = valueLvl3.%Get($PIECE(pIDS,",",2))

                    $$$log("   + "_rAction _" " _ id1 _ " " _ id2 _ " ... ")
                    Set exists = $CLASSMETHOD($$$CFGCLASS(key),"Exists",id1, id2)

                    If rAction="Delete" && 'exists {
                        $$$log("Does not exists (skipping)",0)
                        CONTINUE
                    }

                    If rAction="Create" && exists {
                        If $Get(params("IFEXISTS"))="Update" {
                            $$$log("Already exists (updating) ",0)
                            Set rAction = "Update"
                        } Else {
                            $$$log("Already exists (skipping)",0)
                            CONTINUE
                        }
                    }

                    If rAction = "Delete" {
                        Set sc2 = $CLASSMETHOD($$$CFGCLASS(key), rAction, id1, id2)
                    } Else {
                        Set sc2 = $CLASSMETHOD($$$CFGCLASS(key), rAction, valueLvl3)
                    }
                    Set sc = $$$ADDSC(sc,sc2)
                    $$$log($SYSTEM.Status.GetOneErrorText(sc2),0)
                   
                }
                CONTINUE
            }

            Do ..SetName(key,.valueLvl2,keyLvl2)
            $$$log("   + "_rAction _" "_keyLvl2_" ... ")
            
            Set exists = $CLASSMETHOD($$$CFGCLASS(key),"Exists",keyLvl2)

            If rAction="Delete" && 'exists {
                $$$log("Does not exists (skipping)",0)
                CONTINUE
            }

            If rAction="Create" && exists {
                If $Get(params("IFEXISTS"))="Update" {
                    Set rAction = "Update"
                     $$$log("Already exists (updating) ",0)
                } Else {
                    $$$log("Already exists (skipping)",0)
                    CONTINUE
                }
            }
            
            If rAction = "Delete" {
                Set sc2 = $CLASSMETHOD($$$CFGCLASS(key), rAction, keyLvl2)
            } Else {
                Set sc2 = $CLASSMETHOD($$$CFGCLASS(key), rAction, valueLvl2)
            }
            Set sc = $$$ADDSC(sc,sc2)
            $$$log($SYSTEM.Status.GetOneErrorText(sc2),0)
        }
    }

    Return sc
]]></Implementation>
</Method>

<Method name="SetName">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[key:%String,&model:%DynamicObject,keyLvl2:%String]]></FormalSpec>
<Implementation><![CDATA[
    Set nameProperty = $PARAMETER("Api.Config.Services."_key,"PNAME")
    If nameProperty="" {
        Set model.Name = keyLvl2
        Quit
    }
    Do model.%Set(nameProperty, keyLvl2)
    Quit
]]></Implementation>
</Method>

<Method name="log">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>msg:%String,newLine:%Boolean=$$$YES,dtOnNewLine:%Boolean=$$$YES</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Write:newLine !
    Write:newLine&&dtOnNewLine $zdatetime($h,3,1), " "
    Write msg
    Return sc
]]></Implementation>
</Method>

<Method name="export">
<Description>
OnlyNotDefaultValue : properties with the default value won't exported.  
toFile : if you want to export to a file, fill toFile argument with the filepath.  </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filter:%DynamicObject={{}},OnlyNotDefaultValue:%Boolean=1,toFile:%String=""</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    ; Do ##class(Api.Config.Services.Loader).export()
    #define     CFGCLASS(%cls)  "Api.Config.Services."_%cls

    #dim export As %DynamicObject = {}

    #dim processedFilter As %DynamicObject = ..processConfig(filter)
    
    Set iter = processedFilter.%GetIterator()

    While iter.%GetNext(.key,.value) {
        $$$log(" * "_key)
        If '##class(%Dictionary.CompiledClass).%ExistsId($$$CFGCLASS(key)) {
            $$$log(" class not found (skipped)",0)
            CONTINUE
        }
        
        Set isSingle = $PARAMETER($$$CFGCLASS(key),"ISSINGLE")=1
        Set isMap = $PARAMETER($$$CFGCLASS(key),"ISMAP")=1

        If isSingle { ; 

            Set params = $CLASSMETHOD($$$CFGCLASS(key),"Get")
            Do:OnlyNotDefaultValue ..removeDefaultValue(key,.params)
            Do ..ApplyFilter(value,.params)
            Do export.%Set(key, params)
            CONTINUE

        }

        Set tmpObj = {}
        Do export.%Set(key,tmpObj)

        If isMap {
            Set lvl2keyProp = $PIECE($PARAMETER($$$CFGCLASS(key),"PIDENTIFIER"),",",1)
            
            If '$ISOBJECT(value) {
                Set listKey1 = $CLASSMETHOD($$$CFGCLASS(key),"ListKey1")
                Set ptr = 0
                While $LISTNEXT(listKey1,ptr,vlKey1)  {
                    Set lst = $CLASSMETHOD($$$CFGCLASS(key),"List",vlKey1) 
                    Do tmpObj.%Set(vlKey1, lst)
                }
            } Else {

                Set iterList = value.%GetIterator(), lst = []
                While iterList.%GetNext(.keylist,.vl) {
                    Set lst = $CLASSMETHOD($$$CFGCLASS(key),"List",keylist) 
                        Do tmpObj.%Set(keylist, lst)
                    
                }
            }
            CONTINUE
        }

        
        Set lst = [], lvl2keyProp = $PARAMETER($$$CFGCLASS(key),"PNAME")
        Set:lvl2keyProp="" lvl2keyProp="Name"
        
        If $ISOBJECT(value) {

            Set iterList = value.%GetIterator()
            While iterList.%GetNext(.keylist,.vl) {
                
                If $CLASSMETHOD($$$CFGCLASS(key),"Exists",keylist) {
                    Do lst.%Push($CLASSMETHOD($$$CFGCLASS(key),"Get",keylist))
                }
            }

        } Else {
            Set lst = $CLASSMETHOD($$$CFGCLASS(key),"List")
        }

        Set iterList = lst.%GetIterator()
        While iterList.%GetNext(.keylist,.vl) {
            Do tmpObj.%Set($Property(vl,lvl2keyProp), vl)
            Do:OnlyNotDefaultValue ..removeDefaultValue(key,.vl)
        }
    }

    Set formatter=##class(%JSON.Formatter).%New()
    Set exportStr = ""
    Do formatter.FormatToString(export, .exportStr)
    
    If toFile '= "" {
        Do ..toFile(export, toFile)
    }

    Quit export
]]></Implementation>
</Method>

<Method name="ApplyFilter">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[filter:%DynamicObject,&model:%DynamicObject]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    
    if '$ISOBJECT(filter) {
        Quit $$$OK
    }

    Set iter = model.%GetIterator()

    While iter.%GetNext(.key,.value) {
        Do:'filter.%IsDefined(key) model.%Remove(key)
    }

    Quit $$$OK
]]></Implementation>
</Method>

<Method name="removeDefaultValue">
<ClassMethod>1</ClassMethod>
<FormalSpec>key:%String,model:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    /*If key [ "." {
        Set className = key
        Set:$PIECE(className,".")="Library" $PIECE(className,".")="%Library"
    } Else {
        Set className = "Config."_key
    }*/

    Set className = $CLASSMETHOD("Api.Config.Services."_key,"%GetParameter","SYSCLASS")
    New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS"
    Set obj = $CLASSMETHOD(className,"%New")
    Try {
        Set iter = model.%GetIterator()
        While iter.%GetNext(.property,.value) {
            If ##class(%Dictionary.CompiledProperty).%ExistsId(className_"||"_property) {
                
                If $PROPERTY(obj,property)=$PROPERTY(model,property) {
                    Do model.%Remove(property)
                }
            }
        }
    } Catch(ex) {
        Set sc = ex.AsStatus()
    }
    Set $NAMESPACE = ns

    Quit sc
]]></Implementation>
</Method>

<Method name="processConfig">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[config:%DynamicObject,&params]]></FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set:'$ISOBJECT(config.Defaults) config.Defaults = {}
	
	Set processedConfig = config.%ToJSON()
	
	Set installDir = $SYSTEM.Util.InstallDirectory()
	
	Set replaceString("${MGRDIR}") = $SYSTEM.Util.ManagerDirectory()
	Set replaceString("${CSPDIR}") = ##class(%File).NormalizeDirectory("csp", installDir)
    Set replaceString("${BINDIR}") = $SYSTEM.Util.BinaryDirectory()
    Set replaceString("${LIBDIR}") = ##class(%File).NormalizeDirectory("lib", installDir)
    Set replaceString("${NAMESPACE}") = $NAMESPACE
    Set replaceString("${USERNAME}") = $USERNAME
    Set replaceString("${ROLES}") = $ROLES
    Set replaceString("${SYSTEM}") = $SYSTEM
    

    Set replaceString("${mgrdir}") = $SYSTEM.Util.ManagerDirectory()
	Set replaceString("${cspdir}") = ##class(%File).NormalizeDirectory("csp", installDir)
    Set replaceString("${bindir}") = $SYSTEM.Util.BinaryDirectory()
    Set replaceString("${libdir}") = ##class(%File).NormalizeDirectory("lib", installDir)
    Set replaceString("${namespace}") = $NAMESPACE
    Set replaceString("${username}") = $USERNAME
    Set replaceString("${roles}") = $ROLES
    Set replaceString("${system}") = $SYSTEM

    Set k = ""
    For  {
        Set k = $ORDER(params(k),1,value)
        Quit:k=""
        Set replaceString( "${"_k_"}" ) = value
    }

	#dim iter As %Iterator.Object = config.Defaults.%GetIterator()
	
	While iter.%GetNext(.property, .value) {
		Set:'$Data(params(property)) replaceString( "${"_property_"}" ) = value
	}
	
	Do {
		Set i = $Increment(i), var = ""
		
		For  {
			Set var = $Order(replaceString(var), 1, value)
			Quit:var=""
			Set processedConfig = $Replace(processedConfig, var, $zconvert(value,"O","JS"))
		}
		
	} While (i < 3)	
	
    Set model = {}.%FromJSON(processedConfig)
    Do model.%Remove("Defaults")
    Quit model
]]></Implementation>
</Method>

<Method name="toFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>object:%DynamicObject,filename:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set dir = ##class(%File).GetDirectory(filename)
    
    If '##class(%File).DirectoryExists(dir) {
        Set created = ##class(%File).CreateDirectoryChain(dir)
        Quit:'created $$$ERROR(5001, "Fail to create directory chain")
    }

    Set configString = ""
   
    Do ##class(Api.Config.Developers.Utils).FormatJSON(object, .configString)

    #dim file As %Stream.FileCharacter = ##class(%Stream.FileCharacter).%New()
    $$$QuitOnError(file.LinkToFile(filename))
    Do file.Write(configString)
    Quit file.%Save()
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.MagTapes">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.143006</TimeChanged>
<TimeCreated>66011,29867.143006</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.MagTapes</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Set:model.SystemDevice="" sc = $$$ADDSC(sc,$$$ERROR(5001, "SystemDevice property is mandatory."))
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.MapGlobals">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.MethodsObjectGenerator</Super>
<TimeChanged>66011,29867.157437</TimeChanged>
<TimeCreated>66011,29867.157437</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.MapGlobals</Default>
</Parameter>

<Parameter name="ISMAP">
<Default>1</Default>
</Parameter>

<Parameter name="PIDENTIFIER">
<Default>Namespace,Name</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Database="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Database property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Set:model.Namespace="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Namespace property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapGlobals).Create(model.Namespace,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapGlobals).Modify(model.Namespace,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapGlobals).Delete(Namespace,Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapGlobals).Exists(Namespace,Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Namespace,Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.MapGlobals).Get(Namespace,Name,.properties))
	Set properties("Name") = Name, properties("Namespace") = Namespace
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Names:%String="*"</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set tStatement = ##class(%SQL.Statement).%New()
		Set sc = tStatement.%PrepareClassQuery(..#SYSCLASS,"List")
		If $$$ISERR(sc) $$$ThrowStatus(sc)
		Set tResult = tStatement.%Execute(Namespace,Names)
		If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
		While tResult.%Next() {
			;Set tmp($i(tmp))=tResult.%Get("Name")
			Do list.%Push(..Get(Namespace, tResult.%Get("Name")))
		}
		Kill tResult,tStatement

		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ListKey1">
<ClassMethod>1</ClassMethod>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	Set l = ""
	Do ##class(Api.Config.Services.Namespaces).ExecQry("*",.tmp)
	Set key = ""
	For  {
		Set key = $Order(tmp(key),1,k1)
		Quit:key=""
		Set $list(l,key)=k1
	}
	Return l
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.MapMirrors">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.MethodsObjectGenerator</Super>
<TimeChanged>66011,29867.165103</TimeChanged>
<TimeCreated>66011,29867.165103</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.MapMirrors</Default>
</Parameter>

<Parameter name="ISMAP">
<Default>1</Default>
</Parameter>

<Parameter name="PIDENTIFIER">
<Default>ID,Name</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.GUID="" sc = $$$ADDSC(sc,$$$ERROR(5001, "GUID property is mandatory."))
	Set:model.ID="" sc = $$$ADDSC(sc,$$$ERROR(5001, "ID property is mandatory."))
	Set:model.InstanceDirectory="" sc = $$$ADDSC(sc,$$$ERROR(5001, "InstanceDirectory property is mandatory."))
	Set:model.MirrorAddress="" sc = $$$ADDSC(sc,$$$ERROR(5001, "MirrorAddress property is mandatory."))
	Set:model.MirrorSSPort="" sc = $$$ADDSC(sc,$$$ERROR(5001, "MirrorSSPort property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapMirrors).Create(model.ID,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapMirrors).Delete(ID,Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapMirrors).Exists(ID,Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(ID,Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.MapMirrors).Get(ID,Name,.properties))
	Set properties("ID") = ID, properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Names:%String="*"</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set tStatement = ##class(%SQL.Statement).%New()
		Set sc = tStatement.%PrepareClassQuery(..#SYSCLASS,"List")
		If $$$ISERR(sc) $$$ThrowStatus(sc)
		Set tResult = tStatement.%Execute(ID,Names)
		If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
		While tResult.%Next() {
			Do list.%Push(..Get(ID, tResult.%Get("Name")))
		}
		Kill tResult,tStatement
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapMirrors).Modify(model.ID,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="ListKey1">
<ClassMethod>1</ClassMethod>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	Set l = ""
	Do ##class(Api.Config.Services.Mirrors).ExecQry("*",.tmp)
	Set key = ""
	For  {
		Set key = $Order(tmp(key),1,k1)
		Quit:key=""
		Set $list(l,key)=k1
	}
	Return l
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.MapPackages">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.MethodsObjectGenerator</Super>
<TimeChanged>66011,29867.177274</TimeChanged>
<TimeCreated>66011,29867.177274</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.MapPackages</Default>
</Parameter>

<Parameter name="ISMAP">
<Default>1</Default>
</Parameter>

<Parameter name="PIDENTIFIER">
<Default>Namespace,Name</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Database="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Database property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Set:model.Namespace="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Namespace property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapPackages).Create(model.Namespace,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapPackages).Delete(Namespace,Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapPackages).Exists(Namespace,Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Namespace,Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.MapPackages).Get(Namespace,Name,.properties))
	Set properties("Namespace") = Namespace, properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Names:%String="*"</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set tStatement = ##class(%SQL.Statement).%New()
		Set sc = tStatement.%PrepareClassQuery(..#SYSCLASS,"List")
		If $$$ISERR(sc) $$$ThrowStatus(sc)
		Set tResult = tStatement.%Execute(Namespace,Names)
		If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
		While tResult.%Next() {
			Do list.%Push(..Get(Namespace, tResult.%Get("Name")))
		}
		Kill tResult,tStatement
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapPackages).Modify(model.Namespace,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="ListKey1">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Return ##class(Api.Config.Services.MapGlobals).ListKey1()
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.MapRoutines">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.MethodsObjectGenerator</Super>
<TimeChanged>66011,29867.182509</TimeChanged>
<TimeCreated>66011,29867.182509</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.MapRoutines</Default>
</Parameter>

<Parameter name="ISMAP">
<Default>1</Default>
</Parameter>

<Parameter name="PIDENTIFIER">
<Default>Namespace,Name</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Database="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Database property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Set:model.Namespace="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Namespace property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapRoutines).Create(model.Namespace,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapRoutines).Delete(Namespace,Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapRoutines).Exists(Namespace,Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Namespace,Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.MapRoutines).Get(Namespace,Name,.properties))
	Set properties("Namespace") = Namespace, properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Names:%String="*"</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set tStatement = ##class(%SQL.Statement).%New()
		Set sc = tStatement.%PrepareClassQuery(..#SYSCLASS,"List")
		If $$$ISERR(sc) $$$ThrowStatus(sc)
		Set tResult = tStatement.%Execute(Namespace,Names)
		If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
		While tResult.%Next() {
			Do list.%Push(..Get(Namespace, tResult.%Get("Name")))
		}
		Kill tResult,tStatement
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapRoutines).Modify(model.Namespace,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="ListKey1">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Return ##class(Api.Config.Services.MapGlobals).ListKey1()
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.MapShadows">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.MethodsObjectGenerator</Super>
<TimeChanged>66011,29867.201499</TimeChanged>
<TimeCreated>66011,29867.201499</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.MapShadows</Default>
</Parameter>

<Parameter name="ISMAP">
<Default>1</Default>
</Parameter>

<Parameter name="PIDENTIFIER">
<Default>ID,Name</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Directory="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Directory property is mandatory."))
	Set:model.ID="" sc = $$$ADDSC(sc,$$$ERROR(5001, "ID property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapShadows).Create(model.ID,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapShadows).Delete(ID,Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapShadows).Exists(ID,Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(ID,Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.MapShadows).Get(ID,Name,.properties))
	Set properties("ID") = ID, properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Names:%String="*"</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set tStatement = ##class(%SQL.Statement).%New()
		Set sc = tStatement.%PrepareClassQuery(..#SYSCLASS,"List")
		If $$$ISERR(sc) $$$ThrowStatus(sc)
		Set tResult = tStatement.%Execute(ID,Names)
		If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
		While tResult.%Next() {
			Do list.%Push(..Get(ID, tResult.%Get("Name")))
		}
		Kill tResult,tStatement
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapShadows).Modify(model.ID,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="ListKey1">
<ClassMethod>1</ClassMethod>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	Set l = ""
	Do ##class(Api.Config.Services.Shadows).ExecQry("*",.tmp)
	Set key = ""
	For  {
		Set key = $Order(tmp(key),1,k1)
		Quit:key=""
		Set $list(l,key)=k1
	}
	Return l
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.MirrorMember">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29867.191594</TimeChanged>
<TimeCreated>66011,29867.191594</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.MirrorMember</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.Mirrors">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.221948</TimeChanged>
<TimeCreated>66011,29867.221948</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.Mirrors</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="ExecQry">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Names,&tmp]]></FormalSpec>
<Implementation><![CDATA[
	$$$switchNSSys
	Try{
		Set rs = ##class(%ResultSet).%New(..#SYSCLASS_":List")
		Set sc = rs.Execute(Names)
		If $$$ISERR(sc) $$$ThrowStatus(sc)
		While rs.Next() {
			Set tmp($i(tmp))=rs.Get("Name")
		}
		Do rs.Close()
		Kill rs
	} Catch(ex) {
		Throw ex
	}

	Quit
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Miscellaneous">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29867.203646</TimeChanged>
<TimeCreated>66011,29867.203646</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.Miscellaneous</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.Monitor">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29867.218618</TimeChanged>
<TimeCreated>66011,29867.218618</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.Monitor</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.Namespaces">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.224768</TimeChanged>
<TimeCreated>66011,29867.224768</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.Namespaces</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Globals="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Globals property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Set:model.Routines="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Routines property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="ExecQry">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Names,&tmp]]></FormalSpec>
<Implementation><![CDATA[
	$$$switchNSSys
	Try{
		Set tStatement = ##class(%SQL.Statement).%New()
		Set sc = tStatement.%PrepareClassQuery(..#SYSCLASS,"List")
		If $$$ISERR(sc) $$$ThrowStatus(sc)
		Set tResult = tStatement.%Execute(Names)
		If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
		While tResult.%Next() {
			Set tmp($i(tmp))=tResult.%Get("Namespace")
		}
		Kill tResult,tStatement
	} Catch(ex) {
		Throw ex
	}

	Quit
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.SQL">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29867.246412</TimeChanged>
<TimeCreated>66011,29867.246412</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.SQL</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.SYS.Databases">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.MethodsObjectGenerator</Super>
<TimeChanged>66011,29867.352326</TimeChanged>
<TimeCreated>66011,29867.352326</TimeCreated>

<Parameter name="SYSCLASS">
<Default>SYS.Database</Default>
</Parameter>

<Parameter name="PNAME">
<Default>Directory</Default>
</Parameter>

<Parameter name="PIDENTIFIER">
<Default>Directory</Default>
</Parameter>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Do:'##class(%File).DirectoryExists(model.Directory) ##class(%File).CreateDirectoryChain(model.Directory)
    Set db=##Class(SYS.Database).%New()
    Set lbProperties = $$$DBSysCreateProperties
    Do ..ToArray(model, .properties)
    Set key = ""
    For  {
        Set key = $Order(properties(key),1,value)
        Quit:key=""
        If ''$LISTFIND(lbProperties,key) {  ; can set this property on create.
            Set $Property(db, key) = value
        }
    }
	Quit db.%Save()
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(SYS.Database).DeleteDatabase(Directory)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$switchNSSys
    Quit ##class(SYS.Database).%ExistsId(Directory)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Directory) ""
	$$$switchNSSys
    Set DBObj = ##class(SYS.Database).%OpenId(Directory,,.sc)
    If $$$ISERR(sc) $$$ThrowStatus(sc)
    Do ..ObjectToArray(DBObj, .properties)
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>mask:%String="*"</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
    $$$switchNSSys
    Set dbList = []
	Try{
        Set tStatement = ##class(%SQL.Statement).%New()
        Set sc = tStatement.%PrepareClassQuery(..#SYSCLASS,"CompactLocalList")
        If $$$ISERR(sc) $$$ThrowStatus(sc)
        Set tResult = tStatement.%Execute(mask)
        If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
		While tResult.%Next() {
            Do dbList.%Push(..Get(tResult.%Get("Directory")))
        }
		kill tStatement, tResult
        $$$restoreNS

	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return dbList
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
    Set db=##Class(SYS.Database).%OpenId(model.Directory,,.sc)
    If $$$ISERR(sc) $$$ThrowStatus(sc)
    
    Set lbProperties = $$$DBSysUpdateProperties

    Set key = ""
    For  {
        Set key = $Order(properties(key),1,value)
        Quit:key=""
        If ''$LISTFIND(lbProperties,key) {  ; can set this property on update.
            Set $Property(db, key) = value
        }
    }
	Quit db.%Save()
]]></Implementation>
</Method>

<Method name="Dismount">
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$switchNSSys
    Set db = ##class(SYS.Database).%OpenId(Directory,,.sc)
    If $$$ISERR(sc) $$$ThrowStatus(sc)
    Quit:'db.Mounted $$$OK
    Quit db.Dismount()
]]></Implementation>
</Method>

<Method name="Mount">
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String,readOnly:%Boolean=$$$NO</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$switchNSSys
    Set db = ##class(SYS.Database).%OpenId(Directory,,.sc)
    If $$$ISERR(sc) $$$ThrowStatus(sc)
    If db.Mounted && (db.ReadOnlyMounted'=readOnly) {
        $$$ThrowOnError(db.Dismount())
    }
    Quit db.Mount(+readOnly)
]]></Implementation>
</Method>

<Method name="GetMountState">
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    $$$switchNSSys
    Set db = ##class(SYS.Database).%OpenId(Directory,,.sc)
    If $$$ISERR(sc) {
        $$$ThrowStatus(sc)
    }

    #dim mountState As %Library.DynamicObject = {}
    Do mountState.%Set("Directory", db.Directory, "string")
    Do mountState.%Set("Mounted", db.Mounted, "boolean")
    Do mountState.%Set("ReadOnlyMounted", db.ReadOnlyMounted, "boolean")
    
    Quit mountState
]]></Implementation>
</Method>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.SYS.MirrorFailOver">
<Super>Api.Config.Services.Common.MethodsObjectGenerator</Super>
<TimeChanged>66011,29867.346998</TimeChanged>
<TimeCreated>66011,29867.346998</TimeCreated>

<Method name="JoinMirrorAsFailoverMember">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>config:%DynamicObject,localInfo:%DynamicObject,SSLConfig:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Do:$ISOBJECT($Get(localInfo)) ##class(Api.Config.Services.SYS.MirrorMaster).ToArray(localInfo, .pLocalInfo)
    Do:$ISOBJECT($Get(SSLConfig)) ##class(Api.Config.Services.SYS.MirrorMaster).ToArray(SSLConfig,.SSLInfo)
    
    $$$switchNSSys

    Set sc = ##class(SYS.Mirror).JoinMirrorAsFailoverMember(config.Name,config.SystemName,config.InstanceName,config.AgentAddress,config.AgentPort,.pLocalInfo, .SSLInfo)
    Return:$$$ISERR(sc) sc

    Do ##Class(Config.Mirrors).Get(config.Name,.Properties)
    $$$restoreNS

    If +Properties("UseSSL") {
        Do:$g(%zverbose,1) ##class(Api.Config.Services.Loader).log("   = This member must be approved on primary instance, check (while max 120 sec.)  ")
        Set end = $zh+120
        While $zh < end {
            Hang 2
            Set memberStatus = $SYSTEM.Mirror.GetStatus()
            Do:$g(%zverbose,1) ##class(Api.Config.Services.Loader).log("     - Current status "_memberStatus)
            Quit:"backupconnectedsynchronizing"[$$$LOWER(memberStatus)
        }
    }

    Return sc
]]></Implementation>
</Method>

<Method name="JoinMirrorAsAsyncMember">
<ClassMethod>1</ClassMethod>
<FormalSpec>config:%DynamicObject,localInfo:%DynamicObject,SSLConfig:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Do:$ISOBJECT($Get(localInfo)) ##class(Api.Config.Services.SYS.MirrorMaster).ToArray(localInfo, .pLocalInfo)
    Do:$ISOBJECT($Get(SSLConfig)) ##class(Api.Config.Services.SYS.MirrorMaster).ToArray(SSLConfig, .SSLInfo)
    Set type = $CASE($$$LOWER(config.AsyncMemberType),"disasterrecovery":0,"dr":0,"readonlyreporting":1,"roreporting":1,"ro":1,"readwritereporting":2,"rwreporting":2,"rw":2,:0)
    
    $$$switchNSSys
    
    Set sc =  ##class(SYS.Mirror).JoinMirrorAsAsyncMember(config.Name,config.SystemName,config.InstanceName,config.AgentAddress,config.AgentPort,type, .pLocalInfo, .SSLInfo)
    Return:$$$ISERR(sc) sc

    Do ##Class(Config.Mirrors).Get(config.Name,.Properties)
    $$$restoreNS

    If +Properties("UseSSL") {
        Do:$g(%zverbose,1) ##class(Api.Config.Services.Loader).log("   = This member must be approved on primary instance, check (while max 120 sec.)  ")
        Set end = $zh+120
        While $zh < end {
            Hang 2
            Set memberStatus = $SYSTEM.Mirror.GetStatus()
            Do:$g(%zverbose,1) ##class(Api.Config.Services.Loader).log("     - Current status "_memberStatus)
            Quit:"backupconnectedsynchronizing"[$$$LOWER(memberStatus)
        }
    }
    
    Return sc
]]></Implementation>
</Method>

<Method name="ActivateMirroredDBs">
<ClassMethod>1</ClassMethod>
<FormalSpec>DBList:%DynamicArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Set iter = DBList.%GetIterator()

    While iter.%GetNext(.key , .value ) {
        Hang 3
        $$$switchNSSys
        
        Set sc2 = ##class(SYS.Mirror).ActivateMirroredDatabase(value.Directory)
        Set:$$$ISERR(sc2) sc = $$$ADDSC(sc,sc2)
        $$$restoreNS
        Do:$g(%zverbose,1) ##class(Api.Config.Services.Loader).log($$$FormatText("   + Activate mirrored database %1 : %2",value.Directory, $SYSTEM.Status.GetOneErrorText(sc2)))
        
        Set sfn = +$zu(49, value.Directory)
        $$$switchNSSys
        set sc3 = ##class(SYS.Mirror).CatchupDB($lb(sfn))
        $$$restoreNS
        Do:$g(%zverbose,1) ##class(Api.Config.Services.Loader).log($$$FormatText("   + Catch up database %1 (sfn's %2) : %3",value.Directory, sfn, $SYSTEM.Status.GetOneErrorText(sc3)))
    
    }

    Return sc
]]></Implementation>
</Method>

<Method name="Create">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    If 'model.Config.AsyncMember {
        Set sc = ..JoinMirrorAsFailoverMember(model.Config, model.LocalInfo, model.SSLInfo)
    } Else {
        Set sc = ..JoinMirrorAsAsyncMember(model.Config, model.LocalInfo, model.SSLInfo)
    }
    Return:$$$ISERR(sc) sc
    Return ..ActivateMirroredDBs(model.Databases)
]]></Implementation>
</Method>

<Method name="Update">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Return $$$ERROR($$$NotImplemented)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[    Quit $$$NO
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.SYS.MirrorMaster">
<Description>
Description</Description>
<Super>Api.Config.Services.Common.MethodsObjectGenerator</Super>
<TimeChanged>66011,29867.346644</TimeChanged>
<TimeCreated>66011,29867.346644</TimeCreated>

<Method name="Update">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = ##class(Api.Config.Services.Mirrors).Update(model)
    Return:$$$ISERR(sc) sc

    Return ..AddDBToMirror(model.DataBases)
]]></Implementation>
</Method>

<Method name="CreateNewMirrorSet">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,SSLConfig:%Library.DynamicObject=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Hang 2 ; test waiting activation service mirror.
    Do ..ToArray(model,.properties)
    If $ISOBJECT($Get(SSLConfig)) {
        Do ..ToArray(SSLConfig,.SSLInfo)
    }
    $$$switchNSSys
    set sc = ##class(SYS.Mirror).CreateNewMirrorSet(model.Name, model.SystemName, .properties, .SSLInfo)
    
    Return:$$$ISERR(sc)

    $$$restoreNS

    Do:$g(%zverbose,1) ##class(Api.Config.Services.Loader).log("   = Wait became primary, checking while max 120 sec.  ")
    Set end = $zh+120
    While $zh < end {
        Hang 5
        Set memberStatus = $SYSTEM.Mirror.GetStatus()
        Do:$g(%zverbose,1) ##class(Api.Config.Services.Loader).log("     - Current status "_memberStatus)
        Quit:"primary"[$$$LOWER(memberStatus)
    }
    
    Do ##class(Api.Config.Services.Loader).log($$$FormatText("   + Create MirrorSet %1 : %2", model.Name, $SYSTEM.Status.GetOneErrorText(sc)))
    Return sc
]]></Implementation>
</Method>

<Method name="AddDBToMirror">
<ClassMethod>1</ClassMethod>
<FormalSpec>DBList:%DynamicArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Return:'$ISOBJECT(DBList) $$$OK
    Set sc = $$$OK
    Set iter = DBList.%GetIterator()
    
    While iter.%GetNext(.key , .value ) {
        Do ##class(Api.Config.Services.SYS.Databases).Mount(value.Directory)
        Hang 2
        $$$switchNSSys
        Set sc2 = ##class(SYS.Mirror).AddDatabase(value.Directory, value.MirrorDBName)
        Set:$$$ISERR(sc2) sc = $$$ADDSC(sc,sc2)
        Hang 2
        $$$restoreNS
        Do:$g(%zverbose,1) ##class(Api.Config.Services.Loader).log($$$FormatText("   + Add Database %1 to mirror with DB MirrorName %2 : %3",value.Directory, value.MirrorDBName, $SYSTEM.Status.GetOneErrorText(sc2)))    
    }

    Return sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = ..CreateNewMirrorSet(model.Config, model.SSLInfo)
    Return:$$$ISERR(sc) sc
    Return ..AddDBToMirror(model.Databases)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[    Quit ##class(Api.Config.Services.Mirrors).Exists(Name)
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
    Set iter = model.%GetIterator()

    While iter.%GetNext(.key , .value ) {
        Set properties(key) = value
    }

    Return
]]></Implementation>
</Method>

<Method name="AuthorizeNewMembers">
<ClassMethod>1</ClassMethod>
<FormalSpec>members:%String="backup,report",mirrorName:%String="DEMO",timeInSecond:%Integer=1800</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    ;Job ##class(Api.Config.Services.SYS.MirrorMaster).AuthorizeNewMembers()
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"

    Set sc = $$$OK, pProxy = { "Members":($zcvt(members,"u")),"MirrorName":($zcvt(mirrorName,"u"))}, end = $zh+timeInSecond
    While $zh < end {
        Do ##class(%CSP.UI.Portal.Mirror.EditFailover).AuthorizeNewMembers(pProxy)
        Hang 3
    }

    Return sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Security.Applications">
<Description>
Description</Description>
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.374386</TimeChanged>
<TimeCreated>66011,29867.374386</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Security.Applications</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.Security.GenericExport">
<Description>
Description</Description>
<TimeChanged>66011,29867.38457</TimeChanged>
<TimeCreated>66011,29867.38457</TimeCreated>

<Method name="ExportAll">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Directory:%String=..GetDefaultExportPath(),&Files:%Binary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Kill Files
    
    Set XData = ##class(%Dictionary.CompiledXData).%OpenId($CLASSNAME()_"||ExportAll")
    Set JsonList = {}.%FromJSON($REPLACE(XData.Data.Read(),"{ExportDir}",##class(%File).NormalizeDirectory(Directory)))

    Set iter = JsonList.%GetIterator()

    While iter.%GetNext(.key , .value ) {
        Set properties(key) = value
        Set sc = $CLASSMETHOD($CLASSNAME(),value.ClassMethod,value.Filename)
        Quit:$$$ISERR(sc)
        Set Files(value.ClassMethod) = value.Filename
    }

    Return sc
]]></Implementation>
</Method>

<Method name="Applications">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"ApplicationsExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.Applications).Export(Filename, , "*", 14)
]]></Implementation>
</Method>

<Method name="DocDBs">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"DocDBsExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.DocDBs).Export(Filename, , "*", "*")
]]></Implementation>
</Method>

<Method name="Users">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"UsersExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.Users).Export(Filename,,,,$$$YES)
]]></Implementation>
</Method>

<Method name="Roles">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"RolesExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.Roles).Export(Filename,,,,$$$YES)
]]></Implementation>
</Method>

<Method name="Resources">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"ResourcesExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.Resources).Export(Filename,,,,$$$YES)
]]></Implementation>
</Method>

<Method name="Services">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"ServicesExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.Services).Export(Filename,,"*")
]]></Implementation>
</Method>

<Method name="SSLConfigs">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"SSLConfigsExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.SSLConfigs).Export(Filename,,"*")
]]></Implementation>
</Method>

<Method name="X509Users">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"X509UsersExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.X509Users).Export(Filename)
]]></Implementation>
</Method>

<Method name="SQLPrivileges">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"SQLPrivilegesExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.SQLPrivileges).Export(Filename)
]]></Implementation>
</Method>

<Method name="SQLAdminPrivilegeSet">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"SQLAdminPrivilegesSetExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.SQLAdminPrivilegeSet).Export(Filename)
]]></Implementation>
</Method>

<Method name="SQLRoleGrantOption">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"SQLRoleGrantOptionExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.SQLRoleGrantOption).Export(Filename)
]]></Implementation>
</Method>

<Method name="System">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"SystemExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.System).Export(Filename)
]]></Implementation>
</Method>

<Method name="LDAPConfigs">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"LDAPConfigsExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.LDAPConfigs).Export(Filename)
]]></Implementation>
</Method>

<Method name="KMIPServer">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"KMIPServerExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.KMIPServer).Export(Filename)
]]></Implementation>
</Method>

<Method name="DeleteExportDir">
<ClassMethod>1</ClassMethod>
<FormalSpec>exportDir:%String=..GetDefaultExportPath()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Do ##class(%File).RemoveDirectoryTree(exportDir)
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetDefaultExportPath">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    Set directory = ##class(%File).NormalizeDirectory($SYSTEM.Util.ManagerDirectory()_"tmp_export/")
    Do:'##class(%File).DirectoryExists(directory) ##class(%File).CreateDirectoryChain(directory)
    Return directory
]]></Implementation>
</Method>

<XData name="ExportAll">
<Description>
Description</Description>
<MimeType>application/json</MimeType>
<Data><![CDATA[
[
    {
        "ClassMethod" : "Roles",
        "Filename" : "{ExportDir}RolesExport.xml"
    },
    {
        "ClassMethod" : "Resources",
        "Filename" : "{ExportDir}ResourcesExport.xml"
    },
    {
        "ClassMethod" : "Users",
        "Filename" : "{ExportDir}UsersExport.xml"
    },
    {
        "ClassMethod" : "Applications",
        "Filename" : "{ExportDir}ApplicationsExport.xml"
    },
    {
        "ClassMethod" : "DocDBs",
        "Filename" : "{ExportDir}DocDBsExport.xml"
    },
    {
        "ClassMethod" : "Services",
        "Filename" : "{ExportDir}ServicesExport.xml"
    },
    {
        "ClassMethod" : "SSLConfigs",
        "Filename" : "{ExportDir}SSConfigsExport.xml"
    },
    {
        "ClassMethod" : "X509Users",
        "Filename" : "{ExportDir}X509UsersExport.xml"
    },
    {
        "ClassMethod" : "SQLPrivileges",
        "Filename" : "{ExportDir}SQLPrivilegesExport.xml"
    },
    {
        "ClassMethod" : "SQLAdminPrivilegeSet",
        "Filename" : "{ExportDir}SQLAdminPrivilegeSetExport.xml"
    },
    {
        "ClassMethod" : "SQLRoleGrantOption",
        "Filename" : "{ExportDir}SQLRoleGrantOptionExport.xml"
    },
    {
        "ClassMethod" : "System",
        "Filename" : "{ExportDir}SystemExport.xml"
    },
    {
        "ClassMethod" : "LDAPConfigs",
        "Filename" : "{ExportDir}LDAPConfigsExport.xml"
    },
    {
        "ClassMethod" : "KMIPServer",
        "Filename" : "{ExportDir}KMIPServerExport.xml"
    }
]
]]></Data>
</XData>
</Class>


<Class name="Api.Config.Services.Security.LDAPConfigs">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.392944</TimeChanged>
<TimeCreated>66011,29867.392944</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Security.LDAPConfigs</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.Security.Resources">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.379588</TimeChanged>
<TimeCreated>66011,29867.379588</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Security.Resources</Default>
</Parameter>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit $CLASSMETHOD(..#SYSCLASS, "Create",model.Name,model.Description, model.PublicPermission,model.Type)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Security.Roles">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.408323</TimeChanged>
<TimeCreated>66011,29867.408323</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Security.Roles</Default>
</Parameter>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit $CLASSMETHOD(..#SYSCLASS, "Create",model.Name,model.Description, model.Resources,model.GrantedRoles)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Security.SQLAdminPrivilegeSet">
<Description>
Description</Description>
<Super>Api.Config.Services.Common.MethodsObjectGenerator</Super>
<TimeChanged>66011,29867.413939</TimeChanged>
<TimeCreated>66011,29867.413939</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Security.SQLAdminPrivilegeSet</Default>
</Parameter>

<Parameter name="ISMAP">
<Default>1</Default>
</Parameter>

<Parameter name="PIDENTIFIER">
<Default>Namespace,Grantee</Default>
</Parameter>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Grantee:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Security.SQLAdminPrivilegeSet).IDKeyExists(Namespace, Grantee)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Grantee:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Namespace, Grantee) ""
	$$$switchNSSys
	Set obj = ##class(Security.SQLAdminPrivilegeSet).IDKeyOpen(Namespace, Grantee)
	Do ..ObjectToArray(.obj,.properties)
    Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..Update(model)
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	
    Set obj = ##class(Security.SQLAdminPrivilegeSet).IDKeyOpen(model.Namespace,model.Grantee)
    Set:'$ISOBJECT(obj) obj = ##class(Security.SQLAdminPrivilegeSet).%New()

    Set obj.Namespace = model.Namespace
    Set obj.Grantee = model.Grantee

    Set obj.AlterTable = model.AlterTable
	Set obj.AlterView = model.AlterView
	Set obj.CreateFunction = model.CreateFunction
	Set obj.CreateMethod = model.CreateMethod
	Set obj.CreateProcedure = model.CreateProcedure
	Set obj.CreateQuery = model.CreateQuery
	Set obj.CreateTable = model.CreateTable
	Set obj.CreateTrigger = model.CreateTrigger
	Set obj.CreateView = model.CreateView
	Set obj.DropFunction = model.DropFunction
	Set obj.DropMethod = model.DropMethod
	Set obj.DropProcedure = model.DropProcedure
	Set obj.DropQuery = model.DropQuery
	Set obj.DropTable = model.DropTable
	Set obj.DropTrigger = model.DropTrigger
	Set obj.DropView = model.DropView
	Set obj.NoCheck = model.NoCheck
	Set obj.NoIndex = model.NoIndex
	Set obj.NoLock = model.NoLock
	Set obj.NoTrigger = model.NoTrigger 
    Quit obj.%Save()
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Grantee:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Security.SQLAdminPrivilegeSet).IDKeyDelete(Namespace, Grantee)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String="*"</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	Set list = [], tmp=0
	Try{
		Do ..ExecQry(.tmp)
	}Catch(ex) {
		
		Throw ex
	}
	
	Set k = ""
	For  {
		Set k = $order(tmp(k),1,v)
		Quit:k=""
		
		If Namespace = "*" {
			Do list.%Push(..Get($lg(v,1),$lg(v,2)))
			
		} ElseIf Namespace = $lg(v,1) {
			Do list.%Push(..Get($lg(v,1),$lg(v,2)))
		}


	}
	Return list
]]></Implementation>
</Method>

<Method name="ExecQry">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&tmp]]></FormalSpec>
<Implementation><![CDATA[
	$$$switchNSSys
	Try{
		Set rs=##class(%Library.ResultSet).%New(..#SYSCLASS_":List")
		Do rs.Execute()
		While rs.Next() {
			Set tmp($i(tmp))=$lb(rs.Data("Namespace"),rs.Data("Grantee"))
		}
		Do rs.Close()
	}Catch(ex) {
		Throw ex
	}
	Kill rs
	Quit
]]></Implementation>
</Method>

<Method name="ListKey1">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Return ##class(Api.Config.Services.MapGlobals).ListKey1()
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/*ClassMethod ExecQry(ByRef tmp)
{
	$$$switchNSSys
	Try{
		Set tStatement = ##class(%SQL.Statement).%New()
		Set sc = tStatement.%PrepareClassQuery(..#SYSCLASS,"List")
		If $$$ISERR(sc) $$$ThrowStatus(sc)
		Set tResult = tStatement.%Execute()
		If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
		While tResult.%Next() {
			Set tmp($i(tmp))=$lb(tResult.%Get("Namespace"),tResult.%Get("Grantee"))
		}
		Kill tResult,tStatement
	} Catch(ex) {
		Throw ex
	}

	Quit
}*/
]]></Content>
</UDLText>
</Class>


<Class name="Api.Config.Services.Security.SSLConfigs">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.433817</TimeChanged>
<TimeCreated>66011,29867.433817</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Security.SSLConfigs</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.Security.Services">
<Description>
Description</Description>
<IncludeCode>Api.Config.inc</IncludeCode>
<TimeChanged>66011,29867.405028</TimeChanged>
<TimeCreated>66011,29867.405028</TimeCreated>

<Parameter name="UPDATEONLY">
<Default>1</Default>
</Parameter>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Security.Services).Exists(Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Security.Services).Get(Name,.properties))
	Set properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Security.Services).Modify(model.Name,.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Names:%String="*"</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set rs=##class(%Library.ResultSet).%New("Security.Services:List")
		Do rs.Execute(Names)
		While rs.Next() {
			Do list.%Push(..Get(rs.Data("Name")))
		}
		Do rs.Close()
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("AutheEnabled") = pObj.AutheEnabled
	Set properties("ClientSystems") = pObj.ClientSystems
	Set properties("Description") = pObj.Description
	Set properties("Enabled") = pObj.Enabled
	Set properties("Name") = pObj.Name
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"AutheEnabled") properties("AutheEnabled") = model.AutheEnabled
	Set:$$$CanSetProperty(model,"ClientSystems") properties("ClientSystems") = model.ClientSystems
	Set:$$$CanSetProperty(model,"Description") properties("Description") = model.Description
	Set:$$$CanSetProperty(model,"Enabled") properties("Enabled") = model.Enabled
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("AutheEnabled")) model.%Set("AutheEnabled", properties("AutheEnabled"), "string")
	Do:$Data(properties("ClientSystems")) model.%Set("ClientSystems", properties("ClientSystems"), "string")
	Do:$Data(properties("Description")) model.%Set("Description", properties("Description"), "string")
	Do:$Data(properties("Enabled")) model.%Set("Enabled", properties("Enabled"), "boolean")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Quit model
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Security.Users">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.438696</TimeChanged>
<TimeCreated>66011,29867.438696</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Security.Users</Default>
</Parameter>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
    kill properties("Name")
	Quit $CLASSMETHOD(..#SYSCLASS, "Create",model.Name,.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Shadows">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.246379</TimeChanged>
<TimeCreated>66011,29867.246379</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.Shadows</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Address="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Address property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.SqlSysDatatypes">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.253533</TimeChanged>
<TimeCreated>66011,29867.253533</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.SqlSysDatatypes</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Datatype="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Datatype property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.SqlUserDatatypes">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.250029</TimeChanged>
<TimeCreated>66011,29867.250029</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.SqlUserDatatypes</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Datatype="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Datatype property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Startup">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29867.287601</TimeChanged>
<TimeCreated>66011,29867.287601</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.Startup</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.Telnet">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29867.287464</TimeChanged>
<TimeCreated>66011,29867.287464</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.Telnet</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.ZPM">
<Description>
Description</Description>
<TimeChanged>66011,29867.272407</TimeChanged>
<TimeCreated>66011,29867.272407</TimeCreated>

<Method name="Execute">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,command:%String,args:%String="",pTerminateOnError:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = namespace
    Quit ##class(%ZPM.PackageManager).Shell(command _ " " _ args, pTerminateOnError)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.config">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29867.012507</TimeChanged>
<TimeCreated>66011,29867.012507</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.config</Default>
</Parameter>
</Class>


<Class name="Api.Config.TempStream">
<Description>
Description</Description>
<Super>%Persistent</Super>
<TimeChanged>66011,29866.864473</TimeChanged>
<TimeCreated>66011,29866.864473</TimeCreated>

<Property name="created">
<Type>%TimeStamp</Type>
<InitialExpression>$zdatetime($HOROLOG,3,1)</InitialExpression>
</Property>

<Property name="name">
<Type>%String</Type>
</Property>

<Property name="charStream">
<Type>%Stream.GlobalCharacter</Type>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Api.Config.TempStreamD</DataLocation>
<DefaultData>TempStreamDefaultData</DefaultData>
<IdLocation>^Api.Config.TempStreamD</IdLocation>
<IndexLocation>^Api.Config.TempStreamI</IndexLocation>
<StreamLocation>^Api.Config.TempStreamS</StreamLocation>
<Data name="TempStreamDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>created</Value>
</Value>
<Value name="3">
<Value>name</Value>
</Value>
<Value name="4">
<Value>charStream</Value>
</Value>
</Data>
</Storage>
</Class>


<Routine name="Api.Config.inc" type="INC" timestamp="66011,29866.82753"><![CDATA[

#Define SRVPKG              Api.Config.Services
/// HTTP Status Code

#Define HTTP200                     ##class(%CSP.REST).%GetParameter("HTTP200OK")
#Define HTTP201                     ##class(%CSP.REST).%GetParameter("HTTP201CREATED")
#Define HTTP204                     ##class(%CSP.REST).%GetParameter("HTTP204NOCONTENT")
#Define HTTP400                     ##class(%CSP.REST).%GetParameter("HTTP400BADREQUEST")
#Define HTTP404                     ##class(%CSP.REST).%GetParameter("HTTP404NOTFOUND")
#Define HTTP409                     ##class(%CSP.REST).%GetParameter("HTTP409CONFLICT")


/// OTHERS

#Define switchNSSys                             New $NAMESPACE  Set ns = $NAMESPACE, $NAMESPACE = "%SYS"
#Define restoreNS                               Set $NAMESPACE = ns
#Define CanSetProperty(%json,%property)         (%json.%IsDefined(%property)&&($Ascii(%json.%Get(%property))'=0))
#Define fillJSONFromArray(%array,%json)         Do ##class(dc.deploy.Utils).fillJSONFromArray(.%array,.%json)
#Define fillArrayFromJSON(%json,%array)         Do ##class(dc.deploy.Utils).fillArrayFromJSON(.%json,.%array)

#Define DBSysUpdateProperties       $LISTBUILD("ReadOnly","Size","ExpansionSize","MaxSize","GlobalJournalState","NewGlobalCollation","NewGlobalIsKeep","NewGlobalGrowthBlock","NewGlobalPointerBlock","ClusterMountMode","ResourceName","CompressionEngine")
#Define DBSysCreateProperties       $LISTBUILD("Directory","BlockSize","EncryptedDB","EncryptionKeyID","Size","ExpansionSize","MaxSize","MirrorDBName","MirrorSetName","GlobalJournalState","NewGlobalCollation","NewGlobalIsKeep","NewGlobalGrowthBlock","NewGlobalPointerBlock","ClusterMountMode","ResourceName","CompressionEngine")
]]></Routine>


<Routine name="IORedirect" type="INC" timestamp="66011,29866.136284"><![CDATA[

#Define OldIO                   %zIORedirect("OldIO")
#Define OldMnemonic             %zIORedirect("OldMnemonic")
#Define OldState                %zIORedirect("OldState")
#Define KillOldStateData        Kill $$$OldState, $$$OldMnemonic, $$$OldIO

#Define RedirectOutputHandler   %zIORedirect("OutputHandler")
#Define LastOutputHandler       %zIORedirect("LastOutputHandler")
#Define RedirectInputHandler    %zIORedirect("InputHandler")

#Define RedirectGbl             %zIORedirect("OutputGlobalName")
#Define RedirectGblName         $Get($$$RedirectGbl, $Name(^||IORedirect))

#Define RedirectStream          %zIORedirect("OutStream")
#Define RedirectInputStream     %zIORedirect("InputStream")

#Define RedirectString          %zIORedirect("OutString")
#Define RedirectInputString     %zIORedirect("InputString")

#Define ClearConfig             Kill %zIORedirect

#Define InputHandlerUTimeout    ($CLASSMETHOD($$$RedirectInputHandler,"%GetParameter","USETIMETOUT")=1)

#Define CallReadChar(%timeout)          $SELECT($$$InputHandlerUTimeout:$CLASSMETHOD($$$RedirectInputHandler,"InChar", %timeout),1:$CLASSMETHOD($$$RedirectInputHandler,"InChar"))
#Define CallReadString(%size,%timeout)  $SELECT($$$InputHandlerUTimeout:$CLASSMETHOD($$$RedirectInputHandler,"InString",%size,%timeout),1:$CLASSMETHOD($$$RedirectInputHandler,"InString",%size))
]]></Routine>


<Class name="IORedirect.InputHandler">
<Abstract>1</Abstract>
<IncludeCode>IORedirect</IncludeCode>
<TimeChanged>66011,29866.090343</TimeChanged>
<TimeCreated>66011,29866.090343</TimeCreated>

<Parameter name="USETIMEOUT">
<Default>0</Default>
</Parameter>

<Method name="InChar">
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[    $$$ThrowStatus($$$ERROR($$$NotImplemented))
]]></Implementation>
</Method>

<Method name="InString">
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>size:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[    $$$ThrowStatus($$$ERROR($$$NotImplemented))
]]></Implementation>
</Method>
</Class>


<Class name="IORedirect.InputStream">
<IncludeCode>IORedirect</IncludeCode>
<Super>InputHandler</Super>
<TimeChanged>66011,29866.08774</TimeChanged>
<TimeCreated>66011,29866.08774</TimeCreated>

<Method name="InChar">
<Description>
Timeout parameter won't used in this subclass.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
    Quit:'$ISOBJECT($Get($$$RedirectInputStream)) -1
    Quit $ASCII($$$RedirectInputStream.Read(1))
]]></Implementation>
</Method>

<Method name="InString">
<Description>
Timeout parameter won't used in this subclass.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>size:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    Quit:'$ISOBJECT($Get($$$RedirectInputStream)) ""
    Quit:size="" $$$RedirectInputStream.ReadLine()
    Quit $$$RedirectInputStream.Read(size)
]]></Implementation>
</Method>

<Method name="SetStream">
<Deprecated>1</Deprecated>
<ClassMethod>1</ClassMethod>
<FormalSpec>stream:%Stream.Object=##class(%Stream.GlobalCharacter).%New()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit ..Set(stream)
]]></Implementation>
</Method>

<Method name="Set">
<ClassMethod>1</ClassMethod>
<FormalSpec>stream:%Stream.Object=##class(%Stream.GlobalCharacter).%New()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set $$$RedirectInputStream = stream
    Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="IORedirect.InputString">
<IncludeCode>IORedirect</IncludeCode>
<Super>InputHandler</Super>
<TimeChanged>66011,29866.085193</TimeChanged>
<TimeCreated>66011,29866.085193</TimeCreated>

<Method name="InChar">
<Description>
Timeout parameter won't used in this subclass.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
    Set char = $ASCII($Extract(..Get()))
    Do ..Set($Extract(..Get(), 2, *))
    Quit char
]]></Implementation>
</Method>

<Method name="InString">
<Description>
Timeout parameter won't used in this subclass.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>size:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    If size '= "" {
        Set buffer = $Extract(..Get(), 1, size)
        Do ..Set($Extract(..Get(), size+1, *))
        Quit buffer
    }

    Set buffer = $Piece(..Get(), $$$NL, 1)
    Do ..Set($Piece(..Get(), $$$NL, 2, *))
    Quit buffer
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$Get($$$RedirectInputString)
]]></Implementation>
</Method>

<Method name="Set">
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set $$$RedirectInputString = string
    Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="IORedirect.OutputGlobal">
<IncludeCode>IORedirect</IncludeCode>
<Super>IORedirect.OutputHandler</Super>
<TimeChanged>66011,29866.117895</TimeChanged>
<TimeCreated>66011,29866.117895</TimeCreated>

<Method name="Clear">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Kill @$$$RedirectGblName
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="SetRedirectLocation">
<Deprecated>1</Deprecated>
<ClassMethod>1</ClassMethod>
<FormalSpec>globalName:%String=$Name(^||IORedirect)</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit ..Set(globalName)
]]></Implementation>
</Method>

<Method name="Set">
<ClassMethod>1</ClassMethod>
<FormalSpec>globalName:%String=$Name(^||IORedirect)</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set $$$RedirectGbl = globalName
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$RedirectGblName
]]></Implementation>
</Method>

<Method name="OutChar">
<ClassMethod>1</ClassMethod>
<FormalSpec>char:%Integer</FormalSpec>
<Implementation><![CDATA[    Do ..OutString($Char(char))
]]></Implementation>
</Method>

<Method name="OutString">
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String</FormalSpec>
<Implementation><![CDATA[
    Set gbl = $$$RedirectGblName
    Set:'$Data(@gbl) @gbl = 1
    Set @gbl@(@gbl) =  $Get(@gbl@(@gbl)) _ string
    Quit
]]></Implementation>
</Method>

<Method name="OutFormFeed">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString($Char(12))
    Quit
]]></Implementation>
</Method>

<Method name="OutNewLine">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<Implementation><![CDATA[$Increment(@$$$RedirectGblName)
]]></Implementation>
</Method>

<Method name="OutTab">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString($Char(9))
    Quit
]]></Implementation>
</Method>
</Class>


<Class name="IORedirect.OutputHandler">
<Description>
Description</Description>
<Abstract>1</Abstract>
<TimeChanged>66011,29866.119919</TimeChanged>
<TimeCreated>66011,29866.119919</TimeCreated>

<Method name="OutChar">
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>char:%Integer</FormalSpec>
<Implementation><![CDATA[    $$$ThrowStatus($$$ERROR($$$NotImplemented))
]]></Implementation>
</Method>

<Method name="OutString">
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String</FormalSpec>
<Implementation><![CDATA[    $$$ThrowStatus($$$ERROR($$$NotImplemented))
]]></Implementation>
</Method>

<Method name="OutFormFeed">
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[    $$$ThrowStatus($$$ERROR($$$NotImplemented))
]]></Implementation>
</Method>

<Method name="OutNewLine">
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[    $$$ThrowStatus($$$ERROR($$$NotImplemented))
]]></Implementation>
</Method>

<Method name="OutTab">
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[    $$$ThrowStatus($$$ERROR($$$NotImplemented))
]]></Implementation>
</Method>

<Method name="OnStopRedirect">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="IORedirect.OutputStream">
<IncludeCode>IORedirect</IncludeCode>
<Super>IORedirect.OutputHandler</Super>
<TimeChanged>66011,29866.109597</TimeChanged>
<TimeCreated>66011,29866.109597</TimeCreated>

<Method name="Clear">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set stream = $$$RedirectStream
    Do:$Isobject(stream) stream.Clear()
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="SetStream">
<Description>
Description</Description>
<Deprecated>1</Deprecated>
<ClassMethod>1</ClassMethod>
<FormalSpec>stream:%Stream.Object=##class(%Stream.GlobalCharacter).%New()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit ..Set(stream)
]]></Implementation>
</Method>

<Method name="Set">
<ClassMethod>1</ClassMethod>
<FormalSpec>stream:%Stream.Object=##class(%Stream.GlobalCharacter).%New()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set $$$RedirectStream = stream
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
    Quit:$ISOBJECT($Get($$$RedirectStream)) $$$RedirectStream
    Do ..SetStream()
    Quit $$$RedirectStream
]]></Implementation>
</Method>

<Method name="OutChar">
<ClassMethod>1</ClassMethod>
<FormalSpec>char:%Integer</FormalSpec>
<Implementation><![CDATA[
    Do ..OutString($Char(char))
    Quit
]]></Implementation>
</Method>

<Method name="OutString">
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String</FormalSpec>
<Implementation><![CDATA[
    Do ..Get().Write(string)
    Quit
]]></Implementation>
</Method>

<Method name="OutFormFeed">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString($Char(12))
    Quit
]]></Implementation>
</Method>

<Method name="OutNewLine">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString(..Get().LineTerminator)
    Quit
]]></Implementation>
</Method>

<Method name="OutTab">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString($Char(9))
    Quit
]]></Implementation>
</Method>

<Method name="OnStopRedirect">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim sc As %Status = $$$OK
    #dim stream As %Stream.Object = ..Get()
    If stream.%IsA("%Stream.FileBinary") { 
        Set sc = stream.%Save()
    }
    Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="IORedirect.OutputString">
<IncludeCode>IORedirect</IncludeCode>
<Super>IORedirect.OutputHandler</Super>
<TimeChanged>66011,29866.125237</TimeChanged>
<TimeCreated>66011,29866.125237</TimeCreated>

<Method name="Clear">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit ..Set("")
]]></Implementation>
</Method>

<Method name="Set">
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set $$$RedirectString = string
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[    Quit $Get($$$RedirectString)
]]></Implementation>
</Method>

<Method name="OutChar">
<ClassMethod>1</ClassMethod>
<FormalSpec>char:%Integer</FormalSpec>
<Implementation><![CDATA[
    Do ..OutString($Char(char))
    Quit
]]></Implementation>
</Method>

<Method name="OutString">
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String</FormalSpec>
<Implementation><![CDATA[
    Set $$$RedirectString = $$$RedirectString _ string
    Quit
]]></Implementation>
</Method>

<Method name="OutFormFeed">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString($Char(12))
    Quit
]]></Implementation>
</Method>

<Method name="OutNewLine">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString($$$NL)
    Quit
]]></Implementation>
</Method>

<Method name="OutTab">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString($Char(9))
    Quit
]]></Implementation>
</Method>

<Method name="OnStopRedirect">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="IORedirect.Redirect">
<IncludeCode>IORedirect</IncludeCode>
<TimeChanged>66011,29866.133223</TimeChanged>
<TimeCreated>66011,29866.133223</TimeCreated>

<Parameter name="OUTPUTSTREAM">
<Default>IORedirect.OutputStream</Default>
</Parameter>

<Parameter name="OUTPUTGLOBAL">
<Default>IORedirect.OutputGlobal</Default>
</Parameter>

<Parameter name="OUTPUTSTRING">
<Default>IORedirect.OutputString</Default>
</Parameter>

<Parameter name="INPUTSTREAM">
<Default>IORedirect.InputStream</Default>
</Parameter>

<Parameter name="INPUTSTRING">
<Default>IORedirect.InputString</Default>
</Parameter>

<Method name="RedirectIO">
<Description><![CDATA[
Class this method to Enable the redirect<br/>
OutputHandler must be a subclass name of IORedirect.OutputHandler<br/>
If you want to handle Input, you can fill InputHandler with a subclass name of IORedirect.InputHandler<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>OutputHandler:%String,InputHandler:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set $$$OldIO = $IO
    Set $$$OldMnemonic = ##class(%Library.Device).GetMnemonicRoutine()
    Set $$$OldState = ##class(%Library.Device).ReDirectIO()

    Do ..SetInputHandler(InputHandler), ..SetOuputHandler(OutputHandler)

    Use $IO::("^"_$ZNAME)

    Do ##class(%Library.Device).ReDirectIO(1)

    Quit $$$OK
]]></Implementation>
</Method>

<Method name="RestoreIO">
<Description><![CDATA[
Stop the redirect and restore original IO Setting.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Quit:'$Data($$$OldState) $$$OK
    
    If $Get($$$OldMnemonic) '= "" {
        Use $$$OldIO::("^"_$$$OldMnemonic)
    } Else {
        Use $$$OldIO
    }

    Do ##class(%Library.Device).ReDirectIO($$$OldState)
    $$$KillOldStateData

    Do $CLASSMETHOD($$$RedirectOutputHandler, "OnStopRedirect")
    
    Do ..SetInputHandler(""), ..SetOuputHandler("")
    
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<Description>
Return the output value depending the last used output hander:
OutputGlobal : String with the global name.
OutputString : String with the output value.
OutputStream : Stream with the output value.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[    Quit $CLASSMETHOD($$$LastOutputHandler, "Get")
]]></Implementation>
</Method>

<Method name="ToStream">
<Description>
Enable Output Redirection to a Stream object.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>stream:%Stream.Object=##class(%Stream.GlobalCharacter).%New()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$QuitOnError(..RedirectIO(..#OUTPUTSTREAM))
    $$$QuitOnError($CLASSMETHOD(..#OUTPUTSTREAM, "Set", stream))
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="ToString">
<Description>
Enable output redirect to a string.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$QuitOnError(..RedirectIO(..#OUTPUTSTRING))
    $$$QuitOnError($CLASSMETHOD(..#OUTPUTSTRING, "Set", ""))
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="ToFileCharacter">
<Description>
Enable output redirect to a file.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>fileName:%String</FormalSpec>
<Implementation><![CDATA[
    #dim fcs As %Stream.FileCharacter = ##class(%Stream.FileCharacter).%New()
    Set dir = ##class(%File).GetDirectory(fileName)
    Do:'##class(%File).DirectoryExists(dir) ##class(%File).CreateDirectoryChain(dir)
    Do fcs.LinkToFile(fileName)
    $$$QuitOnError(..RedirectIO(..#OUTPUTSTREAM))

    Quit $CLASSMETHOD(..#OUTPUTSTREAM, "SetStream", fcs)
]]></Implementation>
</Method>

<Method name="ToGlobal">
<Description>
Enable Output redirection to a global.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>global:%String=$Name(^||IORedirect)</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$QuitOnError(..RedirectIO(..#OUTPUTGLOBAL))
    $$$QuitOnError($CLASSMETHOD(..#OUTPUTGLOBAL, "Set", global))
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="InputStream">
<Description>
Enable Read from a stream.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>stream:%Stream.Object=##class(%Stream.GlobalCharacter).%New()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Do ..SetInputHandler(..#INPUTSTREAM), $CLASSMETHOD(..#INPUTSTREAM, "Set", stream)
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="InputString">
<Description>
Enable Read from a string.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>inputString:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Do ..SetInputHandler(..#INPUTSTRING), $CLASSMETHOD(..#INPUTSTRING, "Set", inputString)
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="SetOuputHandler">
<ClassMethod>1</ClassMethod>
<FormalSpec>OutputHandler:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set:OutputHandler'="" $$$LastOutputHandler = OutputHandler
    Set $$$RedirectOutputHandler = OutputHandler
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetOuputHandler">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$RedirectOutputHandler
]]></Implementation>
</Method>

<Method name="SetInputHandler">
<ClassMethod>1</ClassMethod>
<FormalSpec>OutputHandler:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set $$$RedirectInputHandler = OutputHandler
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetInputHandler">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$RedirectInputHandler
]]></Implementation>
</Method>

<Method name="ClearConfig">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$ClearConfig
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="labels">
<ClassMethod>1</ClassMethod>
<ProcedureBlock>0</ProcedureBlock>
<Implementation><![CDATA[
    Quit
rchr(c)      Quit:$Get($$$RedirectInputHandler)=""  Quit $$$CallReadChar($Get(c))
rstr(sz,to)  Quit:$Get($$$RedirectInputHandler)=""  Quit $$$CallReadString($g(sz),$g(to))
wchr(s)      Do $CLASSMETHOD($$$RedirectOutputHandler,"OutChar",s)  Quit
wstr(s)      Do $CLASSMETHOD($$$RedirectOutputHandler,"OutString",s)  Quit
wff()        Do $CLASSMETHOD($$$RedirectOutputHandler,"OutFormFeed")  Quit
wnl()        Do $CLASSMETHOD($$$RedirectOutputHandler,"OutNewLine")  Quit
wtab(s)      Do $CLASSMETHOD($$$RedirectOutputHandler,"OutTab")  Quit
]]></Implementation>
</Method>
</Class>


<Class name="lscalese.configcopy.ExportFilterTemplate">
<Description>
Description</Description>
<TimeChanged>66011,29869.133511</TimeChanged>
<TimeCreated>66011,29869.133511</TimeCreated>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String="Default"</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set XData = ##class(%Dictionary.CompiledXData).%OpenId($CLASSNAME()_"||"_Name)
    Return {}.%FromJSON(XData.Data)
]]></Implementation>
</Method>

<XData name="Default">
<MimeType>application/json</MimeType>
<Data><![CDATA[
{
    "Databases": "",
    "Namespaces":"",
    "MapGlobals":"",
    "MapPackages": "",
    "MapRoutines":"",
    "Journal":"",
    "Startup":"",
    "config":"",
    "Miscellaneous":"",
    "LicenseServers":"",
    "Monitor":"",
    "IO":"",
    "SQL":"",
    "SQLSysDatatypes":"",
    "SQLUserDatatypes":"",
    "Telnet":""
}
]]></Data>
</XData>
</Class>


<Class name="lscalese.configcopy.ImportFromRemote">
<Description>
Export configuration from the remote instance and import this instance.</Description>
<TimeChanged>66011,50198.416874</TimeChanged>
<TimeCreated>66011,44578.305571</TimeCreated>

<Method name="All">
<Description>
Set sc = ##class(lscalese.configcopy.ImportFromRemote).All()</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK

    Set scO = ..Security()
    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)
    
    Set scO = ..Globals()
    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)

    Set scO = ..CPFData()
    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)

    Return sc
]]></Implementation>
</Method>

<Method name="Security">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, Filename = ##class(%File).TempFilename()

    Try {
        $$$TOE(sc,##class(lscalese.configcopy.RemoteExport).Security(Filename))
        $$$TOE(sc,##class(lscalese.configcopy.LocalImport).Security(Filename))
    } Catch (ex) {
        Set sc = ex.AsStatus()
    }
    
    Do ##class(%File).Delete(Filename)

    Return sc
]]></Implementation>
</Method>

<Method name="Globals">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, Filename = ##class(%File).TempFilename()

    Try {
        $$$TOE(sc,##class(lscalese.configcopy.RemoteExport).Globals(Filename))
        $$$TOE(sc,##class(lscalese.configcopy.LocalImport).Globals(Filename))
    } Catch (ex) {
        Set sc = ex.AsStatus()
    }
    
    Do ##class(%File).Delete(Filename)

    Return sc
]]></Implementation>
</Method>

<Method name="CPFData">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, Filename = ##class(%File).TempFilename()

    Try {
        $$$TOE(sc,##class(lscalese.configcopy.RemoteExport).CPFData(Filename))
        $$$TOE(sc,##class(lscalese.configcopy.LocalImport).CPFData(Filename))
    } Catch (ex) {
        Set sc = ex.AsStatus()
    }
    
    Do ##class(%File).Delete(Filename)

    Return sc
]]></Implementation>
</Method>
</Class>


<Class name="lscalese.configcopy.LocalExport">
<Description>
Export configuration of this instance</Description>
<TimeChanged>66012,26469.81149</TimeChanged>
<TimeCreated>66011,29869.102331</TimeCreated>

<Method name="All">
<Description>
d ##class(lscalese.configcopy.LocalExport).All()</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String={ $zu(12,"config-copy-local/")}</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Set Directory = ##class(%File).NormalizeDirectory(Directory)

    Do:'##class(%File).DirectoryExists(Directory) ##class(%File).CreateDirectoryChain(Directory)

    
    Set scO = ..Security(Directory_"SecurityExport.xml")
    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)

    Set scO = ..Tasks(Directory_"TasksExport.xml")
    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)

    Set scO = ..Globals(Directory_"GlobalsExport.xml")
    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)

    Set scO = $$$OK
    Set config =  ..CPFDataTemplate(.scO, "Default")

    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)

    Return:$$$ISERR(scO) sc
    
    Set scO = ##class(Api.Config.Services.Loader).toFile(config, Directory_"config-api.json")
    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)

    Return sc
]]></Implementation>
</Method>

<Method name="Security">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String="SecurityExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.System).ExportAll(Filename)
]]></Implementation>
</Method>

<Method name="Tasks">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String="TasksExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set TaskListId="", id=999 

    For  { 
        Set id = $Order(^["%SYS"]SYS("Task","TaskD",id)) 
        Quit:id=""  
        Set $List(TaskListId,*+1)=id 
    }

    If $LISTLENGTH(TaskListId) = 0 {
        Return $$$OK  ; Nothing to export
    }

    Return ##class(%SYS.TaskSuper).ExportTasks(TaskListId)
]]></Implementation>
</Method>

<Method name="Globals">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String="GlobalsExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    ; zw ##class(lscalese.configcopy.Export).ExportGlobals()
    $$$QuitOnError(..GlobalsToStream(.stream))
    
    Do:##class(%File).Exists(Filename) ##class(%File).Delete(Filename)
    Set file = ##class(%Stream.FileBinary).%New()
    $$$QuitOnError(file.LinkToFile(Filename))
    
    Do file.CopyFrom(.stream)
    Quit file.%Save()
]]></Implementation>
</Method>

<Method name="GlobalsToStream">
<ClassMethod>1</ClassMethod>
<FormalSpec>GblStream:%Stream.GlobalBinary=##class(%Stream.GlobalBinary).%New()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Lock +^ExportTmp
    Kill ^ExportTmp
    Try {
        Merge ^ExportTmp($Name(^%SYS("sql","ODBCCONNECTION"))) = ^%SYS("sql","ODBCCONNECTION")
        Set sc = $SYSTEM.OBJ.ExportToStream("ExportTmp.GBL", .GblStream, "-d")
    } Catch(ex) {
        Set sc = ex.AsStatus()
    }
    Lock -^ExportTmp
    Return sc
]]></Implementation>
</Method>

<Method name="CPFDataTemplate">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&sc:%Status,TemplateName:%String,ToFile:%String="",IncludeSystem:%Boolean=$$$NO]]></FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set Filter = ##class(lscalese.configcopy.ExportFilterTemplate).Get(TemplateName)
    Return ..CPFData(.sc, Filter, ToFile, IncludeSystem)
]]></Implementation>
</Method>

<Method name="CPFData">
<Description>
Export CPF Section using config-api tools.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&sc:%Status=$$$OK,Filter:%DynamicObject,ToFile:%String="",IncludeSystem:%Boolean=$$$NO]]></FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    #dim config As %DynamicObject = {}
    
    Try {
        Set config = ##class(Api.Config.Services.Loader).export(Filter, $$$YES, ToFile)
    } Catch (ex) {
        Set sc = ex.AsStatus()
    }

    Return:$$$ISERR(sc) ""

    Return:IncludeSystem config

    If $Isobject(config.Namespaces) {

        Set excludeNS("%SYS")=""
        Set excludeNS("HSLIB")=""
        Set excludeNS("HSSYS")=""
        Set excludeNS("DOCBOOK")=""
        Set excludeNS("ENSEMBLE")=""
        Set excludeNS("ENSDEMO")=""
        Set excludeNS("HSCUSTOM")=""
        
        Set ns = ""
        For  {
            
            Set ns = $Order(excludeNS(ns))
            Quit:ns=""

            Do config.Namespaces.%Remove(ns)
        }

    }

    Return:'$Isobject(config.Databases) config

    Set excludeDB("IRISSYS")=""
    Set excludeDB("IRISLIB")=""
    Set excludeDB("IRISTEMP")=""
    Set excludeDB("IRISLOCALDATA")=""
    Set excludeDB("IRISAUDIT")=""
    Set excludeDB("ENSLIB")=""
    Set excludeDB("ENSDEMO")=""
    Set excludeDB("ENSEMBLE")=""
    Set excludeDB("HSCUSTOM")=""
    Set excludeDB("HSSYS")=""
    Set excludeDB("HSLIB")=""
    Set excludeDB("USER")=""
    Set excludeDB("CACHESYS")=""
    Set excludeDB("CACHELIB")=""
    Set excludeDB("CACHETEMP")=""
    Set excludeDB("CACHEAUDIT")=""
    Set excludeDB("CACHE")=""
    Set excludeDB("USER")=""
    
    Set db = ""

    For  {
        Set db = $Order(excludeDB(db))
        Quit:db=""
        
        Set dbObj = config.Databases.%Get(db)
        
        Continue:'$Isobject(dbObj)
        
        If $Isobject(config."SYS.Databases"), dbObj.Directory'="" {
            Do config."SYS.Databases".%Remove(dbObj.Directory)
        }
        
        Do config.Databases.%Remove(db)
    }

    Return config
]]></Implementation>
</Method>
</Class>


<Class name="lscalese.configcopy.LocalImport">
<Description>
Description</Description>
<TimeChanged>66012,26372.407129</TimeChanged>
<TimeCreated>66011,29869.123266</TimeCreated>

<Method name="CPFData">
<Description>
Load CPF configuration data from a json format config-api</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>CPFConfig:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Return ##class(Api.Config.Services.Loader).Load(CPFConfig)
]]></Implementation>
</Method>

<Method name="Security">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.System).ImportAll(Filename)
]]></Implementation>
</Method>

<Method name="Tasks">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Return ##class(%SYS.Task).ImportTasks(Filename)
]]></Implementation>
</Method>

<Method name="Globals">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim FileBinary As %Stream.FileBinary = ##class(%Stream.FileBinary).%New()
    Do FileBinary.LinkToFile(Filename)
    Return ..GlobalsStream(.FileBinary)
]]></Implementation>
</Method>

<Method name="GlobalsStream">
<ClassMethod>1</ClassMethod>
<FormalSpec>GblStream:%Stream.GlobalBinary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Lock +^ExportTmp
    
    Kill:$Data(^ExportTmp) ^ExportTmp

    Try{
        $$$TOE(sc,$SYSTEM.OBJ.LoadStream(GblStream))
        
        Set dt = $zdt($h,3,1)

        If $Data(^ExportTmp($Name(^%SYS("sql","ODBCCONNECTION")))) {
            Merge ^configcopy.backup(dt, $Name(^%SYS("sql","ODBCCONNECTION"))) = ^%SYS("sql","ODBCCONNECTION")
            Kill ^%SYS("sql","ODBCCONNECTION")
            Merge ^%SYS("sql","ODBCCONNECTION") = ^ExportTmp($Name(^%SYS("sql","ODBCCONNECTION")))
        }

    } Catch(ex) {

        Set sc = ex.AsStatus()
            
    }
    
    Kill ^ExportTmp

    Lock -^ExportTmp
    
    Return sc
]]></Implementation>
</Method>
</Class>


<Class name="lscalese.configcopy.RemoteExport">
<Description>
Export configuration from a remote instance using a REST api.
config-copy tools must be also installed on the remote instance.</Description>
<TimeChanged>66012,50462.631398</TimeChanged>
<TimeCreated>66011,29869.159783</TimeCreated>

<Method name="All">
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String={$zu(12,"config-copy-remote/")}</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Set Directory = ##class(%File).NormalizeDirectory(Directory)

    Do:'##class(%File).DirectoryExists(Directory) ##class(%File).CreateDirectoryChain(Directory)

    Set scO =..Security(Directory_"SecurityExport.xml")
    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)

    Set scO = ..Tasks(Directory_"TasksExport.xml")
    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)

    Set scO = ..Globals(Directory_"GlobalsExport.xml")
    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)

    Set scO = ..CPFData(Directory_"config-api.json")
    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)

    Return sc
]]></Implementation>
</Method>

<Method name="CPFData">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String="",*config:%DynamicObject=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    ; zw ##class(lscalese.configcopy.RemoteExport).CPFData(,.cfg)
    Set client = ##class(lscalese.configcopy.client.HttpClient).%New()
    Set pRequest = ##class(lscalese.configcopy.client.msg.ExportConfigRequest).%New()
    $$$QuitOnError(client.GETExportConfig(pRequest,.pResponse))
    
    Return:pResponse.httpStatusCode'=200 $$$ERROR(5001, "Return http status code "_pResponse.httpStatusCode)
    
    Set config = {}.%FromJSON(pResponse.body)
    
    Set:Filename'="" sc = ##class(Api.Config.Services.Loader).toFile(config, Filename)
    
    Return sc
]]></Implementation>
</Method>

<Method name="Tasks">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String="",*TasksStream:%Stream.GlobalBinary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    ; d ##class(lscalese.configcopy.RemoteExport).Tasks(,.ts)
    Set sc = $$$OK
    Set client = ##class(lscalese.configcopy.client.HttpClient).%New()
    Set pRequest = ##class(lscalese.configcopy.client.msg.ExportTasksRequest).%New()
    $$$QuitOnError(client.GETExportTasks(pRequest,.pResponse))
    
    Return:pResponse.httpStatusCode'=200 $$$ERROR(5001, "Return http status code "_pResponse.httpStatusCode)
    
    Set TasksStream = pResponse.body
    Do TasksStream.Rewind()
    
    Return:Filename="" sc

    Set fbs = ##class(%Stream.FileBinary).%New()
    $$$QuitOnError(fbs.LinkToFile(Filename))
    Do fbs.CopyFrom(pResponse.body)
    $$$QuitOnError(fbs.%Save())
    
    Return sc
]]></Implementation>
</Method>

<Method name="Security">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String="",*SecurityStream:%Stream.GlobalBinary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    ; zw ##class(lscalese.configcopy.RemoteExport).Security(,.ss)
    Set sc = $$$OK
    Set client = ##class(lscalese.configcopy.client.HttpClient).%New()
    Set pRequest = ##class(lscalese.configcopy.client.msg.ExportSecurityRequest).%New()
    $$$QuitOnError(client.GETExportSecurity(pRequest,.pResponse))
    
    Return:pResponse.httpStatusCode'=200 $$$ERROR(5001, "Return http status code "_pResponse.httpStatusCode)
    
    Set SecurityStream = pResponse.body
    Do SecurityStream.Rewind()
    
    Return:Filename="" sc

    Set fbs = ##class(%Stream.FileBinary).%New()
    $$$QuitOnError(fbs.LinkToFile(Filename))
    Do fbs.CopyFrom(pResponse.body)
    $$$QuitOnError(fbs.%Save())
    
    Return sc
]]></Implementation>
</Method>

<Method name="Globals">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String="",*GlobalsStream:%Stream.GlobalBinary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    ; zw ##class(lscalese.configcopy.RemoteExport).Globals(,.gs)
    Set sc = $$$OK
    Set client = ##class(lscalese.configcopy.client.HttpClient).%New()
    Set pRequest = ##class(lscalese.configcopy.client.msg.getexportsysglobalsRequest).%New()
    $$$QuitOnError(client.GETgetexportsysglobals(pRequest,.pResponse))
    
    Return:pResponse.httpStatusCode'=200 $$$ERROR(5001, "Return http status code "_pResponse.httpStatusCode)
    
    Set GlobalsStream = pResponse.body
    Do GlobalsStream.Rewind()
    
    Return:Filename="" sc

    Set fbs = ##class(%Stream.FileBinary).%New()
    $$$QuitOnError(fbs.LinkToFile(Filename))
    Do fbs.CopyFrom(pResponse.body)
    $$$QuitOnError(fbs.%Save())
    
    Return sc
]]></Implementation>
</Method>
</Class>


<Class name="lscalese.configcopy.Utils">
<Description>
Description</Description>
<TimeChanged>66012,51641.377284</TimeChanged>
<TimeCreated>66011,42392.534365</TimeCreated>

<Method name="Install">
<Description>
Do ##class(lscalese.configcopy.Utils).Install("localhost",52773)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>RemoteHost:%String="localhost",RemotePort:%Integer=52773,SSLConfig:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Do ..SetCredential(,,$$$NO)
    Do ..SetRemoteSettings(RemoteHost, RemotePort, SSLConfig)
    Return ..SetWebApp()
]]></Implementation>
</Method>

<Method name="SetRemoteSettings">
<Description>
Do ##class(lscalese.configcopy.Utils).SetRemoteSettings("localhost",52773)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>RemoteHost:%String="localhost",RemotePort:%Integer=52773,SSLConfig:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set ^configcopy.RemoteExport("server") = RemoteHost
	Set ^configcopy.RemoteExport("port") = RemotePort
	Set ^configcopy.RemoteExport("sslconfig") = SSLConfig
    Return $$$OK
]]></Implementation>
</Method>

<Method name="SetCredential">
<ClassMethod>1</ClassMethod>
<FormalSpec>Username:%String="_system",Password:%String="SYS",Override:%Boolean=$$$YES</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set credentialId = ##class(lscalese.configcopy.client.HttpClient).%GetParameter("CREDENTIALID")
    Return ##class(Ens.Config.Credentials).SetCredential(credentialId, Username, Password, Override)
]]></Implementation>
</Method>

<Method name="SetWebApp">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set params("DispatchClass") = $Select($$$LOWER($ZVersion)["iris":"lscalese.configcopy.rest.disp",1:"lscalese.configcopy.rest.hsdisp")
    ;Set params("DispatchClass")="lscalese.configcopy.rest.hsdisp"

    Set config = {
        "Security.Applications":{
            "/csp/lscalese/configcopy":{
                "AutheEnabled":"32",
                "CookiePath":"/csp/lscalese/configcopy/",
                "DispatchClass":"${DispatchClass}",
                "Name":"/csp/lscalese/configcopy",
                "NameSpace":"${NAMESPACE}"
            }
        }
    }
    
    Return ##class(Api.Config.Services.Loader).Load(config, .params)
]]></Implementation>
</Method>

<Method name="buildXmlRelease">
<Description>
Do ##class(lscalese.configcopy.Utils).buildXmlRelease()</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String="/irisrun/repo/dist/config-copy_for_IRIS.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Do:##class(%File).Exists(filename) ##class(%File).Delete(filename)
    Set items = ""
    Set items("Api.Config.inc.INC")=""
    Set items("IORedirect.INC")=""
    Set items("Api.Config.*.CLS")=""
    Set items("IORedirect.*.CLS")=""
    Set items("lscalese.configcopy.*.CLS")=""
    Quit $SYSTEM.OBJ.Export(.items,filename)
]]></Implementation>
</Method>

<Method name="buildHSXmlRelease">
<Description>
Do ##class(lscalese.configcopy.Utils).buildHSXmlRelease()</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String="/irisrun/repo/dist/config-copy_for_HealthShare.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK

    Do:##class(%File).Exists(filename) ##class(%File).Delete(filename)
    Set items = ""
    Set items("Api.Config.inc.INC")=""
    Set items("IORedirect.INC")=""
    Set items("Api.Config.*.CLS")=""
    Set items("IORedirect.*.CLS")=""
    Set items("lscalese.configcopy.*.CLS")=""

    Set items("'lscalese.configcopy.rest.disp.CLS")=""
    Set items("'lscalese.configcopy.rest.impl.CLS")=""
    Set items("'lscalese.configcopy.rest.spec.CLS")=""
    Set items("'Api.Config.Services.Security.SQLPrivileges.CLS")=""
    Set items("'Api.Config.REST.disp.CLS")=""
    Set items("'Api.Config.REST.impl.CLS")=""
    Set items("'Api.Config.REST.spec.CLS")=""
    
    If $$$LOWER($ZVersion) [ "iris" {
        
        $$$QuitOnError($SYSTEM.OBJ.ExportToStream(.items, .stream))
        Do stream.Rewind()
        
        Set fc = ##class(%Stream.FileCharacter).%New()
        $$$QuitOnError(fc.LinkToFile(filename))

        Do fc.WriteLine(stream.ReadLine())
        Do stream.ReadLine()

        Set exportLine = "<Export generator=""Cache"" version=""25"" zv=""Cache for Windows (x86-64) 2012.2.3 (Build 903U)"" ts="""_$zdt($h,3,1)_""">"
        Do fc.WriteLine(exportLine)

        While 'stream.AtEnd {
            Do fc.WriteLine(stream.ReadLine())
        }
        Set sc = fc.%Save()
        kill fc

    } Else {
        Set sc = $SYSTEM.OBJ.Export(.items, filename)
    }

    Return sc
]]></Implementation>
</Method>
</Class>


<Class name="lscalese.configcopy.client.HttpClient">
<ProcedureBlock>1</ProcedureBlock>
<Super>%RegisteredObject</Super>
<TimeChanged>66011,51151.476043</TimeChanged>
<TimeCreated>66011,29869.135177</TimeCreated>

<Parameter name="CREDENTIALID">
<Default>config-copy</Default>
</Parameter>

<Method name="GETExportConfig">
<Description>
Export configuration in config-api format : https://github.com/lscalese/iris-config-api .</Description>
<FormalSpec>pRequest:lscalese.configcopy.client.msg.ExportConfigRequest,*pResponse:lscalese.configcopy.client.msg.GenericResponse,pHttpRequestIn:%Net.HttpRequest=..GetRequest(pRequest),*pHttpResponse:%Net.HttpResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK, pURL = "/csp/lscalese/configcopy/export/config/"
	Set pHttpRequestIn = ..GetRequest(pRequest)
	Set pHttpRequestIn.ContentType = pRequest.consume
	$$$QuitOnError(pHttpRequestIn.Send("GET", pURL))
	Set pHttpResponse=pHttpRequestIn.HttpResponse
	Set pResponse = ##class(lscalese.configcopy.client.msg.GenericResponse).%New()
	Set sc = ..genericProcessResponse(pRequest, pResponse, "GETExportConfig", sc, $Get(pHttpResponse),"")
	Return sc
]]></Implementation>
</Method>

<Method name="GETExportSecurity">
<Description>
Export all security settings in XML format</Description>
<FormalSpec>pRequest:lscalese.configcopy.client.msg.ExportSecurityRequest,*pResponse:lscalese.configcopy.client.msg.GenericResponse,pHttpRequestIn:%Net.HttpRequest=..GetRequest(pRequest),*pHttpResponse:%Net.HttpResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK, pURL = "/csp/lscalese/configcopy/export/security/"
	Set pHttpRequestIn = ..GetRequest(pRequest)
	Set pHttpRequestIn.ContentType = pRequest.consume
	$$$QuitOnError(pHttpRequestIn.Send("GET", pURL))
	Set pHttpResponse=pHttpRequestIn.HttpResponse
	Set pResponse = ##class(lscalese.configcopy.client.msg.GenericResponse).%New()
	Set sc = ..genericProcessResponse(pRequest, pResponse, "GETExportSecurity", sc, $Get(pHttpResponse),"")
	Return sc
]]></Implementation>
</Method>

<Method name="GETExportTasks">
<Description>
Export all users defined tasks in XML format.</Description>
<FormalSpec>pRequest:lscalese.configcopy.client.msg.ExportTasksRequest,*pResponse:lscalese.configcopy.client.msg.GenericResponse,pHttpRequestIn:%Net.HttpRequest=..GetRequest(pRequest),*pHttpResponse:%Net.HttpResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK, pURL = "/csp/lscalese/configcopy/export/tasks/"
	Set pHttpRequestIn = ..GetRequest(pRequest)
	Set pHttpRequestIn.ContentType = pRequest.consume
	$$$QuitOnError(pHttpRequestIn.Send("GET", pURL))
	Set pHttpResponse=pHttpRequestIn.HttpResponse
	Set pResponse = ##class(lscalese.configcopy.client.msg.GenericResponse).%New()
	Set sc = ..genericProcessResponse(pRequest, pResponse, "GETExportTasks", sc, $Get(pHttpResponse),"")
	Return sc
]]></Implementation>
</Method>

<Method name="GETGetSpec">
<FormalSpec>pRequest:lscalese.configcopy.client.msg.GetSpecRequest,*pResponse:lscalese.configcopy.client.msg.GenericResponse,pHttpRequestIn:%Net.HttpRequest=..GetRequest(pRequest),*pHttpResponse:%Net.HttpResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK, pURL = "/csp/lscalese/configcopy/"
	Set pHttpRequestIn = ..GetRequest(pRequest)
	Set pHttpRequestIn.ContentType = pRequest.consume
	$$$QuitOnError(pHttpRequestIn.Send("GET", pURL))
	Set pHttpResponse=pHttpRequestIn.HttpResponse
	Set pResponse = ##class(lscalese.configcopy.client.msg.GenericResponse).%New()
	Set sc = ..genericProcessResponse(pRequest, pResponse, "GETGetSpec", sc, $Get(pHttpResponse),"")
	Return sc
]]></Implementation>
</Method>

<Method name="GETgetexportsysglobals">
<Description>
Copy the node ^%SYS("sql","ODBCCONNECTION") into ^ExportTmp and export it.</Description>
<FormalSpec>pRequest:lscalese.configcopy.client.msg.getexportsysglobalsRequest,*pResponse:lscalese.configcopy.client.msg.GenericResponse,pHttpRequestIn:%Net.HttpRequest=..GetRequest(pRequest),*pHttpResponse:%Net.HttpResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK, pURL = "/csp/lscalese/configcopy/export/sysglobals/"
	Set pHttpRequestIn = ..GetRequest(pRequest)
	Set pHttpRequestIn.ContentType = pRequest.consume
	$$$QuitOnError(pHttpRequestIn.Send("GET", pURL))
	Set pHttpResponse=pHttpRequestIn.HttpResponse
	Set pResponse = ##class(lscalese.configcopy.client.msg.GenericResponse).%New()
	Set sc = ..genericProcessResponse(pRequest, pResponse, "GETgetexportsysglobals", sc, $Get(pHttpResponse),"")
	Return sc
]]></Implementation>
</Method>

<Method name="GetRequest">
<FormalSpec>pRequest:%RegisteredObject</FormalSpec>
<ReturnType>%Net.HttpRequest</ReturnType>
<Implementation><![CDATA[
	#dim pHttpRequestIn As %Net.HttpRequest = ##class(%Net.HttpRequest).%New()
	Do:##class(%Dictionary.CompiledProperty).%ExistsId(pRequest.%ClassName(1)_"||accept") pHttpRequestIn.SetHeader("accept", pRequest.accept)
	Set pHttpRequestIn.Server = $Get(^configcopy.RemoteExport("server"),"localhost")
	Set pHttpRequestIn.Port = $Get(^configcopy.RemoteExport("port"),52773)
	Set pHttpRequestIn.Https = $Get(^configcopy.RemoteExport("sslconfig"))'=""
	
    If ##class(Ens.Config.Credentials).%ExistsId(..#CREDENTIALID) {
        Set user = ##class(Ens.Config.Credentials).GetValue(..#CREDENTIALID, "Username")
        Set password = ##class(Ens.Config.Credentials).GetValue(..#CREDENTIALID, "Password")
        Do pHttpRequestIn.SetHeader("Authorization","Basic "_$SYSTEM.Encryption.Base64Encode(user_":"_password))
    }

	Return pHttpRequestIn
]]></Implementation>
</Method>

<Method name="genericProcessResponse">
<FormalSpec>pRequest:%RegisteredObject,pResponse:lscalese.configcopy.client.msg.GenericResponse,caller:%String,status:%Status,pHttpResponse:%Net.HttpResponse,parsedResponseClassName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set pResponse.operation = caller
	Set pResponse.operationStatusText = $SYSTEM.Status.GetOneErrorText(status)
	If $Isobject(pHttpResponse) {
		Set pResponse.httpStatusCode = pHttpResponse.StatusCode
		Do pResponse.body.CopyFrom(pHttpResponse.Data)
		Set key = ""
		For  {
			Set key = $Order(pHttpResponse.Headers(key),1 , headerValue)
			Quit:key=""
			Do pResponse.headers.SetAt(headerValue, key)
		}
		Set sc = ##class(lscalese.configcopy.client.HttpClient).processParsedResponse(pHttpResponse, parsedResponseClassName, caller, pRequest, pResponse)
	}
	Return sc
]]></Implementation>
</Method>

<Method name="processParsedResponse">
<ClassMethod>1</ClassMethod>
<FormalSpec>pHttpResponse:%Net.HttpResponse,responseClass:%String,caller:%String,pRequest:%RegisteredObject,pResponse:lscalese.configcopy.client.msg.GenericResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Return:responseClass="" $$$OK
    Set parsedResponse = "", sc = $$$OK
    
    If (pHttpResponse.ContentType="application/json") {
        Set httpStatusCode = pHttpResponse.StatusCode
        
        Set parsedResponse = $ClassMethod(responseClass, "%New")
        
        Quit:parsedResponse.%GetParameter(httpStatusCode _ "MODEL")="" sc

        #define zIsList httpStatusCode _ "ISLIST"
        #define zModelType httpStatusCode _ "MODELTYPE"
        #define zModel httpStatusCode _ "MODEL"

        Try {
            If parsedResponse.%GetParameter( $$$zIsList ) {
                Set list = [].%FromJSON(pHttpResponse.Data)
                Set iter = list.%GetIterator()
                While iter.%GetNext(.keyParam, .value) {
                    Set model = $ClassMethod(parsedResponse.%GetParameter( $$$zModelType ), "%New")
                    Do model.%JSONImport(value)
                    Do $Method($Property(parsedResponse, parsedResponse.%GetParameter( $$$zModel )), "Insert", model)
                }
            } Else {
                Set model = $ClassMethod(parsedResponse.%GetParameter( $$$zModelType ), "%New")
                Do model.%JSONImport(pHttpResponse.Data)
                Set $Property(parsedResponse, parsedResponse.%GetParameter( $$$zModel )) = model
            }
            Set pResponse.parsedResponse = parsedResponse
        } Catch(ex) {
            Set sc = ex.AsStatus()
        }
    }

    Return sc
]]></Implementation>
</Method>

<Method name="SaveCredential">
<ClassMethod>1</ClassMethod>
<FormalSpec>Username:%String,Password:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	; Do ##class(lscalese.configcopy.client.HttpClient).SaveCredential("_system","SYS")
    Return ##class(Ens.Config.Credentials).SetCredential(..#CREDENTIALID, Username, Password, $$$YES)
]]></Implementation>
</Method>
</Class>


<Class name="lscalese.configcopy.client.model.spec">
<ProcedureBlock>1</ProcedureBlock>
<Super>%RegisteredObject</Super>
<TimeChanged>66011,29869.21978</TimeChanged>
<TimeCreated>66011,29869.21978</TimeCreated>

<XData name="OpenAPI">
<MimeType>application/json</MimeType>
<Data><![CDATA[
{
  "swagger":"2.0",
  "basePath":"/lscalese/configcopy",
  "schemes":[
    "http",
    "https"
  ],
  "info":{
    "title":"config-copy api",
    "version":"0.0.1",
    "description":"",
    "contact":{
      "name":"Lorenzo Scalese",
      "email":"lorenzo.scalese@gmail.com",
      "url":"https://github.com/lscalese/iris-config-copy/"
    },
    "license":{
      "name":"MIT",
      "url":"https://github.com/lscalese/iris-config-copy/blob/master/LICENSE"
    }
  },
  "produces":[
    "application/json",
    "application/xml"
  ],
  "paths":{
    "/":{
      "get":{
        "summary":"Swagger 2.0 specification",
        "operationId":"GetSpec",
        "produces":[
          "application/json"
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      }
    },
    "/export/sysglobals":{
      "get":{
        "description":"Copy the node ^%SYS(\"sql\",\"ODBCCONNECTION\") into ^ExportTmp and export it.",
        "parameters":[
        ],
        "produces":[
          "application/xml"
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        },
        "operationId":"getexportsysglobals"
      }
    },
    "/export/config":{
      "get":{
        "description":"Export configuration in config-api format : https://github.com/lscalese/iris-config-api .",
        "operationId":"ExportConfig",
        "parameters":[
        ],
        "produces":[
          "application/json"
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      }
    },
    "/export/tasks/":{
      "get":{
        "description":"Export all users defined tasks in XML format.",
        "operationId":"ExportTasks",
        "parameters":[
        ],
        "produces":[
          "application/xml"
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      }
    },
    "/export/security/":{
      "get":{
        "description":"Export all security settings in XML format",
        "operationId":"ExportSecurity",
        "parameters":[
        ],
        "produces":[
          "application/xml"
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      }
    }
  },
  "definitions":{
  }
}
]]></Data>
</XData>
</Class>


<Class name="lscalese.configcopy.client.msg.ExportConfigRequest">
<Description><![CDATA[
Request Object for application : lscalese.configcopy.client
<br/>Service : ExportConfig]]></Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent</Super>
<TimeChanged>66011,29869.206779</TimeChanged>
<TimeCreated>66011,29869.206779</TimeCreated>
<Inheritance>left</Inheritance>

<Property name="accept">
<Description><![CDATA[
accept : <ul>
<li>application/json</li>
</ul>]]></Description>
<Type>%String</Type>
<InitialExpression>"application/json"</InitialExpression>
</Property>

<Property name="consume">
<Type>%String</Type>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^lscalese.cD0BB.ExportConfi9065D</DataLocation>
<DefaultData>ExportConfigRequestDefaultData</DefaultData>
<IdLocation>^lscalese.cD0BB.ExportConfi9065D</IdLocation>
<IndexLocation>^lscalese.cD0BB.ExportConfi9065I</IndexLocation>
<StreamLocation>^lscalese.cD0BB.ExportConfi9065S</StreamLocation>
<Data name="ExportConfigRequestDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>accept</Value>
</Value>
<Value name="3">
<Value>consume</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="lscalese.configcopy.client.msg.ExportSecurityRequest">
<Description><![CDATA[
Request Object for application : lscalese.configcopy.client
<br/>Service : ExportSecurity]]></Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent</Super>
<TimeChanged>66011,29869.177994</TimeChanged>
<TimeCreated>66011,29869.177994</TimeCreated>
<Inheritance>left</Inheritance>

<Property name="accept">
<Description><![CDATA[
accept : <ul>
<li>application/xml</li>
</ul>]]></Description>
<Type>%String</Type>
<InitialExpression>"application/xml"</InitialExpression>
</Property>

<Property name="consume">
<Type>%String</Type>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^lscalese.cD0BB.ExportSecur6E11D</DataLocation>
<DefaultData>ExportSecurityRequestDefaultData</DefaultData>
<IdLocation>^lscalese.cD0BB.ExportSecur6E11D</IdLocation>
<IndexLocation>^lscalese.cD0BB.ExportSecur6E11I</IndexLocation>
<StreamLocation>^lscalese.cD0BB.ExportSecur6E11S</StreamLocation>
<Data name="ExportSecurityRequestDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>accept</Value>
</Value>
<Value name="3">
<Value>consume</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="lscalese.configcopy.client.msg.ExportTasksRequest">
<Description><![CDATA[
Request Object for application : lscalese.configcopy.client
<br/>Service : ExportTasks]]></Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent</Super>
<TimeChanged>66011,29869.223291</TimeChanged>
<TimeCreated>66011,29869.223291</TimeCreated>
<Inheritance>left</Inheritance>

<Property name="accept">
<Description><![CDATA[
accept : <ul>
<li>application/xml</li>
</ul>]]></Description>
<Type>%String</Type>
<InitialExpression>"application/xml"</InitialExpression>
</Property>

<Property name="consume">
<Type>%String</Type>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^lscalese.cD0BB.ExportTasksE4E2D</DataLocation>
<DefaultData>ExportTasksRequestDefaultData</DefaultData>
<IdLocation>^lscalese.cD0BB.ExportTasksE4E2D</IdLocation>
<IndexLocation>^lscalese.cD0BB.ExportTasksE4E2I</IndexLocation>
<StreamLocation>^lscalese.cD0BB.ExportTasksE4E2S</StreamLocation>
<Data name="ExportTasksRequestDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>accept</Value>
</Value>
<Value name="3">
<Value>consume</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="lscalese.configcopy.client.msg.GenericResponse">
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent</Super>
<TimeChanged>66011,29869.219463</TimeChanged>
<TimeCreated>66011,29869.219463</TimeCreated>
<Inheritance>left</Inheritance>

<Property name="body">
<Type>%Stream.GlobalBinary</Type>
</Property>

<Property name="headers">
<Type>%String</Type>
<Collection>array</Collection>
<Parameter name="MAXLEN" value="128"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="httpStatusCode">
<Type>%Integer</Type>
</Property>

<Property name="operation">
<Type>%String</Type>
<Parameter name="MAXLEN" value="128"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="operationStatusText">
<Type>%String</Type>
<Parameter name="MAXLEN" value="128"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="parsedResponse">
<Type>lscalese.configcopy.client.msg.ParsedResponse</Type>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^lscalese.cD0BB.GenericResp16D5D</DataLocation>
<DefaultData>GenericResponseDefaultData</DefaultData>
<IdLocation>^lscalese.cD0BB.GenericResp16D5D</IdLocation>
<IndexLocation>^lscalese.cD0BB.GenericResp16D5I</IndexLocation>
<StreamLocation>^lscalese.cD0BB.GenericResp16D5S</StreamLocation>
<Data name="GenericResponseDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>body</Value>
</Value>
<Value name="3">
<Value>httpStatusCode</Value>
</Value>
<Value name="4">
<Value>operation</Value>
</Value>
<Value name="5">
<Value>operationStatusText</Value>
</Value>
<Value name="6">
<Value>parsedResponse</Value>
</Value>
</Data>
<Data name="headers">
<Attribute>headers</Attribute>
<Structure>subnode</Structure>
<Subscript>"headers"</Subscript>
</Data>
</Storage>
</Class>


<Class name="lscalese.configcopy.client.msg.GetSpecRequest">
<Description><![CDATA[
Request Object for application : lscalese.configcopy.client
<br/>Service : GetSpec]]></Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent</Super>
<TimeChanged>66011,29869.291142</TimeChanged>
<TimeCreated>66011,29869.291142</TimeCreated>
<Inheritance>left</Inheritance>

<Property name="accept">
<Description><![CDATA[
accept : <ul>
<li>application/json</li>
</ul>]]></Description>
<Type>%String</Type>
<InitialExpression>"application/json"</InitialExpression>
</Property>

<Property name="consume">
<Type>%String</Type>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^lscalese.coD0BB.GetSpecRequestD</DataLocation>
<DefaultData>GetSpecRequestDefaultData</DefaultData>
<IdLocation>^lscalese.coD0BB.GetSpecRequestD</IdLocation>
<IndexLocation>^lscalese.coD0BB.GetSpecRequestI</IndexLocation>
<StreamLocation>^lscalese.coD0BB.GetSpecRequestS</StreamLocation>
<Data name="GetSpecRequestDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>accept</Value>
</Value>
<Value name="3">
<Value>consume</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="lscalese.configcopy.client.msg.ParsedResponse">
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent,%XML.Adaptor</Super>
<TimeChanged>66011,29869.275549</TimeChanged>
<TimeCreated>66011,29869.275549</TimeCreated>
<Inheritance>right</Inheritance>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^lscalese.coD0BB.ParsedResponseD</DataLocation>
<DefaultData>ParsedResponseDefaultData</DefaultData>
<IdLocation>^lscalese.coD0BB.ParsedResponseD</IdLocation>
<IndexLocation>^lscalese.coD0BB.ParsedResponseI</IndexLocation>
<StreamLocation>^lscalese.coD0BB.ParsedResponseS</StreamLocation>
<Data name="ParsedResponseDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="lscalese.configcopy.client.msg.getexportsysglobalsRequest">
<Description><![CDATA[
Request Object for application : lscalese.configcopy.client
<br/>Service : getexportsysglobals]]></Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent</Super>
<TimeChanged>66011,29869.245045</TimeChanged>
<TimeCreated>66011,29869.245045</TimeCreated>
<Inheritance>left</Inheritance>

<Property name="accept">
<Description><![CDATA[
accept : <ul>
<li>application/xml</li>
</ul>]]></Description>
<Type>%String</Type>
<InitialExpression>"application/xml"</InitialExpression>
</Property>

<Property name="consume">
<Type>%String</Type>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^lscalese.cD0BB.getexportsy745AD</DataLocation>
<DefaultData>getexportsysglobalsRequestDefaultData</DefaultData>
<IdLocation>^lscalese.cD0BB.getexportsy745AD</IdLocation>
<IndexLocation>^lscalese.cD0BB.getexportsy745AI</IndexLocation>
<StreamLocation>^lscalese.cD0BB.getexportsy745AS</StreamLocation>
<Data name="getexportsysglobalsRequestDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>accept</Value>
</Value>
<Value name="3">
<Value>consume</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="lscalese.configcopy.rest.hsdisp">
<Description>
This is an implementation of lscalese.configcopy.rest.disp especially for HealthShare
%REST is not available on HealthShare we need a special implementation HealthShare support.</Description>
<Super>%CSP.REST</Super>
<TimeChanged>66012,50378.090561</TimeChanged>
<TimeCreated>66012,28822.980865</TimeCreated>

<Parameter name="CONVERTINPUTSTREAM">
<Description>
By default convert the input stream to Unicode</Description>
<Default>1</Default>
</Parameter>

<Parameter name="CHARSET">
<Description>
The default response charset is utf-8</Description>
<Default>utf-8</Default>
</Parameter>

<XData name="UrlMap">
<XMLNamespace>http://www.intersystems.com/urlmap</XMLNamespace>
<Data><![CDATA[
<Routes>
  <!-- Swagger 2.0 specification -->
  <Route Url="/" Method="get" Call="GetSpec" />
  <Route Url="/export/sysglobals/" Method="get" Call="ExportSysglobals" />
  <Route Url="/export/config/" Method="get" Call="ExportConfig" />
  <Route Url="/export/tasks/" Method="get" Call="ExportTasks" />
  <Route Url="/export/security/" Method="get" Call="ExportSecurity" />
</Routes>
]]></Data>
</XData>

<Method name="GetSpec">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Write {"msg":"Only available with IRIS"}.%ToJSON()
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="ExportSysglobals">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Set Filename = ##class(%File).TempFilename()
    Set sc = ##class(lscalese.configcopy.LocalExport).Globals(Filename)
    
    If $$$ISERR(sc) {
        Do:##class(%File).Exists(Filename) ##class(%File).Delete(Filename)
        $$$ThrowStatus(sc)
    }

    Set fcs = ##class(%Stream.FileCharacter).%New()
    Set sc = fcs.LinkToFile(Filename)
    If $$$ISERR(sc) $$$ThrowStatus(sc)
    #dim cs As %Stream.GlobalCharacter = ##class(%Stream.GlobalCharacter).%New()
    Do cs.CopyFrom(fcs)

    Do ##class(%File).Delete(Filename)

    Do cs.OutputToDevice()

    Return $$$OK
]]></Implementation>
</Method>

<Method name="ExportConfig">
<Description>
Export configuration in config-api format : https://github.com/lscalese/iris-config-api .</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, restore = $$$NO
    Try {
        Do ##class(IORedirect.Redirect).ToString()
        Set restore = $$$YES
        Set config = ##class(lscalese.configcopy.LocalExport).CPFDataTemplate(.sc, "Default")
    } Catch (ex) {
         Set sc = ex.AsStatus()
    }
    If restore {
        Do ##class(IORedirect.Redirect).RestoreIO()
        Do ##class(IORedirect.Redirect).ClearConfig()
    }
    If $$$ISERR(sc) {
        $$$ThrowStatus(sc)
    }
    Write config.%ToJSON()

    Return $$$OK
]]></Implementation>
</Method>

<Method name="ExportTasks">
<Description>
Export all users defined tasks in XML format.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Set Filename = ##class(%File).TempFilename()
    Set sc = ##class(lscalese.configcopy.LocalExport).Tasks(Filename)
    
    If $$$ISERR(sc) {
        Do:##class(%File).Exists(Filename) ##class(%File).Delete(Filename)
        $$$ThrowStatus(sc)
    }

    Set fcs = ##class(%Stream.FileCharacter).%New()
    Set sc = fcs.LinkToFile(Filename)
    If $$$ISERR(sc) $$$ThrowStatus(sc)
    #dim cs As %Stream.GlobalCharacter = ##class(%Stream.GlobalCharacter).%New()
    Do cs.CopyFrom(fcs)

    Do ##class(%File).Delete(Filename)

    Do cs.OutputToDevice()

    Return $$$OK
]]></Implementation>
</Method>

<Method name="ExportSecurity">
<Description>
Export all security settings in XML format</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Set Filename = ##class(%File).TempFilename()
    Set sc = ##class(lscalese.configcopy.LocalExport).Security(Filename)
    
    If $$$ISERR(sc) {
        Do:##class(%File).Exists(Filename) ##class(%File).Delete(Filename)
        $$$ThrowStatus(sc)
    }

    Set fcs = ##class(%Stream.FileCharacter).%New()
    Set sc = fcs.LinkToFile(Filename)
    If $$$ISERR(sc) $$$ThrowStatus(sc)
    #dim cs As %Stream.GlobalCharacter = ##class(%Stream.GlobalCharacter).%New()
    Do cs.CopyFrom(fcs)

    Do ##class(%File).Delete(Filename)

    Do cs.OutputToDevice()

    Return $$$OK
]]></Implementation>
</Method>
</Class>
</Export>
