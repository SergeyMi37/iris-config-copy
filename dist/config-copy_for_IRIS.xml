<?xml version="1.0" encoding="UTF-8"?>
<Export generator="IRIS" version="26" zv="IRIS for UNIX (Ubuntu Server LTS for x86-64 Containers) 2020.4 (Build 547U)" ts="2021-09-25 07:48:35">
<Class name="Api.Config.Developers.ClassGenerator">
<Description>
DON'T USE.  (class used for first code generation.)
Generator for 
- Swagger spec.
- REST Service implementation.
- Proxy class with Config package.
Classes in %SYS config package are pretty similar.
So, We can write easily an algorithm to generate needed classes.</Description>
<Super>%RegisteredObject</Super>
<TimeChanged>66011,29866.887291</TimeChanged>
<TimeCreated>66011,29866.887291</TimeCreated>

<Property name="class">
<Description>
Configuration class</Description>
<Type>%Dictionary.CompiledClass</Type>
</Property>

<Property name="generatedClassName">
<Type>%String</Type>
</Property>

<Property name="outClass">
<Type>%Dictionary.ClassDefinition</Type>
<InitialExpression>##class(%Dictionary.ClassDefinition).%New()</InitialExpression>
</Property>

<Property name="parameters">
<Type>%Binary</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="temp">
<Type>%Binary</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="swaggerSpec">
<Type>%DynamicObject</Type>
</Property>

<Property name="restApp">
<Type>%String</Type>
<InitialExpression>"Api.Config.REST"</InitialExpression>
</Property>

<Method name="test">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    ;d ##class(Api.Config.Developers.ClassGenerator).test()
    tro
    TSTART
    
    Set swagger = {
        "swagger":"2.0",
        "host":"localhost:32773",
        "basePath":"/api/config",
        "schemes":[
            "http","https"
        ],
        "info":{
            "title":"IRIS Config API",
            "version":"0.0.1",
            "description":"Config API.",
            "contact":{
            "name":"Lorenzo Scalese",
            "email":"lorenzo.scalese@gmail.com",
            "url":"https://github.com/lscalese/Iris-Deploy-Utils-API/"
            },
            "license":{
            "name":"MIT",
            "url":"https://github.com/lscalese/Iris-Deploy-Utils-API/blob/master/LICENSE"
            }
        },
        "produces":[
            "application/json"
        ],
        "paths":{
            "/":{
                "get":{
                    "tags":[
                        "Developer"
                    ],
                    "operationId":"GetSpecification",
                    "description":"Swagger 2.0 specification",
                    "responses":{
                        "200":{
                            "description":"OK"
                        }
                    }
                }
            }
        },
        "definitions":{}
    }

    Set outPKG = "Api.Config.Services.", ptr = 0
    Set clsList = ..getConfigClassList() ;$LISTBUILD("Config.MapGlobals","Config.Journal")
    ;Set clsList = $LISTBUILD("Config.Databases")

    While $LISTNEXT(clsList, ptr, v) {
        Set gen = ..%New(v, outPKG _ $Piece(v,".",*), swagger)
        Set sc = gen.generate()

    }

    Set formatter=##class(%JSON.Formatter).%New()
    Set swaggerString = ""
    Do formatter.FormatToString(swagger, .swaggerString)
    ;w !,swaggerString
    
    Set file=##class(%File).%New($Get(parameters("outSwaggerFile"),"/irisrun/repo/GENERATOR.json"))
    Do file.Open("WSN")
    Do file.Write(swaggerString)
    Do file.SaveStream()


    Quit
]]></Implementation>
</Method>

<Method name="getConfigClassList">
<ClassMethod>1</ClassMethod>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Set classes("Cluster")=""
    Set classes("ConfigFile")=""
    Set classes("Databases")=""
    Set classes("Debug")=""
    Set classes("DeviceSubTypes")=""
    Set classes("Devices")=""
    Set classes("ECP")=""
    Set classes("ECPServers")=""
    Set classes("IO")=""
    Set classes("Journal")=""
    Set classes("LicenseServers")=""
    Set classes("MagTapes")=""
    Set classes("MapGlobals")=""
    Set classes("MapMirrors")=""
    Set classes("MapPackages")=""
    Set classes("MapRoutines")=""
    Set classes("MapShadows")=""
    Set classes("MirrorMember")=""
    Set classes("Mirrors")=""
    Set classes("Miscellaneous")=""
    Set classes("Monitor")=""
    Set classes("Namespaces")=""
    Set classes("SQL")=""
    Set classes("Shadows")=""
    Set classes("SqlSysDatatypes")=""
    Set classes("SqlUserDatatypes")=""
    Set classes("Startup")=""
    Set classes("Telnet")=""
    Set classes("config")=""
    
    
    Set class = ""
    For  {
        Set class = $Order(classes(class))
        Quit:class=""
        Set $List(lst,*+1) = "Config."_class
        
    }
    Quit lst
]]></Implementation>
</Method>

<Method name="%OnNew">
<FormalSpec><![CDATA[configClassName:%String,generatedClassName:%String,swagger:%DynamicObject={{}},&parameters:%Binary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, ns = $NAMESPACE 
    
    New $NAMESPACE 
    Set $NAMESPACE= "%SYS"
    
    Set ..class = ##class(%Dictionary.CompiledClass).%OpenId(configClassName,,.sc)
    Quit:$$$ISERR(sc) sc
    
    Set $NAMESPACE= ns
    Set ..swaggerSpec = swagger
    If '$$$defClassDefined(generatedClassName) {
        Set ..outClass = ##class(%Dictionary.ClassDefinition).%New()
        Set ..outClass.Name = generatedClassName
        Set ..outClass.IncludeCode = "Api.Config.inc"
        Set ..outClass.ProcedureBlock = $$$YES
    } Else {
        Set ..outClass = ##class(%Dictionary.ClassDefinition).%OpenId(generatedClassName)
    }
    
    If $Data(parameters) {
        Merge ..parameters = parameters
    }
    Quit sc
]]></Implementation>
</Method>

<Method name="generate">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, ns = $NAMESPACE, key = "", template = {}
    
    Set swaggerDef = {
        "type" : "object",
        "properties" : {},
        "required" : []
    }

    New $NAMESPACE 
    
    Do ..log("Start Generating Class "_..outClass.Name)

    #define GETTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"number",:"string")
    #define GETSWAGGERTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"integer",:"string")

    $$$QuitOnError(..ToDynamic())
    $$$QuitOnError(..ToArray())
    $$$QuitOnError(..Get())
    $$$QuitOnError(..Exists())
    $$$QuitOnError(..Create())
    $$$QuitOnError(..Update())
    $$$QuitOnError(..Delete())
    $$$QuitOnError(..CheckModel())
    $$$QuitOnError(..ObjectToArray())
    $$$QuitOnError(..List())

    For  {
        Set $NAMESPACE= "%SYS", property = ..class.Properties.GetNext(.key), $NAMESPACE= ns

        Quit:key=""
        Continue:..skipProperty(property)

        Set dflt = ""
        If property.InitialExpression '= "" {
            Set $NAMESPACE= "%SYS"
            Try { ; attempt to evaluate InitialExpression
                XECUTE ("(out) SET out="_ property.InitialExpression, .dflt)
            } Catch(ex) { 
                Do ..log("Evaluate initial expression failed for "_property.Name_" : "_property.InitialExpression)
            }
            Set $NAMESPACE= ns
        }
        
        Set jsonType = $$$GETTYPE($Replace(property.Type, "Library.",""))
        Set swaggerType = $$$GETSWAGGERTYPE($Replace(property.Type, "Library.",""))

        Do ToDynamic, ToArray, CheckModel, SwaggerDefinition, ObjectToArray

    }

    
    
    Do ..wlMethod($CHAR(9)_"Quit model", "ToDynamic")
    Do ..wlMethod($CHAR(9)_"Quit", "ToArray")
        
    Do ..wlMethod($CHAR(9)_"Quit sc", "CheckModel")
    Do ..wlMethod($CHAR(9)_"Quit", "ObjectToArray")

    Set clsKey = $Piece(..class.Name, ".", *)
    ;Set clsKey = $s($e(clsKey,*)="s":$e(clsKey,1,*-1),1:clsKey)
    
    Set swaggerDef.example = template
    
    Set:'$ISOBJECT(..swaggerSpec.definitions) ..swaggerSpec.definitions = {}
    Do:swaggerDef.required.%Size()=0 swaggerDef.%Remove("required")

    Do ..swaggerSpec.definitions.%Set(clsKey, swaggerDef)

    If ..configQueryExists("List") {
        Set listOf = {
            "type":"object",
            "properties": {}
        }
        Do listOf.properties.%Set(clsKey, {
            "type":"array",
            "items":{
                "$ref":("#/definitions/"_clsKey)
            }
        })
        Set lisOfPropertyName = "ListOf"_$$$UPPER($Extract(clsKey))_$Extract(clsKey,2,*)
        Set ..temp("RESTGEN","listof") = lisOfPropertyName
        Do ..swaggerSpec.definitions.%Set(lisOfPropertyName, listOf)
    }

    Do ..Path(clsKey)
    Set sc = ##class(%REST.API).CreateApplication(..restApp,..swaggerSpec)
    Do ..log("Update CSP REST application : "_$SYSTEM.Status.GetOneErrorText(sc))
    Do ..addRestImpl()
    Set sc = ..outClass.%Save()
    
    Quit sc

ToDynamic
    Set line = $CHAR(9) _ $$$FormatText("Do:$Data(properties(""%1"")) model.%Set(""%1"", properties(""%1""), ""%2"")", property.Name, jsonType)
    Do ..wlMethod(line, "ToDynamic")
    Quit 1 ; Quit 1 for the pleasure of SonarQube :p

ToArray
    If 'property.ReadOnly {
        Set line = $CHAR(9) _ $$$FormatText("Set:$$$CanSetProperty(model,""%1"") properties(""%1"") = model.%1", property.Name)
        Do ..wlMethod(line, "ToArray")
    }
    Quit 1

CheckModel
    If dflt=""&&property.Required {
        Set line = $CHAR(9) _ $$$FormatText("Set:model.%1="""" sc = $$$ADDSC(sc,$$$ERROR(5001, ""%1 property is mandatory.""))",property.Name)
        Do ..wlMethod(line,"CheckModel")
    }
    Quit 1

SwaggerDefinition
    If dflt=""&&property.Required {
        Do swaggerDef.required.%Push(property.Name)
        Do template.%Set(property.Name, dflt, jsonType)
    }

    Set description = ..getPropertyDescription(property.Name)

    Do swaggerDef.properties.%Set(property.Name, {
        "type" : (swaggerType),
        "default" : (dflt),
        "description" : (description)
    })

    Quit 1

ObjectToArray
    Set line = $CHAR(9)_$$$FormatText("Set properties(""%1"") = pObj.%1",property.Name)
    Do ..wlMethod(line, "ObjectToArray")
    Quit 1
]]></Implementation>
</Method>

<Method name="wlMethod">
<FormalSpec>line:%String,methodName:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set method = $Get(..temp(methodName))
    Quit:'$ISOBJECT(method) $$$OK
    ;Do ..log(methodName _" "_line)
    Do method.Implementation.WriteLine(line)
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="Path">
<FormalSpec>clsKey:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    Set service = {}
    
    Set serviceKey = "/"_$$$LOWER(clsKey)_"/", serviceKeyLocation = "%request.Application_"""_serviceKey_""""

    If '..isCommonSingle() {
        Do ..GetFormalSpec("Get",.callString)
        Set lst = $LISTFROMSTRING(callString, ","), ptr = 0
        
        While $LISTNEXT(lst, ptr, param) {
            Set serviceKey = serviceKey _ $Select($Extract(serviceKey,*)'="/":"/",1:"") _ $Replace("{%1}","%1",$$$LOWER(param))
            Set serviceKeyLocation = serviceKeyLocation _ "_"_$$$LOWER(param) _"/"
            Set rmTrailing=1
        }
        Set:$Get(rmTrailing) serviceKeyLocation = $Extract(serviceKeyLocation,1,*-1)
    }

    Set ..temp("RESTGEN","location")=serviceKeyLocation

    Do service.%Set("get", ..SwaggerGet(clsKey,.operationId))
    Set ..temp("RESTMETHOD","RESTTemplateGET")=operationId
    Do service.%Set("put", ..SwaggerPut(clsKey,.operationId))
    Set ..temp("RESTMETHOD","RESTTemplatePUT")=operationId

    If '..isCommonSingle() {
        Do service.%Set("post", ..SwaggerPost(clsKey,.operationId))
        Set ..temp("RESTMETHOD","RESTTemplatePOST")=operationId
        Do service.%Set("delete", ..SwaggerDelete(clsKey,.operationId))
        Set ..temp("RESTMETHOD","RESTTemplateDELETE")=operationId
    }
    

    Do ..swaggerSpec.paths.%Set(serviceKey, service)

    ;If "/"_$$$LOWER(clsKey)_"/"'=serviceKey,..configQueryExists("List") {
    If '..isCommonSingle(),..configQueryExists("List") {
        If ..isCommonMapMethods() {
            Set serviceKey = "/"_$$$LOWER(clsKey)_"/{namespace}/" 
        } Else {
            Set serviceKey = "/"_$$$LOWER(clsKey)_"/"
        }
        Do ..swaggerSpec.paths.%Set(serviceKey, {"get":(..SwaggerGetList(clsKey,.operationId))})
        Set ..temp("RESTMETHOD","RESTTemplateGETList")=operationId
    }

    Quit $$$OK
]]></Implementation>
</Method>

<Method name="addRestImpl">
<FormalSpec>class:%String=..restApp_".impl"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Set cdef = ##class(%Dictionary.ClassDefinition).%OpenId(class)
    Set cdef.IncludeCode = "Api.Config.inc"
    Do cdef.%Save()

    #dim mdef As %Dictionary.MethodDefinition
    Set mTemplate = ""
    For  {
        Set mTemplate = $Order(..temp("RESTMETHOD",mTemplate),1,methodName)
        Quit:mTemplate=""
        
        Set mdef = ##class(%Dictionary.MethodDefinition).%OpenId(class _ "||" _ methodName)
        Set template=$METHOD(##this,mTemplate)
        Set buff = template.Read()
        Set replace = ""
        For  {
            Set replace = $Order(..temp("RESTGEN",replace),1,value)
            Quit:replace=""
            Set buff = $replace(buff, "{{"_replace_"}}", value)
        }
        w !,methodName
        Do mdef.Implementation.Clear()
        Do mdef.Implementation.Write(buff)
        Set sc2 = mdef.%Save()
        Do ..log("Add REST method implementation "_ methodName _ " "_$SYSTEM.Status.GetOneErrorText(sc2))
        Set:$$$ISERR(sc2) sc = $$$ADDSC(sc,sc2)
    }
    
    Quit sc
]]></Implementation>
</Method>

<Method name="SwaggerDelete">
<FormalSpec>clsKey:%String,*operationId</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[

    Set verb = "delete"
    Set operationId =($$$UPPER($Extract(verb)) _ $Extract(verb, 2, *) _ clsKey)
    Set parameters = ..SwggerGetCommonParam()

    Set responses = {
        "204": {
            "description" : (clsKey _" deleted.")
            
        },
        "400" : {
            "description" : "Bad request, can occurs if mandatory parameters are missing or empty"
        },
        "404" : {
            "description" : (clsKey _ " not found.")
        }
    }

    Set desc = "Delete "_clsKey _ "."
    Set method = {
        "operationId" : (operationId),
        "description": (desc),
        "parameters" : (parameters),
        "responses" : (responses)
    }

    Quit method
]]></Implementation>
</Method>

<Method name="SwaggerPut">
<FormalSpec>clsKey:%String,*operationId</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set verb = "put"
    Set parameters = ..SwggerGetCommonParam()
    Set operationId =($$$UPPER($Extract(verb)) _ $Extract(verb, 2, *) _ clsKey)
    Do parameters.%Push({
        "name": "model",
        "description" : (clsKey _ " to update."),
        "in": "body",
        "required":true,
        "schema": {
            "$ref": ("#/definitions/" _ clsKey)
        }
    })

    Set responses = {
        "204" : {
            "description": "Ressource updated."
        },
        "400" : {
            "description" : "Bad request, can occurs if mandatory parameters are missing or empty"
        },
        "404" : {
            "description" : (clsKey _ " to update not found.")
        }
    }

    Set desc = "Update "_clsKey _ "."
    Set method = {
        "operationId" : (operationId),
        "description": (desc),
        "parameters" : (parameters),
        "responses" : (responses)
    }

    Quit method
]]></Implementation>
</Method>

<Method name="SwaggerPost">
<FormalSpec>clsKey:%String,*operationId</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set verb = "post"
    Set operationId =($$$UPPER($Extract(verb)) _ $Extract(verb, 2, *) _ clsKey)
    Set parameters = ..SwggerGetCommonParam()
    
    Do parameters.%Push({
        "name": "model",
        "description" : (clsKey _ " to create."),
        "in": "body",
        "required":true,
        "schema": {
            "$ref": ("#/definitions/" _ clsKey)
        }
    })

    
    Set responses = {
        "201": {
            "description" : (clsKey _" created."),
            "headers": {
                "Location": {
                    "type":"string",
                    "description":"Created ressource location."
                }
            }
        },
        "400" : {
            "description" : "Bad request, can occurs if mandatory parameters are missing or empty"
        },
        "409" : {
            "description" : ( clsKey _ " already exists.")
        }
    }

    Set desc = "Create "_clsKey _ "."
    Set method = {
        "operationId" : (operationId),
        "description": (desc),
        "parameters" : (parameters),
        "responses" : (responses)
    }
    
    Quit method
]]></Implementation>
</Method>

<Method name="SwaggerGetList">
<FormalSpec>clsKey,*operationId</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set verb = "get"
    Set operationId =($$$UPPER($Extract(verb)) _ $Extract(verb, 2, *) _"List"_ clsKey)
    Set parameters = []

    Do:..isCommonMapMethods() parameters.%Push({
        "name": "namespace",
        "description" : "namespace.",
        "in": "path",
        "required":true,
        "type":"string"
    })
    
    Set responses = {
        "200": {
            "description" : "OK",
            "schema": {
                "$ref": ("#/definitions/ListOf" _ clsKey)
            }
        },
        "400" : {
            "description" : "Bad request, can occurs if mandatory parameters are missing or empty."
        }
    }
    Set desc = "Get List Of "_clsKey _ "."
    Set method = {
        "operationId" : (operationId),
        "description": (desc),
        "parameters" : (parameters),
        "responses" : (responses)
    }
    
    Quit method
]]></Implementation>
</Method>

<Method name="SwaggerGet">
<FormalSpec>clsKey:%String,*operationId</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set verb = "get"
    Set operationId =($$$UPPER($Extract(verb)) _ $Extract(verb, 2, *) _ clsKey)
    Set parameters = ..SwggerGetCommonParam()

    Set responses = {
        "200": {
            "description" : "OK",
            "schema": {
                "$ref": ("#/definitions/" _ clsKey)
            }
        },
        "400" : {
            "description" : "Bad request, can occurs if mandatory parameters are missing or empty."
        },
        "404" : {
            "description" : (clsKey _ " not found.")
        }
    }
    Set desc = "Get "_clsKey _ "."
    Set method = {
        "operationId" : (operationId),
        "description": (desc),
        "parameters" : (parameters),
        "responses" : (responses)
    }
    
    Quit method
]]></Implementation>
</Method>

<Method name="SwggerGetCommonParam">
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set parameters = []
    ;
    ;w !,"..isCommonSingle() : ",..isCommonSingle(),!
    Set ..temp("RESTGEN","params")="", ..temp("RESTGEN","getlistparams")=""

    If '..isCommonSingle() {
        Do ..GetFormalSpec("Get",.callString)
        ;w !,"call string " ,callString,!
        Set lst = $LISTFROMSTRING(callString, ","), ptr = 0, params=""
        
        While $LISTNEXT(lst, ptr, param) {
            Set description = ..getPropertyDescription(param)
            Do parameters.%Push({
                "name" : ($$$LOWER(param)),
                "description" : (description),
                "in" : "path",
                "type" : "string",
                "required" : true
            })
            Set params = params_","_$$$LOWER(param)
            ;w !,"desc ",description
        }
    
        Set ..temp("RESTGEN","params")=$Extract(params,2,*)
    
    } 
    
    If ..isCommonMapMethods() {
        Set ..temp("RESTGEN","getlistparams") = $Piece(..temp("RESTGEN","params"),",",1)
    }

    Quit parameters
]]></Implementation>
</Method>

<Method name="ToDynamic">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK

    Do ..log(" * Generate method ToDynamic : ")
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||ToDynamic" ) {
        Set mToDynamic = ##class(%Dictionary.MethodDefinition).%New()
        Set mToDynamic.Name = "ToDynamic"
        Set mToDynamic.ClassMethod = $$$YES
        Set mToDynamic.FormalSpec = "&properties:%Binary" ; "pObj:"_className
        Set mToDynamic.ReturnType = "%Library.DynamicObject"
        Do mToDynamic.Implementation.WriteLine($CHAR(9) _ "Set model = {}")
        Do ..outClass.Methods.Insert(mToDynamic)
        Set ..temp("ToDynamic")=mToDynamic
        Do ..log( "Initialized.", 0)
    } Else {
        Do ..log( "Already exists (skipped).", 0)
    }

    Quit sc
]]></Implementation>
</Method>

<Method name="ToArray">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Do ..log(" * Generate method ToArray : ")
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||ToArray") {
        Set mToArray = ##class(%Dictionary.MethodDefinition).%New()
        Set mToArray.Name = "ToArray"
        Set mToArray.ClassMethod = $$$YES
        Set mToArray.FormalSpec = "model:%Library.DynamicObject,*properties:%Binary"
        Set mToArray.ReturnType = ""
        Do ..outClass.Methods.Insert(mToArray)
        Set ..temp("ToArray")=mToArray
        Do ..log( "Initialized.", 0)
    } Else {
        Do ..log( "Already exists (skipped).", 0)
    }

    Quit sc
]]></Implementation>
</Method>

<Method name="Get">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Do ..log(" * Generate method Get : ")
    Set methodName = "Get"
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name_"||"_methodName) {
        #dim method As %Dictionary.MethodDefinition = ##class(%Dictionary.MethodDefinition).%New()
        Set method.Name = methodName
        Set method.ClassMethod = $$$YES
        Set method.ReturnType = "%Library.DynamicObject"
        If ..isCommonSingle() {
            Set args = ""
        } Else {
            Set method.FormalSpec = ..GetFormalSpec(methodName, .callString)
            Do method.Implementation.WriteLine($CHAR(9) _ "Quit:'..Exists(" _ callString _ ") """"")
            Set args = $Select(callString'="":callString_",",1:"")
        }
        Do method.Implementation.WriteLine($CHAR(9) _ "$$$switchNSSys")
        
        Do method.Implementation.WriteLine($CHAR(9) _ $$$FormatText("$$$ThrowOnError(##class(%1).Get("_args_".properties))", ..class.Name))
        Do method.Implementation.WriteLine($CHAR(9) _ "Quit ..ToDynamic(.properties)")
        Do ..outClass.Methods.Insert(method)
        Set ..temp(methodName)=method
        Do ..log("Initialized.", 0)
    } Else {
        Do ..log("Already exists (skipped).", 0)
    }
    Set ..temp("RESTGEN","get") = $$$FormatText("##class(%1).%2", ..outClass.Name, methodName)
    Quit sc
]]></Implementation>
</Method>

<Method name="Exists">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, methodName = "Exists"
    Quit:'..configMethodExists(methodName) sc

    Quit:..isCommonSingle() sc

    Do ..log(" * Generate method Exists : ")
    
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||"_methodName) {
        Set method = ##class(%Dictionary.MethodDefinition).%New()
        Set method.Name = methodName
        Set method.ClassMethod = $$$YES
        Set method.ReturnType = "%Boolean"
        Set method.FormalSpec = ..GetFormalSpec("Get", .callString) 
        Do method.Implementation.WriteLine($CHAR(9) _ "$$$switchNSSys")
        Do method.Implementation.WriteLine($CHAR(9) _ $$$FormatText("Quit ##class(%1).Exists("_callString_")", ..class.Name))
        Do ..outClass.Methods.Insert(method)
        Set ..temp(methodName)=method
        Do ..log("Initialized.", 0)
    } Else {
        Do ..log("Already exists (skipped).", 0)
    }
     Set ..temp("RESTGEN","exists") = $$$FormatText("##class(%1).%2", ..outClass.Name, methodName)
    Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, methodName = "Create"
    Quit:'..configMethodExists(methodName) sc
    
    Set ns = $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Quit:$CLASSMETHOD(..class.Name,"%Extends","Config.CommonSingleMethods") sc
    Set $NAMESPACE = ns

    Do ..log(" * Generate method Create : ")

    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||" _ methodName) {
        Set method = ##class(%Dictionary.MethodDefinition).%New()
        Set method.Name = methodName
        Set method.ClassMethod = $$$YES
        Set method.ReturnType = "%Status"
        Set method.FormalSpec = "model:%Library.DynamicObject"
        Do ..GetFormalSpec("Get", .callString, "model.")
        Do method.Implementation.WriteLine($CHAR(9) _ "Do ..ToArray(model,.properties)")
        Do method.Implementation.WriteLine($CHAR(9) _ "$$$switchNSSys")
        Set args = $Select(callString'="":callString_",",1:"")
        Do method.Implementation.WriteLine($CHAR(9) _ $$$FormatText("Quit ##class(%1).Create("_args_".properties)", ..class.Name))
        Do ..outClass.Methods.Insert(method)
        Set ..temp(methodName)=method
        Do ..log("Initialized.", 0)

    } Else {
        Do ..log("Already exists (skipped).", 0)
    }
    Set ..temp("RESTGEN","create") = $$$FormatText("##class(%1).%2", ..outClass.Name, methodName)
    Quit sc
]]></Implementation>
</Method>

<Method name="Update">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, methodName = "Update"
    Quit:'..configMethodExists("Modify") sc
    Do ..log(" * Generate method Update : ")
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||" _ methodName) {
        Set method = ##class(%Dictionary.MethodDefinition).%New()
        Set method.Name = methodName
        Set method.ClassMethod = $$$YES
        Set method.ReturnType = "%Status"
        Set method.FormalSpec = "model:%Library.DynamicObject"
        If '..isCommonSingle() {
            Do ..GetFormalSpec("Get", .callString, "model.") 
            Set args = $Select(callString'="":callString_",",1:"")
        } Else {
            Set args = ""
        }
        Do method.Implementation.WriteLine($CHAR(9) _ "Do ..ToArray(model,.properties)")
        Do method.Implementation.WriteLine($CHAR(9) _ "$$$switchNSSys")
       
        Do method.Implementation.WriteLine($CHAR(9) _ $$$FormatText("Quit ##class(%1).Modify("_args_".properties)", ..class.Name))
        Do ..outClass.Methods.Insert(method)
        Set ..temp(methodName)=method
        Do ..log("Initialized.", 0)
    } Else {
        Do ..log("Already exists (skipped).", 0)
    }
    Set ..temp("RESTGEN","update") = $$$FormatText("##class(%1).%2", ..outClass.Name, methodName)
    Quit sc
]]></Implementation>
</Method>

<Method name="Delete">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, methodName = "Delete"
    Quit:'..configMethodExists(methodName) sc
    Do ..log(" * Generate method Delete : ")
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||" _ methodName) {
        Set method = ##class(%Dictionary.MethodDefinition).%New()
        Set method.Name = methodName
        Set method.ClassMethod = $$$YES
        Set method.ReturnType = "%Status"
        Set method.FormalSpec = ..GetFormalSpec("Get", .callString) 
        Do method.Implementation.WriteLine($CHAR(9) _ "$$$switchNSSys")
        Do method.Implementation.WriteLine($CHAR(9) _ $$$FormatText("Quit ##class(%1).Delete("_callString_")", ..class.Name))
        Do ..outClass.Methods.Insert(method)
        Set ..temp(methodName)=method
        Do ..log("Initialized.", 0)
    } Else {
        Do ..log("Already exists (skipped).", 0)
    }
    Set ..temp("RESTGEN","delete") = $$$FormatText("##class(%1).%2", ..outClass.Name, methodName)
    Quit sc
]]></Implementation>
</Method>

<Method name="CheckModel">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, methodName =  "CheckModel"
    Do ..log(" * Generate method CheckModel : ")
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||" _methodName) {
        Set checkModelMethod = ##class(%Dictionary.MethodDefinition).%New()
        Set checkModelMethod.Name = methodName
        Set checkModelMethod.ClassMethod = $$$YES
        Set checkModelMethod.ReturnType = "%Status"
        Set checkModelMethod.FormalSpec = "model:%Library.DynamicObject"
        Do checkModelMethod.Implementation.WriteLine($CHAR(9)_"Set sc = $$$OK")
        Do ..outClass.Methods.Insert(checkModelMethod)
        Set ..temp(methodName)=checkModelMethod
        Do ..log("Initialized.", 0)
    } Else {
        Do ..log("Already exists (skipped).", 0)
    }
    Set ..temp("RESTGEN","checkmodel") = $$$FormatText("##class(%1).%2", ..outClass.Name, methodName)
    Quit sc
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, methodName = "ObjectToArray"
    Do ..log(" * Generate method ObjectToArray : ")
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||" _methodName) {
        Set mObjectToArray = ##class(%Dictionary.MethodDefinition).%New()
        Set mObjectToArray.Name = methodName
        Set mObjectToArray.ClassMethod = $$$YES
        Set mObjectToArray.ReturnType = ""
        Set mObjectToArray.FormalSpec = "&pObj,*properties:%Binary"
        Do ..outClass.Methods.Insert(mObjectToArray)
        Do ..outClass.Methods.Insert(mObjectToArray)
        Set ..temp(methodName)=mObjectToArray
        Do ..log("Initialized.", 0)
    } Else {
        Do ..log("Already exists (skipped).", 0)
    }
    Quit sc
]]></Implementation>
</Method>

<Method name="List">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, methodName = "List"
    Quit:'..configQueryExists(methodName) sc
    Set ns = $NAMESPACE
    New $NAMESPACE

    Do ..log(" * Generate method List : ")
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||" _ methodName) {
        Set method = ##class(%Dictionary.MethodDefinition).%New()
        Set method.Name = methodName
        Set method.ClassMethod = $$$YES
        Set method.ReturnType = "%DynamicArray"
        Set method.FormalSpec = ..GetFormalSpecList(.callString)
        Do method.Implementation.WriteLine($CHAR(9) _ "$$$switchNSSys")
        Do method.Implementation.WriteLine($CHAR(9) _ "Set list = []")
        Do method.Implementation.WriteLine($CHAR(9) _ "Try{")
        Do method.Implementation.WriteLine($CHAR(9,9) _ "Set rs=##class(%Library.ResultSet).%New("""_..class.Name_":List"")")
        Do method.Implementation.WriteLine($CHAR(9,9) _ "Do rs.Execute("_callString_")")
        Do method.Implementation.WriteLine($CHAR(9,9) _ "While rs.Next() {")
        
        Set $NAMESPACE = "%SYS"
        Set paramsGet = ""
        If $CLASSMETHOD(..class.Name, "%Extends", "Config.CommonSingleMethods") {
            Set paramsGet = ""
        } ElseIf $CLASSMETHOD(..class.Name, "%Extends", "Config.CommonMapMethods") {
            Set paramsGet = "Namespace, rs.Data(""Name"")"
        } ElseIf $CLASSMETHOD(..class.Name, "%Extends", "Config.CommonMultipleMethods") {
            Set paramsGet = "rs.Data(""Name"")"
        }
        Set $NAMESPACE = ns

        Do method.Implementation.WriteLine($CHAR(9,9,9) _ "Do list.%Push(..Get("_paramsGet_"))")
        Do method.Implementation.WriteLine($CHAR(9,9) _ "}")
        Do method.Implementation.WriteLine($CHAR(9,9) _ "Do rs.Close()")
        Do method.Implementation.WriteLine($CHAR(9,9) _ "$$$restoreNS")
        Do method.Implementation.WriteLine($CHAR(9) _"}Catch(ex) {")
        Do method.Implementation.WriteLine($CHAR(9,9) _"$$$restoreNS")
        Do method.Implementation.WriteLine($CHAR(9,9)_"Throw ex")
        Do method.Implementation.WriteLine($CHAR(9) _"}")
        Do method.Implementation.WriteLine($CHAR(9) _"Return list")
       
        Do ..outClass.Methods.Insert(method)
        Set ..temp(methodName)=method
        Do ..log("Initialized.", 0)
    } Else {
        Do ..log("Already exists (skipped).", 0)
    }

    Set ..temp("RESTGEN","getlist") = $$$FormatText("##class(%1).%2", ..outClass.Name, methodName)

    Quit sc
]]></Implementation>
</Method>

<Method name="GetFormalSpecList">
<FormalSpec>*callString:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS", callString = ""

    Set query = ##class(%Dictionary.CompiledQuery).%OpenId(..class.Name _ "||List")
    
    Set tmpList = $LISTFROMSTRING(query.FormalSpec), ptr = 0
    
    While $LISTNEXT(tmpList, ptr, v) {
        Set $Piece(callString, ",", *+1)= $Piece(v, ":")
    }
    Set callString = $Extract(callString, 2, *)
    
    Quit query.FormalSpec
]]></Implementation>
</Method>

<Method name="GetFormalSpec">
<FormalSpec>methodName:%String,*callString:%String,prefix:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS", callString = ""

    #dim cm As %Dictionary.CompiledMethod = ##class(%Dictionary.CompiledMethod).%OpenId(..class.Name _ "||" _ methodName,,.sc)
    Quit:$$$ISERR(sc) sc
    Set formalSpec = $Piece(cm.FormalSpec, ",&Properties")
    Set tmpList = $LISTFROMSTRING(formalSpec), ptr = 0
    
    While $LISTNEXT(tmpList, ptr, v) {
        Set $Piece(callString, ",", *+1)= prefix _ $Piece(v, ":")
    }
    Set callString = $Extract(callString, 2, *)

    Quit formalSpec
]]></Implementation>
</Method>

<Method name="configMethodExists">
<FormalSpec>methodName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Quit ##class(%Dictionary.CompiledMethod).%ExistsId(..class.Name _ "||" _ methodName)
]]></Implementation>
</Method>

<Method name="configQueryExists">
<FormalSpec>queryName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Quit ##class(%Dictionary.CompiledQuery).%ExistsId(..class.Name _ "||" _ queryName)
]]></Implementation>
</Method>

<Method name="log">
<Description>
write message to the current device if verbose is enabled</Description>
<FormalSpec>message:%String,newLine:%Boolean=1,dateTime:%Boolean=1</FormalSpec>
<Implementation><![CDATA[
    Quit:'..verbose()
    Write:newLine !, $zdt($h,3,1), " "
    Write message
    Quit
]]></Implementation>
</Method>

<Method name="isCommonSingle">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Quit $CLASSMETHOD(..class.Name,"%Extends","Config.CommonSingleMethods")
]]></Implementation>
</Method>

<Method name="isCommonMapMethods">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Quit $CLASSMETHOD(..class.Name,"%Extends","Config.CommonMapMethods")
]]></Implementation>
</Method>

<Method name="isCommonMultipleMethods">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Quit $CLASSMETHOD(..class.Name,"%Extends","Config.CommonMultipleMethods")
]]></Implementation>
</Method>

<Method name="getPropertyDescription">
<FormalSpec>property:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"

    Set desc = ""

    #dim cProp As %Dictionary.CompiledProperty = ##class(%Dictionary.CompiledProperty).%OpenId(..class.Name _ "||" _property,,.sc)
    Quit:$$$ISERR(sc) ""
    Set desc = cProp.Description
    ;Set desc = $Replace(desc,"<br>","\n")
    ;Set desc = $Replace(desc,"<br/>","\n")
    
    Quit desc
]]></Implementation>
</Method>

<Method name="verbose">
<CodeMode>expression</CodeMode>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[$Get(..parameters("verbose"),1)
]]></Implementation>
</Method>

<Method name="skipProperty">
<FormalSpec>property:%Dictionary.CompiledProperty</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    Quit:property.Internal $$$YES
    Quit:$Get(parameters("excludePercent"), $$$YES)&&($EXTRACT(property.Name)="%") $$$YES
    Quit:$Get(parameters("excludePrivate"), $$$YES)&&property.Private $$$YES
    Quit $$$NO
]]></Implementation>
</Method>

<Method name="RESTTemplateGET">
<ReturnType>%Stream.GlobalCharacter</ReturnType>
<Implementation><![CDATA[
    Set stream = ##class(%Stream.GlobalCharacter).%New()

    If ..configMethodExists("Exists") {
        Do stream.WriteLine($c(9)_ "If '{{exists}}({{params}}) {")
        Do stream.WriteLine($c(9,9)_ "Do ..%SetStatusCode($$$HTTP404)")
        Do stream.WriteLine($c(9,9)_ "Quit """"")
        Do stream.WriteLine($c(9)_ "}")
        Do stream.WriteLine("")
    }

    Do stream.WriteLine($c(9)_"Set model = {{get}}({{params}})")
    Do stream.WriteLine($c(9)_"Do ..%SetStatusCode($$$HTTP200)")
    Do stream.WriteLine($c(9)_"Do ..%SetContentType(""application/json"")")
    Do stream.WriteLine($c(9)_"Quit model")
    
    Quit stream
]]></Implementation>
</Method>

<Method name="RESTTemplatePUT">
<ReturnType>%Stream.GlobalCharacter</ReturnType>
<Implementation><![CDATA[
    Set stream = ##class(%Stream.GlobalCharacter).%New()
    Do stream.WriteLine($c(9)_ "Set dModel = {}.%FromJSON(.model)")
    Do stream.WriteLine($c(9)_ "Set sc ={{checkmodel}}(dModel)")
    Do stream.WriteLine($c(9)_ "If $$$ISERR(sc) {")
    Do stream.WriteLine($c(9,9)_ "Do ..%SetStatusCode($$$HTTP400)")
    Do stream.WriteLine($c(9,9)_ "Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)")
    Do stream.WriteLine($c(9,9)_ "Quit jsonSC")
    Do stream.WriteLine($c(9)_ "}")
    Do stream.WriteLine($c(9)_ "")
    If ..configMethodExists("Exists") {
        Do stream.WriteLine($c(9)_ "If '{{exists}}({{params}}) {")
        Do stream.WriteLine($c(9,9)_ "Do ..%SetStatusCode($$$HTTP404)")
        Do stream.WriteLine($c(9)_ "}")
    }
    Do stream.WriteLine($c(9)_ "")
    Do stream.WriteLine($c(9)_ "$$$ThrowOnError({{update}}(dModel))")
    Do stream.WriteLine($c(9)_ "Do ..%SetStatusCode($$$HTTP204)")
    Do stream.WriteLine($c(9)_ "Quit """"")   
    Quit stream
]]></Implementation>
</Method>

<Method name="RESTTemplatePOST">
<ReturnType>%Stream.GlobalCharacter</ReturnType>
<Implementation><![CDATA[
    Set stream = ##class(%Stream.GlobalCharacter).%New()
    Do stream.WriteLine($c(9)_ "Set dModel = {}.%FromJSON(.model)")
    Do stream.WriteLine($c(9)_ "Set sc ={{checkmodel}}(dModel)")
    Do stream.WriteLine($c(9)_ "If $$$ISERR(sc) {")
    Do stream.WriteLine($c(9,9)_ "Do ..%SetStatusCode($$$HTTP400)")
    Do stream.WriteLine($c(9,9)_ "Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)")
    Do stream.WriteLine($c(9,9)_ "Quit jsonSC")
    Do stream.WriteLine($c(9)_ "}")
    Do stream.WriteLine($c(9)_ "")
    Do stream.WriteLine($c(9)_ "If {{exists}}({{params}}) {")
    Do stream.WriteLine($c(9,9)_ "Do ..%SetStatusCode($$$HTTP409)")
    Do stream.WriteLine($c(9,9)_ "Quit """"")
    Do stream.WriteLine($c(9)_ "}")
    Do stream.WriteLine($c(9)_ "")
    Do stream.WriteLine($c(9)_ "$$$ThrowOnError({{create}}(dModel))")
    Do stream.WriteLine($c(9)_ "Do ..%SetStatusCode($$$HTTP201)")
    Do stream.WriteLine($c(9)_ "Do ..%SetHeader(""Location"", {{location}})")
    Do stream.WriteLine($c(9)_ "Quit """"")
    Quit stream
]]></Implementation>
</Method>

<Method name="RESTTemplateDELETE">
<ReturnType>%Stream.GlobalCharacter</ReturnType>
<Implementation><![CDATA[
    Set stream = ##class(%Stream.GlobalCharacter).%New()
    Do stream.WriteLine($c(9)_ "If '{{exists}}({{params}}) {")
    Do stream.WriteLine($c(9,9)_ "Do ..%SetStatusCode($$$HTTP404)")
    Do stream.WriteLine($c(9,9)_ "Quit """"")
    Do stream.WriteLine($c(9)_ "}")
    Do stream.WriteLine($c(9)_ "")
    Do stream.WriteLine($c(9)_ "$$$ThrowOnError({{delete}}({{params}}))")
    Do stream.WriteLine($c(9)_ "Do ..%SetStatusCode($$$HTTP204)")
    Do stream.WriteLine($c(9)_ "Quit """"")
    Quit stream
]]></Implementation>
</Method>

<Method name="RESTTemplateGETList">
<ReturnType>%Stream.GlobalCharacter</ReturnType>
<Implementation><![CDATA[
    Set stream = ##class(%Stream.GlobalCharacter).%New()
    Do stream.WriteLine($c(9)_ "Set lst = {{getlist}}({{getlistparams}})")
    Do stream.WriteLine($c(9)_ "Do ..%SetStatusCode($$$HTTP200)")
    Do stream.WriteLine($c(9)_ "Do ..%SetContentType(""application/json"")")
    Do stream.WriteLine($c(9)_ "Quit {""{{listof}}"":(lst)}")
    Quit stream
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Developers.Helper">
<Description>
dev helper
zw ##class(Api.Config.Developers.Helper).GenCommonMethod("","")
zw ##class(Api.Config.Developers.Helper).GenObjectToArray("","")
zw ##class(Api.Config.Developers.Helper).GenToDynamic("","")
do ##class(Api.Config.Developers.Helper).ShowSwaggerDef("")</Description>
<System>2</System>
<TimeChanged>66011,29866.863563</TimeChanged>
<TimeCreated>66011,29866.863563</TimeCreated>

<Method name="GenCommonMethod">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,outClassName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Do ..GenToDynamic(className, outClassName)
    Do ..GenToArray(className, outClassName)
    Do ..GenObjectToArray(className, outClassName)
    Do ..ShowSwaggerDef(className)
    Return sc
]]></Implementation>
</Method>

<Method name="GenToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,outClassName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
        #define GETTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"number",:"string")
    #define GETSWAGGERTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"integer",:"string")

    Write !," * Generate method ToArray to "_outClassName _ " "
    Set sc = $$$OK, key=""
    
    ;Set outClass = ##class(%Dictionary.ClassDefinition).%OpenId(outClassName)
    Set methodName = "ToArray"
    
    Set method = ##class(%Dictionary.MethodDefinition).%OpenId(outClassName_"||"_methodName,,.sc)
    Set:'$ISOBJECT(method) method = ##class(%Dictionary.MethodDefinition).%New()
    Set method = ##class(%Dictionary.MethodDefinition).%New()
    Set method.Name = methodName
    Set method.ClassMethod = $$$YES
    Set method.FormalSpec = "model:%Library.DynamicObject,*properties:%Binary"
    Set method.ReturnType = ""
    Do method.parentSetObjectId(outClassName)

    New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS"
    
    
    #dim class As %Dictionary.CompiledClass = ##class(%Dictionary.CompiledClass).%OpenId(className)

    For  {
        Set property = class.Properties.GetNext(.key)
        Quit:key="" 
        Continue:..skipProperty(property)
        ; Set jsonType = $$$GETTYPE($Replace(property.Type, "Library.",""))
        ; Set swaggerType = $$$GETSWAGGERTYPE($Replace(property.Type, "Library.",""))
        Set line = $CHAR(9) _ $$$FormatText("Set:$$$CanSetProperty(model,""%1"") properties(""%1"") = model.%1", property.Name)
        Do method.Implementation.WriteLine(line)
    }
    Do method.Implementation.WriteLine($CHAR(9) _ "Quit")

    Set $NAMESPACE = ns
    Set sc = method.%Save()
    Write $SYSTEM.Status.GetOneErrorText(sc)
    Return sc
]]></Implementation>
</Method>

<Method name="GenToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,outClassName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #define GETTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"number",:"string")
    #define GETSWAGGERTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"integer",:"string")

    Write !," * Generate method ToDynamic to "_outClassName _ " "
    Set sc = $$$OK, key=""
    
    ;Set outClass = ##class(%Dictionary.ClassDefinition).%OpenId(outClassName)
    Set methodName = "ToDynamic"
    
    Set method = ##class(%Dictionary.MethodDefinition).%OpenId(outClassName_"||"_methodName,,.sc)
    Set:'$ISOBJECT(method) method = ##class(%Dictionary.MethodDefinition).%New()
    Set method.Name = "ToDynamic"
    Set method.ClassMethod = $$$YES
    Set method.FormalSpec = "&properties:%Binary" ; "pObj:"_className
    Set method.ReturnType = "%Library.DynamicObject"
    Do method.Implementation.WriteLine($CHAR(9) _ "Set model = {}")
    Do method.parentSetObjectId(outClassName)

    New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS"
    
    
    #dim class As %Dictionary.CompiledClass = ##class(%Dictionary.CompiledClass).%OpenId(className)

    For  {
        Set property = class.Properties.GetNext(.key)
        Quit:key="" 
        Continue:..skipProperty(property)
        Set jsonType = $$$GETTYPE($Replace(property.Type, "Library.",""))
        ; Set swaggerType = $$$GETSWAGGERTYPE($Replace(property.Type, "Library.",""))
        Do method.Implementation.WriteLine($CHAR(9) _ $$$FormatText("Do:$Data(properties(""%1"")) model.%Set(""%1"", properties(""%1""), ""%2"")", property.Name, jsonType))
    }
    Do method.Implementation.WriteLine($CHAR(9) _ "Quit model")

    Set $NAMESPACE = ns
    Set sc = method.%Save()
    Write $SYSTEM.Status.GetOneErrorText(sc)
    Return sc
]]></Implementation>
</Method>

<Method name="GenObjectToArray">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,outClassName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    ; zw ##class(PackageName.ClassName).GenObjectToArray("","")
    Write !," * Generate method ObjectToArray to "_outClassName _ " "
    Set sc = $$$OK, key=""
    
    Set methodName = "ObjectToArray"
    
    Set method = ##class(%Dictionary.MethodDefinition).%OpenId(outClassName_"||"_methodName)
    Set:'$ISOBJECT(method) method = ##class(%Dictionary.MethodDefinition).%New()
    Set method.Name = methodName
    Set method.ClassMethod = $$$YES
    Set method.ReturnType = ""
    Set method.FormalSpec = "&pObj,*properties:%Binary"
    
    Do method.parentSetObjectId(outClassName)

    New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS"
    
    
    #dim class As %Dictionary.CompiledClass = ##class(%Dictionary.CompiledClass).%OpenId(className)

    For  {
        Set property = class.Properties.GetNext(.key)
        Quit:key="" 
        Continue:..skipProperty(property)
        Do method.Implementation.WriteLine($CHAR(9)_$$$FormatText("Set properties(""%1"") = pObj.%1",property.Name))
    }

    Set $NAMESPACE = ns
    Set sc = method.%Save()
    Write $SYSTEM.Status.GetOneErrorText(sc)
    Return sc
]]></Implementation>
</Method>

<Method name="ShowSwaggerDef">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    #define GETTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"number",:"string")
    #define GETSWAGGERTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"integer",:"string")

    Set swaggerDef = {
        "type" : "object",
        "properties" : {},
        "required" : []
    }
    Set template = {}, key=""
    Set swaggerDef.example = template
    New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS"
    
    Set obj = $CLASSMETHOD(className, "%New")
    
    #dim class As %Dictionary.CompiledClass = ##class(%Dictionary.CompiledClass).%OpenId(className)

    For  {
        Set property = class.Properties.GetNext(.key)
        Quit:key="" 
        Continue:..skipProperty(property)
        Set jsonType = $$$GETTYPE($Replace(property.Type, "Library.",""))
        Set swaggerType = $$$GETSWAGGERTYPE($Replace(property.Type, "Library.",""))
    
        Set dflt = $PROPERTY(obj,property.Name)
        Set:$ISOBJECT(dflt) dflt=""
        If dflt=""&&property.Required {
            Do swaggerDef.required.%Push(property.Name)
            Do template.%Set(property.Name, dflt, jsonType)
        }

        Set description = ..getPropertyDescription(property.Name, className)

        Do swaggerDef.properties.%Set(property.Name, {
            "type" : (swaggerType),
            "default" : (dflt),
            "description" : (description)
        })
    
    }
    
    Set $NAMESPACE = ns
    
    Set defObj = {}
    Set pName = $tr(className,"%.")
    Do defObj.%Set(pName,swaggerDef)

    Set isSingle = ''$PARAMETER("Api.Config.Services."_$tr(className,"%"),"ISSINGLE")
    If 'isSingle {
        Do defObj.%Set("ListOf"_pName,{
            "type":"object",
            "properties":{
                "list" : {
                    "type":"array",
                    "items": {
                        "$ref": ("#/definitions/" _ pName)
                    }
                }
            }
        })
    }
    
    Do ##class(Api.Config.Developers.Utils).FormatJSON(defObj,.formatted)

    w !,formatted
    Quit swaggerDef
]]></Implementation>
</Method>

<Method name="getPropertyDescription">
<ClassMethod>1</ClassMethod>
<FormalSpec>property:%String,class:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"

    #dim cProp As %Dictionary.CompiledProperty = ##class(%Dictionary.CompiledProperty).%OpenId(class _ "||" _property,,.sc)
    Quit:$$$ISERR(sc) ""
    Quit cProp.Description
]]></Implementation>
</Method>

<Method name="skipProperty">
<ClassMethod>1</ClassMethod>
<FormalSpec>property:%Dictionary.CompiledProperty</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    Quit:property.Internal $$$YES
    Quit:$Get(parameters("excludePercent"), $$$YES)&&($EXTRACT(property.Name)="%") $$$YES
    Quit:$Get(parameters("excludePrivate"), $$$YES)&&property.Private $$$YES
    Quit $$$NO
]]></Implementation>
</Method>

<Method name="MDListServices">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    ; d ##class(Api.Config.Developers.Helper).MDListServices()
    #define METHODEXISTS(%name)    $s(##class(%Dictionary.MethodDefinition).%ExistsId(key_"||"_%name):"yes",1:"no")
    Write !,"| Service classes 	| List 	| Get 	| Update    | Create    | Delete    | Exists    |"
    Write !,"|-	|-	|-	|-	|-	|-	|-	|"

    Set list = 1, get = 1, update = 1, create = 1, delete=1, exists=1 
    Set key = "Api.Config.Services"
    For  {
        Set key = $Order(^oddDEF(key))
        Quit:key=""||(key'["Api.Config.Services.")
        CONTINUE:key="Api.Config.Services.Loader"

        Set list = $$$METHODEXISTS("List"), 
                    get = $$$METHODEXISTS("Get"), 
                    update = $$$METHODEXISTS("Update"), 
                    create = $$$METHODEXISTS("Create"), 
                    delete = $$$METHODEXISTS("Delete"), 
                    exists = $$$METHODEXISTS("Exists")
        Write !, $$$FormatText("| %1 | %2 | %3 | %4 | %5 | %6 | %7 |",key,list,get,update,create,delete,exists)
    }
]]></Implementation>
</Method>

<Method name="MDListRequest">
<ClassMethod>1</ClassMethod>
<FormalSpec>swagger:%DynamicObject</FormalSpec>
<Implementation><![CDATA[
    s swagger = {}.%FromJSON(##class(%Dictionary.CompiledXData).%OpenId("Api.Config.REST.spec||OpenAPI").Data)
    ; d ##class(Api.Config.Developers.Helper).MDListRequest()
    Write !,"| Method 	| Request 	| Summary  |"
    Write !,"|-	|-	|- |"
    Set iter = swagger.paths.%GetIterator()
    While iter.%GetNext(.key,.value) {
        For method = "get", "post", "put", "delete" {
            CONTINUE:'value.%IsDefined(method)
            Write !, $$$FormatText("| %1 | %2 | %3 |", method, key, $PROPERTY($PROPERTY(value,method),"summary"))
        }
        
    }
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Developers.Install">
<Description>
Description</Description>
<TimeChanged>66011,29866.869194</TimeChanged>
<TimeCreated>66011,29866.869194</TimeCreated>

<Method name="installRESTApp">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set cfg = {
        "Security.Applications" : {
            "/api/config": {
                "NameSpace" : ($NAMESPACE),
                "Enabled" : 1,
                "DispatchClass" : "Api.Config.REST.disp",
                "CSPZENEnabled" : 1,
                "AutheEnabled": 32
            }
        }
    }

    Set sc = ##class(Api.Config.Services.Loader).Load(cfg)

    Quit sc
]]></Implementation>
</Method>

<Method name="SetSwaggerUIDefaultPath">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>specUrl:%String="/api/config/",toReplace:%String="""http://localhost:52773/crud/_spec"""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Quit:'##class(Api.Config.Services.Security.Applications).Exists("/swagger-ui") $$$ERROR(5001, "/swagger-ui web app does not exists")
    
    Set app = ##class(Api.Config.Services.Security.Applications).Get("/swagger-ui")
    Set dir = ##class(%File).NormalizeDirectory(app.Path)
    
    Set newValue = "(window.location.protocol+'//'+window.location.host+'"_specUrl_"')"
    Set file = ##class(%Stream.FileCharacter).%New()
    Do file.LinkToFile(dir_"index.html")
    Set buff = file.Read()
    Set buff = $REPLACE(buff, toReplace, newValue)
    Do file.Clear()
    Do file.Rewind()
    Do file.Write(buff)
    Quit file.%Save()
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Developers.Samples">
<Description>
code samples
Description</Description>
<TimeChanged>66011,29866.925501</TimeChanged>
<TimeCreated>66011,29866.925501</TimeCreated>

<Method name="firstStep">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    /// zw ##class(Api.Config.Developers.Samples).firstStep()
    Set config = {
        "Security.Roles":{
            "MyAppRoleRO" : {
                "Descripion" : "MyApp SQL Read Only Role",
                "Resources" : "%Service_SQL:U",
                "GrantedRoles" : "%SQL"
            },
            "MyAppRoleRW" : {
                "Descripion" : "MyApp SQL Read\\Write Role",
                "Resources" : "%Service_SQL:U",
                "GrantedRoles" : "%SQL"
            }
        },
        "Security.SQLPrivileges": [{
            "Grantable" : 0,
            "Grantee": "MyAppRoleRO",
            "Grantor" : "_SYSTEM",
            "Namespace" : "${namespace}",
            "PrivList" : "s",
            "SQLObject" : "1,Api_*"
        },{
            "Grantable" : 0,
            "Grantee": "MyAppRoleRW",
            "Grantor" : "_SYSTEM",
            "Namespace" : "${namespace}",
            "PrivList" : "siud",
            "SQLObject" : "1,Api_*"
        }],
        "Security.Users": {
            "SQLUserRW": {
                "Description":"SQLUser1",
                "Password" : "$$test$$",
                "ChangePassword" : 1,
                "AccountNeverExpires": 1,
                "Roles":"MyAppRoleRW",
                "Namespace" : "${namespace}"
            },
            "SQLUserRO": {
                "Description":"SQLUserRO",
                "Password" : "$$test$$",
                "ChangePassword" : 0,
                "AccountNeverExpires": 1,
                "Roles":"MyAppRoleRO",
                "Namespace" : "${namespace}"
            }
        },
        "Security.SSLConfigs": {
            "SSLDefault":{}
        },
        "Library.SQLConnection": {
            "SQLConnection1" : {},
            "SQLConnection2" : {}
        },
        "Security.SQLAdminPrivilegeSet" : {
            "${namespace}": [{
                "CreateTable" : 1,
                "Grantee" : "SQLUserRW"
            }]
        },
        "azeruipo" : {
            
        }
    }
    Set sc = ##class(Api.Config.Services.Loader).Load(config)
    Quit sc
]]></Implementation>
</Method>

<Method name="firstAppEnvironment">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    /// zw ##class(Api.Config.Developers.Samples).firstAppEnvironment()
    Set config = {
        "Defaults":{
            "DBDIR" : "${MGRDIR}",
            "WEBAPPDIR" : "${CSPDIR}",
            "DBDATA" : "${DBDIR}myappdata/",
            "DBARCHIVE" : "${DBDIR}myapparchive/",
            "DBCODE" : "${DBDIR}myappcode/",
            "DBLOG" : "${DBDIR}myapplog/"
        },
        "SYS.Databases":{
            "${DBDATA}" : {"ExpansionSize":128},
            "${DBARCHIVE}" : {},
            "${DBCODE}" : {},
            "${DBLOG}" : {}
        },
        "Databases":{
            "MYAPPDATA" : {
                "Directory" : "${DBDATA}"
            },
            "MYAPPCODE" : {
                "Directory" : "${DBCODE}"
            },
            "MYAPPARCHIVE" : {
                "Directory" : "${DBARCHIVE}"
            },
            "MYAPPLOG" : {
                "Directory" : "${DBLOG}"
            }
        },
        "Namespaces":{
            "MYAPP": {
                "Globals":"MYAPPDATA",
                "Routines":"MYAPPCODE"
            }
        },
        "Security.Applications": {
            "/csp/zrestapp": {
                "DispatchClas" : "my.dispatch.class",
                "Namespace" : "MYAPP",
                "Enabled" : "1",
                "AuthEnabled": "64",
                "CookiePath" : "/csp/zrestapp/"
            },
            "/csp/zwebapp": {
                "Path": "${WEBAPPDIR}zwebapp/",
                "Namespace" : "MYAPP",
                "Enabled" : "1",
                "AuthEnabled": "64",
                "CookiePath" : "/csp/zwebapp/"
            }
        },
        "MapGlobals":{
            "MYAPP": [{
                "Name" : "Archive.Data",
                "Database" : "MYAPPARCHIVE"
            },{
                "Name" : "App.Log",
                "Database" : "MYAPPLOG"
            }]
        }
    }
    Set sc = ##class(Api.Config.Services.Loader).Load(config)
    Quit sc
]]></Implementation>
</Method>

<Method name="advanced">
<Description>
zw ##class(Api.Config.Developers.Samples).advanced()</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set config = {
        "Defaults":{
            "DBDIR" : "${MGRDIR}",
            "WEBAPPDIR" : "${CSPDIR}",
            "DBDATA" : "${DBDIR}myappdata/",
            "DBARCHIVE" : "${DBDIR}myapparchive/",
            "DBCODE" : "${DBDIR}myappcode/",
            "DBLOG" : "${DBDIR}myapplog/"
        },
        "SYS.Databases":{
            "${DBDATA}" : {"ExpansionSize":128},
            "${DBARCHIVE}" : {},
            "${DBCODE}" : {},
            "${DBLOG}" : {}
        },
        "Databases":{
            "MYAPPDATA" : {
                "Directory" : "${DBDATA}"
            },
            "MYAPPCODE" : {
                "Directory" : "${DBCODE}"
            },
            "MYAPPARCHIVE" : {
                "Directory" : "${DBARCHIVE}"
            },
            "MYAPPLOG" : {
                "Directory" : "${DBLOG}"
            }
        },
        "Namespaces":{
            "MYAPP": {
                "Globals":"MYAPPDATA",
                "Routines":"MYAPPCODE"
            }
        },
        "Security.Applications": {
            "/csp/zrestapp": {
                "DispatchClas" : "my.dispatch.class",
                "Namespace" : "MYAPP",
                "Enabled" : "1",
                "AuthEnabled": "64",
                "CookiePath" : "/csp/zrestapp/"
            },
            "/csp/zwebapp": {
                "Path": "${WEBAPPDIR}zwebapp/",
                "Namespace" : "MYAPP",
                "Enabled" : "1",
                "AuthEnabled": "64",
                "CookiePath" : "/csp/zwebapp/"
            }
        },
        "MapGlobals":{
            "MYAPP": [{
                "Name" : "Archive.Data",
                "Database" : "MYAPPARCHIVE"
            },{
                "Name" : "App.Log",
                "Database" : "MYAPPLOG"
            }]
        },
        "MapPackages": {
            "MYAPP": [{
                "Namespace" : "MYAPP",
                "Name" : "PackageName",
                "Database" : "USER"
            }]
        },
        "MapRoutines": {
            "MYAPP": [{
                "Namespace" : "MYAPP",
                "Name" : "RoutineName",
                "Database" : "USER"
            }]
        },
        "Journal": {
            "FreezeOnError":1
        },
        "Security.Services":{   
            "%Service_Mirror": {
                "Enabled" : 0
            }
        },
        "SQL": {
            "LockThreshold" : 2500
        },
        "config": {
            "locksiz" : 33554432
        },
        "Startup":{
            "SystemMode" : "DEVELOPMENT"
        }
    }
    Set sc = ##class(Api.Config.Services.Loader).Load(config)
    Quit sc
]]></Implementation>
</Method>

<Method name="TestExport">
<Description>
zw ##class(Api.Config.Developers.Samples).TestExport()
d ##class(Api.Config.Developers.Utils).Show(##class(Api.Config.Developers.Samples).TestExport())</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set filter = {
        "Namespaces": {   
            "${namespace}":""    /* Namespace to export */
        },
        "MapGlobals":{
            "${namespace}":""    /* Export all globals mapping for namespace MYAPP */
        },
        "MapPackages":{ 
            "${namespace}":""    /* Export all packages mapping for namespace MYAPP */
        },
        "MapRoutines":{
            "${namespace}":""    /* Export all routines mapping for namespace MYAPP */
        },
        "Security.Applications":{
            "/csp/zrestapp":"",   /* Export Web applications parameters /csp/zrestapp */
            "/csp/zwebapp":""     /* Export Web applications parameters /csp/zwebapp */
        },
        "Journal":"",  /* Export all journal setting.  *There is a trick to export only non default parameters(see below) */
        "config":"",   /* Export config parameters */
        "Library.SQLConnection":"",
        "Security.Users":"",
        "Security.SQLAdminPrivilegeSet":{
            "${namespace}":""
        },
        "Security.SQLPrivileges":""
    }
    Set OnlyNotDefaultValue = 1
    Set config = ##class(Api.Config.Services.Loader).export(filter,OnlyNotDefaultValue)
    Quit config
]]></Implementation>
</Method>

<Method name="TestExport2">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Set filter = {
        "Namespaces": {   
            "%SYS":""    /* Namespace to export */
        },
        "Journal":"",  /* Export all journal setting.  *There is a trick to export only non default parameters(see below) */
        "config":""   /* Export config parameters */
    }

    Set OnlyNotDefaultValue = 0
    Set config = ##class(Api.Config.Services.Loader).export(filter,OnlyNotDefaultValue)
    Do ##class(Api.Config.Developers.Utils).Show(config)
]]></Implementation>
</Method>

<Method name="TestZPM">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Set config = {
        "ZPM": {
            "${namespace}": [
                {
                    "install":"sslclient"
                }
            ]
        }
    }

    Set sc = ##class(Api.Config.Services.Loader).Load(config)
    W "sc ",$SYSTEM.Status.GetOneErrorText(sc)
    Quit
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Developers.UnitTestsClassGen">
<Description>
Dev helper to generate template UnitTests classes for services.</Description>
<TimeChanged>66011,29866.895887</TimeChanged>
<TimeCreated>66011,29866.895887</TimeCreated>

<Parameter name="PACKAGE">
<Default>UnitTests.Api.Config.Services.</Default>
</Parameter>

<Method name="Gen">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,*unitTestClass:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    ; zw ##class(Api.Config.Developers.UnitTestsClassGen).Gen("Api.Config.Services.Namespaces",.o)
    #define METHODEXISTS(%method)       ##class(%Dictionary.CompiledMethod).%ExistsId(className_"||"_%method)
    
    Set unitTestClass = ..#PACKAGE _ $PIECE(className,"Config.Services.",2)

    #dim class As %Dictionary.ClassDefinition = ##class(%Dictionary.ClassDefinition).%New()
    Set class.Name = unitTestClass
    Set class.ProcedureBlock = $$$YES
    Set class.Super = "%UnitTest.TestCase"

    If $$$METHODEXISTS("Get") {
        Do class.Methods.Insert(..GetMethod(className))
    }

    If $$$METHODEXISTS("Update") {
        Do class.Methods.Insert(..UpdateMethod(className))
    }

    If $$$METHODEXISTS("Create") {
        Do class.Methods.Insert(..CreateMethod(className))
    }

    If $$$METHODEXISTS("List") {
        Do class.Methods.Insert(..ListMethod(className))
    }



    Quit class.%Save()
]]></Implementation>
</Method>

<Method name="ListMethod">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Dictionary.MethodDefinition</ReturnType>
<Implementation><![CDATA[
    #dim method As %Dictionary.MethodDefinition = ##class(%Dictionary.MethodDefinition).%New()
    Set method.Name = "TestList"
    Set method.ReturnType = "%Status"

    Do method.Implementation.WriteLine($CHAR(9)_"Set sc = $$$OK")

    Set listLine = "Set list = ##class(%1).List(%2)"

    If $PARAMETER(className,"ISMAP") {
        Set arg = $PIECE($PARAMETER(className,"PIDENTIFIER"),",",1)
        Do method.Implementation.WriteLine($CHAR(9) _ "Set "_ arg _" = """"" )
        Set listLine = $$$FormatText(listLine, className, arg)

    } Else {
        Set listLine = $$$FormatText(listLine, className, "")
    }

    Do method.Implementation.WriteLine($CHAR(9)_ listLine)
    
    
    
    Do method.Implementation.WriteLine($CHAR(9)_"Quit sc")

    Quit method
]]></Implementation>
</Method>

<Method name="CreateMethod">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Dictionary.MethodDefinition</ReturnType>
<Implementation><![CDATA[
    #dim method As %Dictionary.MethodDefinition = ##class(%Dictionary.MethodDefinition).%New()
    Set method.Name = "TestCreateAndDelete"
    Set method.ReturnType = "%Status"

    Do method.Implementation.WriteLine($CHAR(9)_"Set sc = $$$OK")

    Do method.Implementation.WriteLine($CHAR(9)_"Set model = {}")

    Do method.Implementation.WriteLine($CHAR(9)_ $Replace("Set sc = ##class(%1).Create(model)", "%1",className))

    Do method.Implementation.WriteLine($CHAR(9)_ "Do $$$AssertStatusOK(sc,""Create status"")")

    Set delLine = $Replace("Set sc = ##class(%1).Delete(%2)","%1",className)

    If $PARAMETER(className,"ISMAP") {
        Set args = $PARAMETER(className,"PIDENTIFIER")
        For i=1:1:$LENGTH(args,",") {
            Do method.Implementation.WriteLine($CHAR(9) _ "Set "_$Piece(args,",",i) _" = """"" )
        }
        Set delLine = $$$FormatText(delLine, className, args)

    } Else {
        Set pName = $PARAMETER(className,"PNAME")
        Set:pName="" pName="Name"
        Do method.Implementation.WriteLine($CHAR(9) _ "Set "_pName _" = """"" )
        Set delLine = $$$FormatText(delLine, className, pName)
    }

    Do method.Implementation.WriteLine($CHAR(9)_ delLine)
    Do method.Implementation.WriteLine($CHAR(9)_ "Do $$$AssertStatusOK(sc,""Delete created ressource"")")
    
    
    Do method.Implementation.WriteLine($CHAR(9)_"Quit sc")

    Quit method
]]></Implementation>
</Method>

<Method name="UpdateMethod">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Dictionary.MethodDefinition</ReturnType>
<Implementation><![CDATA[
    #dim method As %Dictionary.MethodDefinition = ##class(%Dictionary.MethodDefinition).%New()
    Set method.Name = "TestUpdate"
    Set method.ReturnType = "%Status"

    Do method.Implementation.WriteLine($CHAR(9)_"Set sc = $$$OK")

    Do method.Implementation.WriteLine($CHAR(9)_"Set model = {}")

    Do method.Implementation.WriteLine($CHAR(9)_ $Replace("Set sc = ##class(%1).Update(model)", "%1",className))

    Do method.Implementation.WriteLine($CHAR(9)_ "Do $$$AssertStatusOK(sc)")

    Do method.Implementation.WriteLine($CHAR(9)_"Quit sc")

    Quit method
]]></Implementation>
</Method>

<Method name="GetMethod">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Dictionary.MethodDefinition</ReturnType>
<Implementation><![CDATA[
    #dim method As %Dictionary.MethodDefinition = ##class(%Dictionary.MethodDefinition).%New()
    Set method.Name = "TestGet"
    Set method.ReturnType = "%Status"

    Do method.Implementation.WriteLine($CHAR(9)_"Set sc = $$$OK")

    Set getLine = $CHAR(9) _ "Set model = ##class(%1).Get(%2)"

    If $PARAMETER(className,"ISSINGLE") {
        Set getLine = $$$FormatText(getLine, className, "")

    } ElseIf $PARAMETER(className,"ISMAP") {

        Set args = $PARAMETER(className,"PIDENTIFIER")
        For i=1:1:$LENGTH(args,",") {
            Do method.Implementation.WriteLine($CHAR(9) _ "Set "_$Piece(args,",",i) _" = """"" )
        }
        Set getLine = $$$FormatText(getLine, className, args)

    } Else {

        Set pName = $PARAMETER(className,"PNAME")
        Set:pName="" pName="Name"
        Do method.Implementation.WriteLine($CHAR(9) _ "Set "_pName _" = """"" )

        Set getLine = $$$FormatText(getLine, className, pName)
        
    }

    
    
    Do method.Implementation.WriteLine(getLine)
    For i=1:1:3 {
        Do method.Implementation.WriteLine($CHAR(9) _ "Set expected = """"")
        Do method.Implementation.WriteLine($CHAR(9) _ "Do $$$AssertTrue(model.%IsDefined(expected),$replace(""Check if property %1 is defined"",""%1"",expected))")
    }
    Do method.Implementation.WriteLine($CHAR(9)_"Quit sc")

    Quit method
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Developers.Utils">
<Description>
Description</Description>
<System>2</System>
<TimeChanged>66011,29866.889698</TimeChanged>
<TimeCreated>66011,29866.889698</TimeCreated>

<Method name="Show">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%DynamicObject</FormalSpec>
<Implementation><![CDATA[
    Set str = ""
    Do ..FormatJSON(model,.str)
    Write !,str
]]></Implementation>
</Method>

<Method name="FormatJSON">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%DynamicObject,*formatted</FormalSpec>
<Implementation><![CDATA[
    If '##class(%Dictionary.CompiledClass).%ExistsId("%JSON.Formatter") { ; hs 2018 compatibility ...
	Set formatted = model.%ToJSON()
	Quit
    }
    Set formatter=##class(%JSON.Formatter).%New()
    Set formatted = ""
    Do formatter.FormatToString(model, .formatted)
    Quit
]]></Implementation>
</Method>

<Method name="buildXmlRelease">
<Description>
zw ##class(Api.Config.Developers.Utils).buildXmlRelease()</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String="/irisrun/repo/dist/config-api_with_dependencies.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    Do:##class(%File).Exists(filename) ##class(%File).Delete(filename)
    Set items = ""
    Set items("Api.Config.inc.INC")=""
    Set items("IORedirect.INC")=""
    Set items("Api.Config.*.CLS")=""
    Set items("IORedirect.*.CLS")=""
    Quit $SYSTEM.OBJ.Export(.items,filename)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.REST.impl">
<Description><![CDATA[
Config API.<br/>
Business logic class defined by OpenAPI in Api.Config.REST.spec<br/>
Updated Sep 24, 2021 08:17:47]]></Description>
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%REST.Impl</Super>
<TimeChanged>66011,29868.015282</TimeChanged>
<TimeCreated>66011,29866.971774</TimeCreated>

<Parameter name="ExposeServerExceptions">
<Description>
If ExposeServerExceptions is true, then details of internal errors will be exposed.</Description>
<Default>1</Default>
</Parameter>

<Method name="GetSpecification">
<Description>
Swagger 2.0 specification</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Do ..%SetStatusCode($$$HTTP200)
    Do ..%SetContentType("application/json")
    #dim XData As %Dictionary.CompiledXData = ##class(%Dictionary.CompiledXData).%OpenId("Api.Config.REST.spec||OpenAPI")
    Set swagger = {}.%FromJSON(XData.Data)
    Set swagger.host = %request.CgiEnvs("SERVER_NAME") _ ":" _ %request.CgiEnvs("SERVER_PORT")
    Set swagger.basePath = %request.Application
    Quit swagger
]]></Implementation>
</Method>

<Method name="GetCluster">
<Description>
Get Cluster.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("Cluster")
]]></Implementation>
</Method>

<Method name="PutCluster">
<Description><![CDATA[
Update Cluster.<br/>
The method arguments hold values for:<br/>
    model, Cluster to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model), resp = ..DefaultPutImpl("Cluster", dModel,,$$$NO)
	Quit resp
]]></Implementation>
</Method>

<Method name="GetConfigFile">
<Description>
Get ConfigFile.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = ##class(Api.Config.Services.ConfigFile).Get()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutConfigFile">
<Description><![CDATA[
Update ConfigFile.<br/>
The method arguments hold values for:<br/>
    model, ConfigFile to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.ConfigFile).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	
	$$$ThrowOnError(##class(Api.Config.Services.ConfigFile).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetDatabases">
<Description><![CDATA[
Get Databases.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("Databases", name)
]]></Implementation>
</Method>

<Method name="PutDatabases">
<Description><![CDATA[
Update Databases.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>
    model, Databases to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.Databases).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.Databases).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Databases).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostDatabases">
<Description><![CDATA[
Create Databases.<br/>
The method arguments hold values for:<br/>
    model, Databases to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set resp = ..DefaultPostImpl("Databases", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"databases/"_dModel.Name)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteDatabases">
<Description><![CDATA[
Delete Databases.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultDelImpl("Databases", name)
]]></Implementation>
</Method>

<Method name="GetListDatabases">
<Description>
Get List Of Databases.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultListOf("Databases","ListOfDatabases")
]]></Implementation>
</Method>

<Method name="GetDebug">
<Description><![CDATA[
Get Debug.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.Debug).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Set model = ##class(Api.Config.Services.Debug).Get(name)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutDebug">
<Description><![CDATA[
Update Debug.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>
    model, Debug to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.Debug).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.Debug).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Debug).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostDebug">
<Description><![CDATA[
Create Debug.<br/>
The method arguments hold values for:<br/>
    model, Debug to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set resp = ..DefaultPostImpl("Debug", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"debug/"_dModel.Name)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteDebug">
<Description><![CDATA[
Delete Debug.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultDelImpl("Debug", name)
]]></Implementation>
</Method>

<Method name="GetListDebug">
<Description>
Get List Of Debug.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultListOf("Debug","ListOfDebug")
]]></Implementation>
</Method>

<Method name="GetDeviceSubTypes">
<Description><![CDATA[
Get DeviceSubTypes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("DeviceSubTypes", name)
]]></Implementation>
</Method>

<Method name="PutDeviceSubTypes">
<Description><![CDATA[
Update DeviceSubTypes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>
    model, DeviceSubTypes to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.DeviceSubTypes).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.DeviceSubTypes).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.DeviceSubTypes).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostDeviceSubTypes">
<Description><![CDATA[
Create DeviceSubTypes.<br/>
The method arguments hold values for:<br/>
    model, DeviceSubTypes to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set resp = ..DefaultPostImpl("DeviceSubTypes", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"devicesubtypes/"_dModel.Name)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteDeviceSubTypes">
<Description><![CDATA[
Delete DeviceSubTypes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultDelImpl("DeviceSubTypes", name)
]]></Implementation>
</Method>

<Method name="GetListDeviceSubTypes">
<Description>
Get List Of DeviceSubTypes.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultListOf("DeviceSubTypes","ListOfDeviceSubTypes")
]]></Implementation>
</Method>

<Method name="GetDevices">
<Description><![CDATA[
Get Devices.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("Devices", name)
]]></Implementation>
</Method>

<Method name="PutDevices">
<Description><![CDATA[
Update Devices.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>
    model, Devices to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.Devices).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.Devices).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Devices).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetECP">
<Description>
Get ECP.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("ECP")
]]></Implementation>
</Method>

<Method name="PostDevices">
<Description><![CDATA[
Create Devices.<br/>
The method arguments hold values for:<br/>
    model, Devices to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set resp = ..DefaultPostImpl("Devices", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"devices/"_dModel.Name)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteDevices">
<Description><![CDATA[
Delete Devices.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultDelImpl("Devices", name)
]]></Implementation>
</Method>

<Method name="PutECP">
<Description><![CDATA[
Update ECP.<br/>
The method arguments hold values for:<br/>
    model, ECP to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.ECP).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	
	$$$ThrowOnError(##class(Api.Config.Services.ECP).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListDevices">
<Description>
Get List Of Devices.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultListOf("Devices","ListOfDevices")
]]></Implementation>
</Method>

<Method name="GetECPServers">
<Description><![CDATA[
Get ECPServers.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("ECPServers", name)
]]></Implementation>
</Method>

<Method name="PutECPServers">
<Description><![CDATA[
Update ECPServers.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>
    model, ECPServers to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.ECPServers).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.ECPServers).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.ECPServers).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetIO">
<Description>
Get IO.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("IO")
]]></Implementation>
</Method>

<Method name="PostECPServers">
<Description><![CDATA[
Create ECPServers.<br/>
The method arguments hold values for:<br/>
    model, ECPServers to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set resp = ..DefaultPostImpl("ECPServers", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"ecpservers/"_dModel.Name)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteECPServers">
<Description><![CDATA[
Delete ECPServers.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultDelImpl("ECPServers", name)
]]></Implementation>
</Method>

<Method name="PutIO">
<Description><![CDATA[
Update IO.<br/>
The method arguments hold values for:<br/>
    model, IO to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.IO).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	
	$$$ThrowOnError(##class(Api.Config.Services.IO).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetJournal">
<Description>
Get Journal.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("Journal")
]]></Implementation>
</Method>

<Method name="GetListECPServers">
<Description>
Get List Of ECPServers.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultListOf("ECPServers","ListOfECPServers")
]]></Implementation>
</Method>

<Method name="PutJournal">
<Description><![CDATA[
Update Journal.<br/>
The method arguments hold values for:<br/>
    model, Journal to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.Journal).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	
	$$$ThrowOnError(##class(Api.Config.Services.Journal).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetLicenseServers">
<Description><![CDATA[
Get LicenseServers.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("LicenseServers", name)
]]></Implementation>
</Method>

<Method name="PutLicenseServers">
<Description><![CDATA[
Update LicenseServers.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>
    model, LicenseServers to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.LicenseServers).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.LicenseServers).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.LicenseServers).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostLicenseServers">
<Description><![CDATA[
Create LicenseServers.<br/>
The method arguments hold values for:<br/>
    model, LicenseServers to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set resp = ..DefaultPostImpl("LicenseServers", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"licenseservers/"_dModel.Name)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteLicenseServers">
<Description><![CDATA[
Delete LicenseServers.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultDelImpl("LicenseServers", name)
]]></Implementation>
</Method>

<Method name="GetListLicenseServers">
<Description>
Get List Of LicenseServers.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultListOf("LicenseServers","ListOfLicenseServers")
]]></Implementation>
</Method>

<Method name="GetMagTapes">
<Description><![CDATA[
Get MagTapes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("MagTapes", name)
]]></Implementation>
</Method>

<Method name="PutMagTapes">
<Description><![CDATA[
Update MagTapes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>
    model, MagTapes to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.MagTapes).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.MagTapes).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MagTapes).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostMagTapes">
<Description><![CDATA[
Create MagTapes.<br/>
The method arguments hold values for:<br/>
    model, MagTapes to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set resp = ..DefaultPostImpl("MagTapes", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"magtapes/"_dModel.Name)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteMagTapes">
<Description><![CDATA[
Delete MagTapes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultDelImpl("MagTapes", name)
]]></Implementation>
</Method>

<Method name="GetListMagTapes">
<Description>
Get List Of MagTapes.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultListOf("MagTapes","ListOfMagTapes")
]]></Implementation>
</Method>

<Method name="GetMapGlobals">
<Description><![CDATA[
Get MapGlobals.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("MapGlobals", namespace, name)
]]></Implementation>
</Method>

<Method name="PutMapGlobals">
<Description><![CDATA[
Update MapGlobals.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>
    model, MapGlobals to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name, dModel.Namespace = namespace
	Set sc =##class(Api.Config.Services.MapGlobals).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.MapGlobals).Exists(namespace,name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MapGlobals).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostMapGlobals">
<Description><![CDATA[
Create MapGlobals.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    model, MapGlobals to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Namespace = namespace
	Set resp = ..DefaultPostImpl("MapGlobals", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"mapglobals/"_namespace_"/"_dModel.Name)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteMapGlobals">
<Description><![CDATA[
Delete MapGlobals.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultDelImpl("MapGlobals", namespace, name)
]]></Implementation>
</Method>

<Method name="GetListMapGlobals">
<Description><![CDATA[
Get List Of MapGlobals.<br/>
The method arguments hold values for:<br/>
    namespace, namespace.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set lst = ##class(Api.Config.Services.MapGlobals).List(namespace)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfMapGlobals":(lst)}
]]></Implementation>
</Method>

<Method name="GetMapMirrors">
<Description><![CDATA[
Get MapMirrors.<br/>
The method arguments hold values for:<br/>
    id, ID where the mapping is.<br><br/>
    name, This is the name of this instance in the mirror. Mirror system names
must be unique (enforced by Enterprise Manager) across all of the mirrors which 
the EM manages, as an instance has a single mirror system name which 
may appear in multiple mirror sets (eg. a reporting member may connect
to multiple mirrors). For the most part the <property>GUID </property>
is used to identify a mirror member, the Name is used for display 
purposes. 
<br><br>
The name must not contain a colon (':') and is converted to uppercase before
saving.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("MapMirrors", id, name)
]]></Implementation>
</Method>

<Method name="PutMapMirrors">
<Description><![CDATA[
Update MapMirrors.<br/>
The method arguments hold values for:<br/>
    id, ID where the mapping is.<br><br/>
    name, This is the name of this instance in the mirror. Mirror system names
must be unique (enforced by Enterprise Manager) across all of the mirrors which 
the EM manages, as an instance has a single mirror system name which 
may appear in multiple mirror sets (eg. a reporting member may connect
to multiple mirrors). For the most part the <property>GUID </property>
is used to identify a mirror member, the Name is used for display 
purposes. 
<br><br>
The name must not contain a colon (':') and is converted to uppercase before
saving.<br/>
    model, MapMirrors to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Id = id, dModel.Name = name
	Set sc =##class(Api.Config.Services.MapMirrors).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.MapMirrors).Exists(id,name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MapMirrors).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostMapMirrors">
<Description><![CDATA[
Create MapMirrors.<br/>
The method arguments hold values for:<br/>
    id, ID where the mapping is.<br><br/>
    model, MapMirrors to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Id = id
	Set resp = ..DefaultPostImpl("MapMirrors", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"mapmirrors/"_id_"/"_dModel.Name)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteMapMirrors">
<Description><![CDATA[
Delete MapMirrors.<br/>
The method arguments hold values for:<br/>
    id, ID where the mapping is.<br><br/>
    name, This is the name of this instance in the mirror. Mirror system names
must be unique (enforced by Enterprise Manager) across all of the mirrors which 
the EM manages, as an instance has a single mirror system name which 
may appear in multiple mirror sets (eg. a reporting member may connect
to multiple mirrors). For the most part the <property>GUID </property>
is used to identify a mirror member, the Name is used for display 
purposes. 
<br><br>
The name must not contain a colon (':') and is converted to uppercase before
saving.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultDelImpl("MapMirrors", id, name)
]]></Implementation>
</Method>

<Method name="GetListMapMirrors">
<Description><![CDATA[
Get List Of MapMirrors.<br/>
The method arguments hold values for:<br/>
    id, ID where the mapping is.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set lst = ##class(Api.Config.Services.MapMirrors).List(id)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfMapMirrors":(lst)}
]]></Implementation>
</Method>

<Method name="GetMapPackages">
<Description><![CDATA[
Get MapPackages.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("MapPackages", namespace, name)
]]></Implementation>
</Method>

<Method name="PutMapPackages">
<Description><![CDATA[
Update MapPackages.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>
    model, MapPackages to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Namespace = namespace, dModel.Name = name
	Set sc =##class(Api.Config.Services.MapPackages).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.MapPackages).Exists(namespace,name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MapPackages).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostMapPackages">
<Description><![CDATA[
Create MapPackages.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    model, MapPackages to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Namespace = namespace
	Set resp = ..DefaultPostImpl("MapPackages", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"mappackages/"_namespace_"/"_dModel.Name)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteMapPackages">
<Description><![CDATA[
Delete MapPackages.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultDelImpl("MapPackages", namespace, name)
]]></Implementation>
</Method>

<Method name="GetListMapPackages">
<Description><![CDATA[
Get List Of MapPackages.<br/>
The method arguments hold values for:<br/>
    namespace, namespace.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set lst = ##class(Api.Config.Services.MapPackages).List(namespace)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfMapPackages":(lst)}
]]></Implementation>
</Method>

<Method name="GetMapRoutines">
<Description><![CDATA[
Get MapRoutines.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("MapRoutines", namespace, name)
]]></Implementation>
</Method>

<Method name="PutMapRoutines">
<Description><![CDATA[
Update MapRoutines.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>
    model, MapRoutines to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Namespace = namespace, dModel.Name = name
	Set sc =##class(Api.Config.Services.MapRoutines).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.MapRoutines).Exists(namespace,name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MapRoutines).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostMapRoutines">
<Description><![CDATA[
Create MapRoutines.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    model, MapRoutines to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Namespace = namespace
	Set resp = ..DefaultPostImpl("MapRoutines", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"maproutines/"_namespace_"/"_dModel.Name)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteMapRoutines">
<Description><![CDATA[
Delete MapRoutines.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultDelImpl("MapRoutines", namespace, name)
]]></Implementation>
</Method>

<Method name="GetListMapRoutines">
<Description><![CDATA[
Get List Of MapRoutines.<br/>
The method arguments hold values for:<br/>
    namespace, namespace.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set lst = ##class(Api.Config.Services.MapRoutines).List(namespace)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfMapRoutines":(lst)}
]]></Implementation>
</Method>

<Method name="GetMapShadows">
<Description><![CDATA[
Get MapShadows.<br/>
The method arguments hold values for:<br/>
    id, ID where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.MapShadows).Exists(id,name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Set model = ##class(Api.Config.Services.MapShadows).Get(id,name)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutMapShadows">
<Description><![CDATA[
Update MapShadows.<br/>
The method arguments hold values for:<br/>
    id, ID where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>
    model, MapShadows to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Id = id, dModel.Name = name
	Set sc =##class(Api.Config.Services.MapShadows).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.MapShadows).Exists(id,name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MapShadows).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetMirrorMember">
<Description>
Get MirrorMember.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("MirrorMember")
]]></Implementation>
</Method>

<Method name="PostMapShadows">
<Description><![CDATA[
Create MapShadows.<br/>
The method arguments hold values for:<br/>
    id, ID where the mapping is.<br><br/>
    model, MapShadows to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Id = id
	Set resp = ..DefaultPostImpl("MapShadows", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"mapshadows/"_id_"/"_dModel.Name)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteMapShadows">
<Description><![CDATA[
Delete MapShadows.<br/>
The method arguments hold values for:<br/>
    id, ID where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultDelImpl("MapShadows", id, name)
]]></Implementation>
</Method>

<Method name="PutMirrorMember">
<Description><![CDATA[
Update MirrorMember.<br/>
The method arguments hold values for:<br/>
    model, MirrorMember to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.MirrorMember).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	
	$$$ThrowOnError(##class(Api.Config.Services.MirrorMember).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListMapShadows">
<Description><![CDATA[
Get List Of MapShadows.<br/>
The method arguments hold values for:<br/>
    id, ID where the mapping is.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set lst = ##class(Api.Config.Services.MapShadows).List(id)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfMapShadows":(lst)}
]]></Implementation>
</Method>

<Method name="GetMirrors">
<Description><![CDATA[
Get Mirrors.<br/>
The method arguments hold values for:<br/>
    name, Mirror names are uppercase (alphanumeric)
Name of the mirror, restricted to 15 uppercase alphanumeric characters. 
Must be unique across the mirrors managed by the EMS<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("Mirrors",name)
]]></Implementation>
</Method>

<Method name="PutMirrors">
<Description><![CDATA[
Update Mirrors.<br/>
The method arguments hold values for:<br/>
    name, Mirror names are uppercase (alphanumeric)
Name of the mirror, restricted to 15 uppercase alphanumeric characters. 
Must be unique across the mirrors managed by the EMS<br/>
    model, Mirrors to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.Mirrors).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.Mirrors).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Mirrors).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetMiscellaneous">
<Description>
Get Miscellaneous.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("Miscellaneous")
]]></Implementation>
</Method>

<Method name="PostMirrors">
<Description><![CDATA[
Create Mirrors.<br/>
The method arguments hold values for:<br/>
    model, Mirrors to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set resp = ..DefaultPostImpl("Mirrors", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"mirrors/"_dModel.Name)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteMirrors">
<Description><![CDATA[
Delete Mirrors.<br/>
The method arguments hold values for:<br/>
    name, Mirror names are uppercase (alphanumeric)
Name of the mirror, restricted to 15 uppercase alphanumeric characters. 
Must be unique across the mirrors managed by the EMS<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultDelImpl("Mirrors", name)
]]></Implementation>
</Method>

<Method name="PutMiscellaneous">
<Description><![CDATA[
Update Miscellaneous.<br/>
The method arguments hold values for:<br/>
    model, Miscellaneous to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.Miscellaneous).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	
	$$$ThrowOnError(##class(Api.Config.Services.Miscellaneous).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListMirrors">
<Description>
Get List Of Mirrors.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultListOf("Mirrors","ListOfMirrors")
]]></Implementation>
</Method>

<Method name="GetMonitor">
<Description>
Get Monitor.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("Monitor")
]]></Implementation>
</Method>

<Method name="PutMonitor">
<Description><![CDATA[
Update Monitor.<br/>
The method arguments hold values for:<br/>
    model, Monitor to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.Monitor).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	
	$$$ThrowOnError(##class(Api.Config.Services.Monitor).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetNamespaces">
<Description><![CDATA[
Get Namespaces.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("Namespaces", name)
]]></Implementation>
</Method>

<Method name="PutNamespaces">
<Description><![CDATA[
Update Namespaces.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>
    model, Namespaces to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model), dModel.Name = name
	Set resp = ..DefaultPutImpl("Namespaces", dModel)
	Quit resp
]]></Implementation>
</Method>

<Method name="GetSQL">
<Description>
Get SQL.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("SQL")
]]></Implementation>
</Method>

<Method name="PostNamespaces">
<Description><![CDATA[
Create Namespaces.<br/>
The method arguments hold values for:<br/>
    model, Namespaces to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model), resp = ..DefaultPostImpl("Namespaces", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"namespaces/"_dModel.Name)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteNamespaces">
<Description><![CDATA[
Delete Namespaces.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultDelImpl("Namespaces", name)
]]></Implementation>
</Method>

<Method name="PutSQL">
<Description><![CDATA[
Update SQL.<br/>
The method arguments hold values for:<br/>
    model, SQL to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.SQL).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	
	$$$ThrowOnError(##class(Api.Config.Services.SQL).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListNamespaces">
<Description>
Get List Of Namespaces.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultListOf("Namespaces","ListOfNamespaces")
]]></Implementation>
</Method>

<Method name="GetShadows">
<Description><![CDATA[
Get Shadows.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("Shadows",name)
]]></Implementation>
</Method>

<Method name="PutShadows">
<Description><![CDATA[
Update Shadows.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>
    model, Shadows to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.Shadows).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.Shadows).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Shadows).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostShadows">
<Description><![CDATA[
Create Shadows.<br/>
The method arguments hold values for:<br/>
    model, Shadows to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set resp = ..DefaultPostImpl("Shadows", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"shadows/"_dModel.Name)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteShadows">
<Description><![CDATA[
Delete Shadows.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultDelImpl("Shadows", name)
]]></Implementation>
</Method>

<Method name="GetListShadows">
<Description>
Get List Of Shadows.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultListOf("Shadows","ListOfShadows")
]]></Implementation>
</Method>

<Method name="GetSqlSysDatatypes">
<Description><![CDATA[
Get SqlSysDatatypes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("SqlSysDatatypes",name)
]]></Implementation>
</Method>

<Method name="PutSqlSysDatatypes">
<Description><![CDATA[
Update SqlSysDatatypes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>
    model, SqlSysDatatypes to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.SqlSysDatatypes).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.SqlSysDatatypes).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.SqlSysDatatypes).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostSqlSysDatatypes">
<Description><![CDATA[
Create SqlSysDatatypes.<br/>
The method arguments hold values for:<br/>
    model, SqlSysDatatypes to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set resp = ..DefaultPostImpl("SqlSysDatatypes", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"sqlsysdatatypes/"_dModel.Name)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteSqlSysDatatypes">
<Description><![CDATA[
Delete SqlSysDatatypes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultDelImpl("SqlSysDatatypes", name)
]]></Implementation>
</Method>

<Method name="GetListSqlSysDatatypes">
<Description>
Get List Of SqlSysDatatypes.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultListOf("SqlSysDatatypes","ListOfSqlSysDatatypes")
]]></Implementation>
</Method>

<Method name="GetSqlUserDatatypes">
<Description><![CDATA[
Get SqlUserDatatypes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("SqlUserDatatypes",name)
]]></Implementation>
</Method>

<Method name="PutSqlUserDatatypes">
<Description><![CDATA[
Update SqlUserDatatypes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>
    model, SqlUserDatatypes to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.SqlUserDatatypes).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.SqlUserDatatypes).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.SqlUserDatatypes).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetStartup">
<Description>
Get Startup.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("Startup")
]]></Implementation>
</Method>

<Method name="PostSqlUserDatatypes">
<Description><![CDATA[
Create SqlUserDatatypes.<br/>
The method arguments hold values for:<br/>
    model, SqlUserDatatypes to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set resp = ..DefaultPostImpl("SqlUserDatatypes", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"sqluserdatatypes/"_dModel.Name)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteSqlUserDatatypes">
<Description><![CDATA[
Delete SqlUserDatatypes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultDelImpl("SqlUserDatatypes", name)
]]></Implementation>
</Method>

<Method name="PutStartup">
<Description><![CDATA[
Update Startup.<br/>
The method arguments hold values for:<br/>
    model, Startup to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.Startup).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	
	$$$ThrowOnError(##class(Api.Config.Services.Startup).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListSqlUserDatatypes">
<Description>
Get List Of SqlUserDatatypes.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultListOf("SqlUserDatatypes","ListOfSqlUserDatatypes")
]]></Implementation>
</Method>

<Method name="GetTelnet">
<Description>
Get Telnet.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("Telnet")
]]></Implementation>
</Method>

<Method name="PutTelnet">
<Description><![CDATA[
Update Telnet.<br/>
The method arguments hold values for:<br/>
    model, Telnet to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.Telnet).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	
	$$$ThrowOnError(##class(Api.Config.Services.Telnet).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="Getconfig">
<Description>
Get config.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("config")
]]></Implementation>
</Method>

<Method name="Putconfig">
<Description><![CDATA[
Update config.<br/>
The method arguments hold values for:<br/>
    model, config to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model), resp = ..DefaultPutImpl("config", dModel,,$$$NO)
	Quit resp
]]></Implementation>
</Method>

<Method name="GetListOfDirectory">
<Description>
Get list of databases directory.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultListOf("SYS.Databases","ListOfDirectory")
]]></Implementation>
</Method>

<Method name="GetDirectory">
<Description><![CDATA[
Get database directory details.<br/>
The method arguments hold values for:<br/>
    directory, Database directory ex: /usr/irissys/mgr/user/ don't forget to escape -> %2Fusr%2Firissys%2Fmgr%2Fuser%2F.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>directory:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("SYS.Databases",directory)
]]></Implementation>
</Method>

<Method name="PostDirectory">
<Description><![CDATA[
Create a new database directory.<br/>
The method arguments hold values for:<br/>
    directory, Database directory to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>directory:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(.directory)
	Set resp = ..DefaultPostImpl("SYS.Databases", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"sys/databases/"_##class(%CSP.Page).EscapeURL(dModel.Directory))
	Quit resp
]]></Implementation>
</Method>

<Method name="PutDirectory">
<Description><![CDATA[
Update an existing database directory.<br/>
The method arguments hold values for:<br/>
    directory, Database directory ex: /usr/irissys/mgr/user/ don't forget to escape -> %2Fusr%2Firissys%2Fmgr%2Fuser%2F.<br/>
    DirectoryModel, Database to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>directory:%String,DirectoryModel:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.DirectoryModel), dModel.Directory = ##class(%CSP.Page).UnescapeURL(directory)
	Set resp = ..DefaultPutImpl("SYS.Databases", dModel,,$$$YES)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteDirectory">
<Description><![CDATA[
Delete database directory.<br/>
The method arguments hold values for:<br/>
    directory, Database directory ex: /usr/irissys/mgr/user/ don't forget to escape -> %2Fusr%2Firissys%2Fmgr%2Fuser%2F.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>directory:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultDelImpl("SYS.Databases",  ##class(%CSP.Page).UnescapeURL(directory))
]]></Implementation>
</Method>

<Method name="PutDirectoryMounted">
<Description><![CDATA[
Mount database.<br/>
The method arguments hold values for:<br/>
    directory<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>directory:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set directory = ##class(%CSP.Page).UnescapeURL(directory)

	If '##class(Api.Config.Services.SYS.Databases).Exists(directory) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	$$$ThrowOnError(##class(Api.Config.Services.SYS.Databases).Mount(directory))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="DeleteDirectoryMounted">
<Description><![CDATA[
Dismount database.<br/>
The method arguments hold values for:<br/>
    directory<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>directory:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set directory = ##class(%CSP.Page).UnescapeURL(directory)

	If '##class(Api.Config.Services.SYS.Databases).Exists(directory) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	$$$ThrowOnError(##class(Api.Config.Services.SYS.Databases).Dismount(directory))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetWebApp">
<Description><![CDATA[
Get Web application.<br/>
The method arguments hold values for:<br/>
    name, Web application url ex : /api/config don't forget to escape -> %2Fapi%2Fconfig<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultGetImpl("Security.Applications",name)
]]></Implementation>
</Method>

<Method name="PutWebApp">
<Description><![CDATA[
Update Web application.<br/>
The method arguments hold values for:<br/>
    name, Web application url ex : /api/config don't forget to escape -> %2Fapi%2Fconfig<br/>
    model<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(model)
	Set name = ##class(%CSP.Page).UnescapeURL(name)
	If '##class(Api.Config.Services.Security.Applications).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	$$$ThrowOnError(##class(Api.Config.Services.Security.Applications).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostWebApp">
<Description><![CDATA[
Create a new web applications.<br/>
The method arguments hold values for:<br/>
    model<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(.model)
	Set resp = ..DefaultPostImpl("Security.Applications", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"security/applications/"_##class(%CSP.Page).EscapeURL(dModel.Name))
	Quit resp
]]></Implementation>
</Method>

<Method name="GetListOfWebApps">
<Description>
Get list of existing web applications.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultListOf("Security.Applications","ListOfWebApps")
]]></Implementation>
</Method>

<Method name="DeleteWebApp">
<Description><![CDATA[
Delete Web application.<br/>
The method arguments hold values for:<br/>
    name, Web application url ex : /api/config don't forget to escape -> %2Fapi%2Fconfig<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultDelImpl("Security.Applications",  name)
]]></Implementation>
</Method>

<Method name="LoadConfiguration">
<Description><![CDATA[
Load configuration.<br/>
The method arguments hold values for:<br/>
    model, configuration in json format.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(model)
	Do ##class(IORedirect.Redirect).ToStream()
	Try {
		Set tSC = ##class(Api.Config.Services.Loader).Load(dModel)
	}
	Catch ex {
		Set tSC=ex.AsStatus()
	}
	
	Do ##class(IORedirect.Redirect).RestoreIO()
	Set stream = ##class(IORedirect.Redirect).Get()
	
	If $$$ISERR(tSC) {
		Do ..%SetStatusCode(500)
		Do stream.WriteLine($SYSTEM.Status.GetOneErrorText(tSC))
	}
	Do stream.Rewind()
	Quit stream
]]></Implementation>
</Method>

<Method name="DeleteConfiguration">
<Description><![CDATA[
WARNING Delete all namespaces, databases, webapps,... defined in configuration object.<br/>
The method arguments hold values for:<br/>
    model, configuration in json format.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(model)
	Do ##class(IORedirect.Redirect).ToStream()
	
	Try {
		Set tSC = ##class(Api.Config.Services.Loader).Delete(dModel)
	}
	Catch ex {
		Set tSC=ex.AsStatus()
	}
	
	Do ##class(IORedirect.Redirect).RestoreIO()
	Set stream = ##class(IORedirect.Redirect).Get()
	
	If $$$ISERR(tSC) {
		Do ..%SetStatusCode(500)
		Do stream.WriteLine($SYSTEM.Status.GetOneErrorText(tSC))
	}
	Do stream.Rewind()
	Quit stream
]]></Implementation>
</Method>

<Method name="GetListOfServices">
<Description>
Get list of services.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultListOf("Security.Services","ListOfServices")
]]></Implementation>
</Method>

<Method name="GetService">
<Description><![CDATA[
Get service detail by name<br/>
The method arguments hold values for:<br/>
    name<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[	Quit ..DefaultGetImpl("Security.Services",name)
]]></Implementation>
</Method>

<Method name="PutService">
<Description><![CDATA[
Update service.  Set Enable property to 1/0 to activate/disable.<br/>
The method arguments hold values for:<br/>
    name<br/>
    model<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(model)
	Set name = ##class(%CSP.Page).UnescapeURL(name)
	If '##class(Api.Config.Services.Security.Services).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	$$$ThrowOnError(##class(Api.Config.Services.Security.Services).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostExport">
<Description><![CDATA[
Create an export instance on the server following your filter criteria.  You can download the created export with GET /export/{id}.  See the location response header.<br/>
The method arguments hold values for:<br/>
    filter, params filter to export.<br/>
    OnlyNotDefaultValue, export only not default value parameters.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filter:%Stream.Object,OnlyNotDefaultValue:%Integer</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(filter)
	Do ..%SetStatusCode($$$HTTP201)
	Set export = ##class(Api.Config.Services.Loader).export(dModel,''OnlyNotDefaultValue)
	Set record = ##class(Api.Config.TempStream).%New()
	Set record.name = "export-config"
	Do export.%ToJSON(record.charStream)
	Do record.%Save()
	Do ..%SetStatusCode($$$HTTP201)
	Do ..%SetHeader("Location", %request.Application_"export/"_record.%Id())
	Quit ""
]]></Implementation>
</Method>

<Method name="GetExport">
<Description><![CDATA[
Get an existing configuration export.<br/>
The method arguments hold values for:<br/>
    id, export id to retrieve.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    If '##class(Api.Config.TempStream).%ExistsId(id) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	Do ..%SetStatusCode($$$HTTP200)
	Set record = ##class(Api.Config.TempStream).%OpenId(id)
	Set response = {}.%FromJSON(record.charStream)
	Quit response
]]></Implementation>
</Method>

<Method name="PostUsers">
<Description><![CDATA[
Create a new user.<br/>
The method arguments hold values for:<br/>
    model<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(.model)
	Set resp = ..DefaultPostImpl("Security.Users", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"security/users/"_dModel.Name)
	Quit resp
]]></Implementation>
</Method>

<Method name="GetListOfUsers">
<Description>
Get list of users.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultListOf("Security.Users")
]]></Implementation>
</Method>

<Method name="GetUser">
<Description><![CDATA[
Get user detail.<br/>
The method arguments hold values for:<br/>
    name, user name<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultGetImpl("Security.Users", name)
]]></Implementation>
</Method>

<Method name="PutUsers">
<Description><![CDATA[
Update user.<br/>
The method arguments hold values for:<br/>
    name, username.<br/>
    model<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(.model), dModel.Name = name
	Set resp = ..DefaultPutImpl("Security.Users", dModel)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteUsers">
<Description><![CDATA[
Delete a user.<br/>
The method arguments hold values for:<br/>
    name, username.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultDelImpl("Security.Users", name)
]]></Implementation>
</Method>

<Method name="PostRoles">
<Description><![CDATA[
Create a new role.<br/>
The method arguments hold values for:<br/>
    model<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(.model)
	Set resp = ..DefaultPostImpl("Security.Roles", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"/security/roles/"_dModel.Name)
	Quit resp
]]></Implementation>
</Method>

<Method name="GetListOfRoles">
<Description>
Get list of roles.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultListOf("Security.Roles")
]]></Implementation>
</Method>

<Method name="GetRoles">
<Description><![CDATA[
Get role detail.<br/>
The method arguments hold values for:<br/>
    name, role name<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultGetImpl("Security.Roles", name)
]]></Implementation>
</Method>

<Method name="PutRoles">
<Description><![CDATA[
Update role.<br/>
The method arguments hold values for:<br/>
    name, role name.<br/>
    model<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(.model), dModel.Name = name
	Set resp = ..DefaultPutImpl("Security.Roles", dModel)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteRoles">
<Description><![CDATA[
Delete a role.<br/>
The method arguments hold values for:<br/>
    name, role name.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultDelImpl("Security.Roles", name)
]]></Implementation>
</Method>

<Method name="PostResources">
<Description><![CDATA[
Create a new resource.<br/>
The method arguments hold values for:<br/>
    model<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(.model)
	Set resp = ..DefaultPostImpl("Security.Resources", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"/security/resources/"_dModel.Name)
	Quit resp
]]></Implementation>
</Method>

<Method name="GetListOfResources">
<Description>
Get list of resources.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultListOf("Security.Resources")
]]></Implementation>
</Method>

<Method name="GetResources">
<Description><![CDATA[
Get resource detail.<br/>
The method arguments hold values for:<br/>
    name, resource name<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultGetImpl("Security.Resources", name)
]]></Implementation>
</Method>

<Method name="PutResources">
<Description><![CDATA[
Update resource.<br/>
The method arguments hold values for:<br/>
    name, resource name.<br/>
    model<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(.model), dModel.Name = name
	Set resp = ..DefaultPutImpl("Security.Resources", dModel)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteResources">
<Description><![CDATA[
Delete a resource.<br/>
The method arguments hold values for:<br/>
    name, resource name.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultDelImpl("Security.Resources", name)
]]></Implementation>
</Method>

<Method name="PostSSLConfigs">
<Description><![CDATA[
Create a new sslconfig.<br/>
The method arguments hold values for:<br/>
    model<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(.model)
	Set resp = ..DefaultPostImpl("Security.SSLConfigs", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"/security/sslconfigs/"_dModel.Name)
	Quit resp
]]></Implementation>
</Method>

<Method name="GetListOfSSLConfigs">
<Description>
Get list of sslconfigs.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultListOf("Security.SSLConfigs")
]]></Implementation>
</Method>

<Method name="GetSSLConfigs">
<Description><![CDATA[
Get sslconfig detail.<br/>
The method arguments hold values for:<br/>
    name, sslconfig name<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultGetImpl("Security.SSConfigs", name)
]]></Implementation>
</Method>

<Method name="PutSSLConfigs">
<Description><![CDATA[
Update sslconfig.<br/>
The method arguments hold values for:<br/>
    name, sslconfig name.<br/>
    model<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(.model), dModel.Name = name
	Set resp = ..DefaultPutImpl("Security.SSLConfigs", dModel)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteSSLConfigs">
<Description><![CDATA[
Delete a sslconfig.<br/>
The method arguments hold values for:<br/>
    name, sslconfig name.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultDelImpl("Security.SSLConfigs", name)
]]></Implementation>
</Method>

<Method name="GetListOfSQLAdminPrivilegeSet">
<Description>
Get list of SQLAdminPrivilegeSet.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultListOf("Security.SQLAdminPrivilegeSet")
]]></Implementation>
</Method>

<Method name="PutSQLAdminPrivilegeSet">
<Description><![CDATA[
Set SQLAdminPrivilegeSet.<br/>
The method arguments hold values for:<br/>
    model<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(.model)
	Set resp = ..DefaultPutImpl("Security.SQLAdminPrivilegeSet", dModel, , $$$NO)
	Quit resp
]]></Implementation>
</Method>

<Method name="GetSQLAdminPrivilegeSet">
<Description><![CDATA[
Get SQLAdminPrivilegeSet detail.<br/>
The method arguments hold values for:<br/>
    namespace, namespace<br/>
    grantee, grantee<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,grantee:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultGetImpl("Security.SQLAdminPrivilegeSet", namespace, grantee)
]]></Implementation>
</Method>

<Method name="DeleteSQLAdminPrivilegeSet">
<Description><![CDATA[
Delete SQLAdminPrivilegeSet.<br/>
The method arguments hold values for:<br/>
    namespace, namespace<br/>
    grantee, grantee<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,grantee:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultDelImpl("Security.SQLAdminPrivilegeSet", namespace, grantee)
]]></Implementation>
</Method>

<Method name="GetListOfSQLPrivileges">
<Description><![CDATA[
Get list of privilege for namespace and grantee.<br/>
The method arguments hold values for:<br/>
    namespace<br/>
    grantee<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,grantee:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set lst = ##class(Api.Config.Services.Security.SQLPrivileges).List(namespace,grantee)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfNamespaces":(lst)}
]]></Implementation>
</Method>

<Method name="DeleteSQLPrivileges">
<Description><![CDATA[
Delete privileges for namespace and grantee.<br/>
The method arguments hold values for:<br/>
    namespace<br/>
    grantee<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,grantee:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultDelImpl("Security.SQLPrivileges", namespace, grantee)
]]></Implementation>
</Method>

<Method name="PutSQLPrivileges">
<Description><![CDATA[
Set SQL Privileges<br/>
The method arguments hold values for:<br/>
    SQLPrivilege<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>SQLPrivilege:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(.SQLPrivilege)
	Set resp = ..DefaultPutImpl("Security.SQLPrivileges", dModel, , $$$NO)
	Quit resp
]]></Implementation>
</Method>

<Method name="PostSQLConnection">
<Description><![CDATA[
Create a new sqlconnection.<br/>
The method arguments hold values for:<br/>
    model<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(.model)
	Set resp = ..DefaultPostImpl("Library.SQLConnection", dModel, .created)
	Do:created ..%SetHeader("Location", %request.Application_"library/sqlconnection/"_dModel.Name)
	Quit resp
]]></Implementation>
</Method>

<Method name="GetListOfSQLConnection">
<Description>
Get list of existing SQLConnections.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultListOf("Library.SQLConnection")
]]></Implementation>
</Method>

<Method name="GetSQLConnection">
<Description><![CDATA[
Get SQLConnection detail.<br/>
The method arguments hold values for:<br/>
    name, SQLConnection name<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultGetImpl("Library.SQLConnection", name)
]]></Implementation>
</Method>

<Method name="PutSQLConnection">
<Description><![CDATA[
Update SQLConnection.<br/>
The method arguments hold values for:<br/>
    name, SQLConnection name.<br/>
    model<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(.model), dModel.Name = name
	Set resp = ..DefaultPutImpl("Library.SQLConnection", dModel)
	Quit resp
]]></Implementation>
</Method>

<Method name="DeleteSQLConnection">
<Description><![CDATA[
Delete SQLConnection.<br/>
The method arguments hold values for:<br/>
    name, SQLConnection name.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[    Quit ..DefaultDelImpl("Security.SQLConnection", name)
]]></Implementation>
</Method>

<Method name="DefaultGetImpl">
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,ids...</FormalSpec>
<Private>1</Private>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set class = "Api.Config.Services." _ class

	If '$d(ids) {
		Do ..%SetStatusCode($$$HTTP200)
		Quit $CLASSMETHOD(class, "Get")
	}

	Set id1 = ##class(%CSP.Page).UnescapeURL(ids(1))

	If ids = 1 {
		
		If '$CLASSMETHOD(class, "Exists", id1) {
			Do ..%SetStatusCode($$$HTTP404)
			Quit ""
		}
		
		Quit $CLASSMETHOD(class, "Get", id1)
	}

	Set id2 = ##class(%CSP.Page).UnescapeURL(ids(2))

	If '$CLASSMETHOD(class, "Exists", id1, id2) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Do ..%SetStatusCode($$$HTTP200)
	Quit $CLASSMETHOD(class, "Get", id1, id2)
]]></Implementation>
</Method>

<Method name="DefaultDelImpl">
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,ids...</FormalSpec>
<Private>1</Private>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set class = "Api.Config.Services." _ class
	Set id1 = ##class(%CSP.Page).UnescapeURL(ids(1))

	If ids = 1 {
		
		If '$CLASSMETHOD(class, "Exists", id1) {
			Do ..%SetStatusCode($$$HTTP404)
			Quit ""
		}
		
		$$$ThrowOnError($CLASSMETHOD(class, "Delete", id1))
		Do ..%SetStatusCode($$$HTTP204)
		Quit ""
	}

	Set id2 = ##class(%CSP.Page).UnescapeURL(ids(2))

	If '$CLASSMETHOD(class, "Exists", id1, id2) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError($CLASSMETHOD(class, "Delete", id1, id2))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="DefaultPostImpl">
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,dModel:%DynamicObject,*created:%Boolean</FormalSpec>
<Private>1</Private>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set class = "Api.Config.Services." _ class
	Set created = $$$NO, sc = $CLASSMETHOD(class, "CheckModel", dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	Set ids = $PARAMETER(class, "PIDENTIFIER")
	Set id1 = $Piece(ids,",",1)
	Set:id1="" id1="Name"
	Set id2 = $Piece(ids,",",2)

	If id2 = "" {
		If $CLASSMETHOD(class, "Exists", dModel.%Get(id1)) {
			Do ..%SetStatusCode($$$HTTP409)
			Quit ""
		}
	} Else {
		If $CLASSMETHOD(class, "Exists", dModel.%Get(id1), dModel.%Get(id2)) {
			Do ..%SetStatusCode($$$HTTP409)
			Quit ""
		}
	}
	
	$$$ThrowOnError($CLASSMETHOD(class, "Create", dModel))
	Set created = $$$YES
	Do ..%SetStatusCode($$$HTTP201)
	Quit ""
]]></Implementation>
</Method>

<Method name="DefaultPutImpl">
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,dModel:%DynamicObject,*updated:%Boolean,existsTest:%Boolean=$$$YES</FormalSpec>
<Private>1</Private>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set class = "Api.Config.Services." _ class
	Set updated = $$$NO, sc = $CLASSMETHOD(class, "CheckModel", dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}

	If existsTest {
		Set ids = $PARAMETER(class, "PIDENTIFIER")
		Set id1 = $Piece(ids,",",1)
		Set:id1="" id1="Name"
		Set id2 = $Piece(ids,",",2)
		s ^lsc=id1 _ dModel.%Get(id1)
		If id2 = "" {
			If '$CLASSMETHOD(class, "Exists", dModel.%Get(id1)) {
				Do ..%SetStatusCode($$$HTTP404)
				Quit ""
			}
		} Else {
			If '$CLASSMETHOD(class, "Exists", dModel.%Get(id1), dModel.%Get(id2)) {
				Do ..%SetStatusCode($$$HTTP404)
				Quit ""
			}
		}
	}
	
	$$$ThrowOnError($CLASSMETHOD(class, "Update", dModel))
	Set updated = $$$YES
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="DefaultListOf">
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyList:%String="list"</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set class = "Api.Config.Services." _ class, obj = {}
	Set lst = $CLASSMETHOD(class, "List")
	Do ..%SetStatusCode($$$HTTP200), ..%SetContentType("application/json"), obj.%Set(propertyList,lst)
	Quit obj
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.REST.spec">
<ProcedureBlock>1</ProcedureBlock>
<Super>%REST.Spec</Super>
<TimeChanged>66011,29867.067197</TimeChanged>
<TimeCreated>66011,29867.067197</TimeCreated>

<XData name="OpenAPI">
<MimeType>application/json</MimeType>
<Data><![CDATA[
{
  "swagger":"2.0",
  "basePath":"/api/config",
  "schemes":[
    "http",
    "https"
  ],
  "info":{
    "title":"IRIS Config API",
    "version":"0.0.1",
    "description":"Config API.",
    "contact":{
      "name":"Lorenzo Scalese",
      "email":"lorenzo.scalese@gmail.com",
      "url":"https://github.com/lscalese/iris-config-api/"
    },
    "license":{
      "name":"MIT",
      "url":"https://github.com/lscalese/iris-config-api/blob/master/LICENSE"
    }
  },
  "produces":[
    "application/json"
  ],
  "paths":{
    "/":{
      "get":{
        "summary":"Swagger 2.0 specification",
        "tags":[
          "Developer"
        ],
        "operationId":"GetSpecification",
        "description":"Swagger 2.0 specification",
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      }
    },
    "/loader":{
      "put":{
        "description":"Load configuration.",
        "summary":"Load configuration.",
        "operationId":"LoadConfiguration",
        "tags":[
          "Import/Export configuration"
        ],
        "parameters":[
          {
            "name":"model",
            "description":"configuration in json format.",
            "required":true,
            "in":"body",
            "schema":{
              "$ref":"#/definitions/ConfigDocument"
            }
          }
        ],
        "produces":[
          "text/plain"
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      },
      "delete":{
        "summary":"WARNING Delete all namespaces, databases, webapps,... defined in configuration object.",
        "description":"WARNING Delete all namespaces, databases, webapps,... defined in configuration object.",
        "operationId":"DeleteConfiguration",
        "tags":[
          "Import/Export configuration"
        ],
        "parameters":[
          {
            "name":"model",
            "description":"configuration in json format.",
            "required":true,
            "in":"body",
            "schema":{
            }
          }
        ],
        "produces":[
          "text/plain"
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      }
    },
    "/export":{
      "post":{
        "tags":[
          "Import/Export configuration"
        ],
        "summary":"Export a part of IRIS configuration.",
        "description":"Create an export instance on the server following your filter criteria.  You can download the created export with GET /export/{id}.  See the location response header.  ",
        "operationId":"PostExport",
        "parameters":[
          {
            "name":"filter",
            "description":"params filter to export.",
            "required":true,
            "in":"body",
            "schema":{
              "$ref":"#/definitions/ExportFilter"
            }
          },
          {
            "name":"OnlyNotDefaultValue",
            "description":"export only not default value parameters.",
            "required":true,
            "in":"query",
            "type":"integer",
            "default":"1"
          }
        ],
        "responses":{
          "201":{
            "description":"OK",
            "headers":{
              "Location":{
                "type":"string"
              }
            }
          }
        }
      }
    },
    "/export/{id}":{
      "get":{
        "tags":[
          "Import/Export configuration"
        ],
        "summary":"Get an existing configuration export.",
        "description":"Get an existing configuration export.",
        "operationId":"GetExport",
        "parameters":[
          {
            "name":"id",
            "description":"export id to retrieve.",
            "required":true,
            "type":"string",
            "in":"path"
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
            }
          }
        }
      }
    },
    "/security/users":{
      "post":{
        "summary":"Create a new user.",
        "description":"Create a new user.",
        "tags":[
          "Security"
        ],
        "operationId":"PostUsers",
        "parameters":[
          {
            "name":"model",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/SecurityUsers"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"OK",
            "headers":{
              "Location":{
                "type":"string"
              }
            }
          }
        }
      },
      "get":{
        "summary":"Get list of existing users.",
        "description":"Get list of users.",
        "tags":[
          "Security"
        ],
        "operationId":"GetListOfUsers",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfSecurityUsers"
            }
          }
        }
      }
    },
    "/security/users/${name}":{
      "get":{
        "summary":"Get user detail.",
        "description":"Get user detail.",
        "tags":[
          "Security"
        ],
        "operationId":"GetUser",
        "parameters":[
          {
            "name":"name",
            "description":"user name",
            "required":true,
            "type":"string",
            "in":"path"
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/SecurityUsers"
            }
          }
        }
      },
      "put":{
        "summary":"Update user.",
        "description":"Update user.",
        "tags":[
          "Security"
        ],
        "operationId":"PutUsers",
        "parameters":[
          {
            "name":"name",
            "description":"username.",
            "required":true,
            "type":"string",
            "in":"path"
          },
          {
            "name":"model",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/SecurityUsers"
            }
          }
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      },
      "delete":{
        "summary":"Delete a user.",
        "description":"Delete a user.",
        "tags":[
          "Security"
        ],
        "operationId":"DeleteUsers",
        "parameters":[
          {
            "name":"name",
            "description":"username.",
            "required":true,
            "type":"string",
            "in":"path"
          }
        ],
        "responses":{
          "204":{
            "description":"User Deleted."
          },
          "404":{
            "description":"User not found."
          }
        }
      }
    },
    "/security/roles":{
      "post":{
        "summary":"Create a new role.",
        "description":"Create a new role.",
        "tags":[
          "Security"
        ],
        "operationId":"PostRoles",
        "parameters":[
          {
            "name":"model",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/SecurityRoles"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"OK",
            "headers":{
              "Location":{
                "type":"string"
              }
            }
          }
        }
      },
      "get":{
        "summary":"Get list of existing roles.",
        "description":"Get list of roles.",
        "tags":[
          "Security"
        ],
        "operationId":"GetListOfRoles",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfSecurityRoles"
            }
          }
        }
      }
    },
    "/security/roles/${name}":{
      "get":{
        "summary":"Get role detail.",
        "description":"Get role detail.",
        "tags":[
          "Security"
        ],
        "operationId":"GetRoles",
        "parameters":[
          {
            "name":"name",
            "description":"role name",
            "required":true,
            "type":"string",
            "in":"path"
          }
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      },
      "put":{
        "summary":"Update role.",
        "description":"Update role.",
        "tags":[
          "Security"
        ],
        "operationId":"PutRoles",
        "parameters":[
          {
            "name":"name",
            "description":"role name.",
            "required":true,
            "type":"string",
            "in":"path"
          },
          {
            "name":"model",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/SecurityRoles"
            }
          }
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      },
      "delete":{
        "summary":"Delete a role.",
        "description":"Delete a role.",
        "tags":[
          "Security"
        ],
        "operationId":"DeleteRoles",
        "parameters":[
          {
            "name":"name",
            "description":"role name.",
            "required":true,
            "type":"string",
            "in":"path"
          }
        ],
        "responses":{
          "204":{
            "description":"Role Deleted."
          },
          "404":{
            "description":"Role not found."
          }
        }
      }
    },
    "/security/resources":{
      "post":{
        "summary":"Create a new resource.",
        "description":"Create a new resource.",
        "tags":[
          "Security"
        ],
        "operationId":"PostResources",
        "parameters":[
          {
            "name":"model",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/SecurityResources"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"OK",
            "headers":{
              "Location":{
                "type":"string"
              }
            }
          }
        }
      },
      "get":{
        "summary":"Get list of existing resources.",
        "description":"Get list of resources.",
        "tags":[
          "Security"
        ],
        "operationId":"GetListOfResources",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfSecurityResources"
            }
          }
        }
      }
    },
    "/security/resources/${name}":{
      "get":{
        "summary":"Get resource detail.",
        "description":"Get resource detail.",
        "tags":[
          "Security"
        ],
        "operationId":"GetResources",
        "parameters":[
          {
            "name":"name",
            "description":"resource name",
            "required":true,
            "type":"string",
            "in":"path"
          }
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      },
      "put":{
        "summary":"Update resource.",
        "description":"Update resource.",
        "tags":[
          "Security"
        ],
        "operationId":"PutResources",
        "parameters":[
          {
            "name":"name",
            "description":"resource name.",
            "required":true,
            "type":"string",
            "in":"path"
          },
          {
            "name":"model",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/SecurityResources"
            }
          }
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      },
      "delete":{
        "summary":"Delete a resource.",
        "description":"Delete a resource.",
        "tags":[
          "Security"
        ],
        "operationId":"DeleteResources",
        "parameters":[
          {
            "name":"name",
            "description":"resource name.",
            "required":true,
            "type":"string",
            "in":"path"
          }
        ],
        "responses":{
          "204":{
            "description":"Resource Deleted."
          },
          "404":{
            "description":"Resource not found."
          }
        }
      }
    },
    "/security/sslconfigs":{
      "post":{
        "summary":"Create a new sslconfig.",
        "description":"Create a new sslconfig.",
        "tags":[
          "Security"
        ],
        "operationId":"PostSSLConfigs",
        "parameters":[
          {
            "name":"model",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/SecuritySSLConfigs"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"OK",
            "headers":{
              "Location":{
                "type":"string"
              }
            }
          }
        }
      },
      "get":{
        "summary":"Get list of existing sslconfigs.",
        "description":"Get list of sslconfigs.",
        "tags":[
          "Security"
        ],
        "operationId":"GetListOfSSLConfigs",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfSecuritySSLConfigs"
            }
          }
        }
      }
    },
    "/security/sslconfigs/${name}":{
      "get":{
        "summary":"Get sslconfig detail.",
        "description":"Get sslconfig detail.",
        "tags":[
          "Security"
        ],
        "operationId":"GetSSLConfigs",
        "parameters":[
          {
            "name":"name",
            "description":"sslconfig name",
            "required":true,
            "type":"string",
            "in":"path"
          }
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      },
      "put":{
        "summary":"Update sslconfig.",
        "description":"Update sslconfig.",
        "tags":[
          "Security"
        ],
        "operationId":"PutSSLConfigs",
        "parameters":[
          {
            "name":"name",
            "description":"sslconfig name.",
            "required":true,
            "type":"string",
            "in":"path"
          },
          {
            "name":"model",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/SecuritySSLConfigs"
            }
          }
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      },
      "delete":{
        "summary":"Delete a sslconfig.",
        "description":"Delete a sslconfig.",
        "tags":[
          "Security"
        ],
        "operationId":"DeleteSSLConfigs",
        "parameters":[
          {
            "name":"name",
            "description":"sslconfig name.",
            "required":true,
            "type":"string",
            "in":"path"
          }
        ],
        "responses":{
          "204":{
            "description":"SSLConfig Deleted."
          },
          "404":{
            "description":"SSLConfig not found."
          }
        }
      }
    },
    "/security/sqladminprivilegeset":{
      "get":{
        "summary":"Get list of SQLAdminPrivilegeSet.",
        "description":"Get list of SQLAdminPrivilegeSet.",
        "tags":[
          "Security"
        ],
        "operationId":"GetListOfSQLAdminPrivilegeSet",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfSecuritySQLAdminPrivilegeSet"
            }
          }
        }
      },
      "put":{
        "summary":"Set SQLAdminPrivilegeSet.",
        "description":"Set SQLAdminPrivilegeSet.",
        "tags":[
          "Security"
        ],
        "operationId":"PutSQLAdminPrivilegeSet",
        "parameters":[
          {
            "name":"model",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/SecuritySQLAdminPrivilegeSet"
            }
          }
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      }
    },
    "/security/sqladminprivilegeset/{namespace}/{grantee}":{
      "get":{
        "summary":"Get SQLAdminPrivilegeSet detail.",
        "description":"Get SQLAdminPrivilegeSet detail.",
        "tags":[
          "Security"
        ],
        "operationId":"GetSQLAdminPrivilegeSet",
        "parameters":[
          {
            "name":"namespace",
            "description":"namespace",
            "required":true,
            "type":"string",
            "in":"path"
          },
          {
            "name":"grantee",
            "description":"grantee",
            "required":true,
            "type":"string",
            "in":"path"
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/SecuritySQLAdminPrivilegeSet"
            }
          }
        }
      },
      "delete":{
        "summary":"Delete SQLAdminPrivilegeSet.",
        "description":"Delete SQLAdminPrivilegeSet.",
        "tags":[
          "Security"
        ],
        "operationId":"DeleteSQLAdminPrivilegeSet",
        "parameters":[
          {
            "name":"namespace",
            "description":"namespace",
            "required":true,
            "type":"string",
            "in":"path"
          },
          {
            "name":"grantee",
            "description":"grantee",
            "required":true,
            "type":"string",
            "in":"path"
          }
        ],
        "responses":{
          "204":{
            "description":"SQLAdminPrivilegeSet Deleted."
          },
          "404":{
            "description":"SQLAdminPrivilegeSet not found."
          }
        }
      }
    },
    "/security/sqlprivileges/{namespace}/{grantee}":{
      "get":{
        "tags":[
          "Security"
        ],
        "summary":"Get list of privilege for namespace and grantee.",
        "description":"Get list of privilege for namespace and grantee.",
        "operationId":"GetListOfSQLPrivileges",
        "parameters":[
          {
            "name":"namespace",
            "in":"path",
            "required":true,
            "type":"string"
          },
          {
            "name":"grantee",
            "in":"path",
            "required":true,
            "type":"string"
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfSecuritySQLPrivileges"
            }
          }
        }
      },
      "delete":{
        "tags":[
          "Security"
        ],
        "summary":"Delete privileges for namespace and grantee.",
        "description":"Delete privileges for namespace and grantee.",
        "operationId":"DeleteSQLPrivileges",
        "parameters":[
          {
            "name":"namespace",
            "in":"path",
            "required":true,
            "type":"string"
          },
          {
            "name":"grantee",
            "in":"path",
            "required":true,
            "type":"string"
          }
        ],
        "responses":{
          "204":{
            "description":"Privileges deleted."
          }
        }
      }
    },
    "/security/sqlprivileges":{
      "put":{
        "tags":[
          "Security"
        ],
        "summary":"Set SQL Privileges.",
        "description":"Set SQL Privileges",
        "operationId":"PutSQLPrivileges",
        "parameters":[
          {
            "name":"SQLPrivilege",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/SecuritySQLPrivileges"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"Privileges added."
          }
        }
      }
    },
    "/library/sqlconnection":{
      "post":{
        "summary":"Create a new sqlconnection.",
        "description":"Create a new sqlconnection.",
        "tags":[
          "Security"
        ],
        "operationId":"PostSQLConnection",
        "parameters":[
          {
            "name":"model",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/LibrarySQLConnection"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"OK",
            "headers":{
              "Location":{
                "type":"string"
              }
            }
          }
        }
      },
      "get":{
        "summary":"Get list of existing SQLConnections.",
        "description":"Get list of existing SQLConnections.",
        "tags":[
          "Security"
        ],
        "operationId":"GetListOfSQLConnection",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfLibrarySQLConnection"
            }
          }
        }
      }
    },
    "/library/sqlconnection/${name}":{
      "get":{
        "summary":"Get SQLConnection detail.",
        "description":"Get SQLConnection detail.",
        "tags":[
          "Security"
        ],
        "operationId":"GetSQLConnection",
        "parameters":[
          {
            "name":"name",
            "description":"SQLConnection name",
            "required":true,
            "type":"string",
            "in":"path"
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfLibrarySQLConnection"
            }
          }
        }
      },
      "put":{
        "summary":"Update SQLConnection.",
        "description":"Update SQLConnection.",
        "tags":[
          "Security"
        ],
        "operationId":"PutSQLConnection",
        "parameters":[
          {
            "name":"name",
            "description":"SQLConnection name.",
            "required":true,
            "type":"string",
            "in":"path"
          },
          {
            "name":"model",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/LibrarySQLConnection"
            }
          }
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      },
      "delete":{
        "summary":"Delete SQLConnection.",
        "description":"Delete SQLConnection.",
        "tags":[
          "Security"
        ],
        "operationId":"DeleteSQLConnection",
        "parameters":[
          {
            "name":"name",
            "description":"SQLConnection name.",
            "required":true,
            "type":"string",
            "in":"path"
          }
        ],
        "responses":{
          "204":{
            "description":"SQLConnection Deleted."
          },
          "404":{
            "description":"SQLConnection not found."
          }
        }
      }
    },
    "/sys/databases":{
      "get":{
        "tags":[
          "Databases"
        ],
        "summary":"Get list of databases directory.",
        "operationId":"GetListOfDirectory",
        "description":"Get list of databases directory.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfDirectory"
            }
          }
        }
      },
      "post":{
        "tags":[
          "Databases"
        ],
        "operationId":"PostDirectory",
        "summary":"Create a new database directory.",
        "description":"Create a new database directory.",
        "parameters":[
          {
            "name":"directory",
            "description":"Database directory to create.",
            "in":"body",
            "schema":{
              "$ref":"#/definitions/Directory"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"Database created",
            "headers":{
              "Location":{
                "type":"string"
              }
            }
          },
          "409":{
            "description":"Database already exists."
          }
        }
      }
    },
    "/sys/databases/{directory}/mounted":{
      "put":{
        "tags":[
          "Databases"
        ],
        "operationId":"PutDirectoryMounted",
        "summary":"Mount database.",
        "description":"Mount database.",
        "parameters":[
          {
            "name":"directory",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      },
      "delete":{
        "tags":[
          "Databases"
        ],
        "operationId":"DeleteDirectoryMounted",
        "summary":"Dismount database.",
        "description":"Dismount database.",
        "parameters":[
          {
            "name":"directory",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      }
    },
    "/sys/databases/{directory}":{
      "get":{
        "tags":[
          "Databases"
        ],
        "operationId":"GetDirectory",
        "summary":"Get database directory details",
        "description":"Get database directory details.",
        "parameters":[
          {
            "name":"directory",
            "description":"Database directory ex: /usr/irissys/mgr/user/ don't forget to escape -> %2Fusr%2Firissys%2Fmgr%2Fuser%2F.",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Directory"
            }
          },
          "404":{
            "description":"Database directory not found."
          }
        }
      },
      "put":{
        "tags":[
          "Databases"
        ],
        "operationId":"PutDirectory",
        "summary":"Update details of an existing database directory.",
        "description":"Update an existing database directory.",
        "parameters":[
          {
            "name":"directory",
            "description":"Database directory ex: /usr/irissys/mgr/user/ don't forget to escape -> %2Fusr%2Firissys%2Fmgr%2Fuser%2F.",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"DirectoryModel",
            "description":"Database to update.",
            "in":"body",
            "schema":{
              "$ref":"#/definitions/Directory"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"Database updated.",
            "headers":{
              "Location":{
                "type":"string"
              }
            }
          },
          "404":{
            "description":"Database to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Databases"
        ],
        "operationId":"DeleteDirectory",
        "description":"Delete database directory.",
        "parameters":[
          {
            "name":"directory",
            "description":"Database directory ex: /usr/irissys/mgr/user/ don't forget to escape -> %2Fusr%2Firissys%2Fmgr%2Fuser%2F.",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"Database deleted."
          },
          "404":{
            "description":"Database to delete not found."
          }
        }
      }
    },
    "/databases/{name}":{
      "get":{
        "tags":[
          "Databases"
        ],
        "operationId":"GetDatabases",
        "description":"Get Databases.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Databases"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Databases not found."
          }
        }
      },
      "put":{
        "tags":[
          "Databases"
        ],
        "operationId":"PutDatabases",
        "description":"Update Databases.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"Databases to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Databases"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Databases to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Databases"
        ],
        "operationId":"DeleteDatabases",
        "description":"Delete Databases.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"Databases deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Databases not found."
          }
        }
      }
    },
    "/databases":{
      "get":{
        "tags":[
          "Databases"
        ],
        "operationId":"GetListDatabases",
        "description":"Get List Of Databases.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfDatabases"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Databases"
        ],
        "operationId":"PostDatabases",
        "description":"Create Databases.",
        "parameters":[
          {
            "name":"model",
            "description":"Databases to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Databases"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"Databases created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"Databases already exists."
          }
        }
      }
    },
    "/namespaces/{name}":{
      "get":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"GetNamespaces",
        "description":"Get Namespaces.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Namespaces"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Namespaces not found."
          }
        }
      },
      "put":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"PutNamespaces",
        "description":"Update Namespaces.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"Namespaces to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Namespaces"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Namespaces to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"DeleteNamespaces",
        "description":"Delete Namespaces.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"Namespaces deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Namespaces not found."
          }
        }
      }
    },
    "/namespaces":{
      "get":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"GetListNamespaces",
        "description":"Get List Of Namespaces.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfNamespaces"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"PostNamespaces",
        "description":"Create Namespaces.",
        "parameters":[
          {
            "name":"model",
            "description":"Namespaces to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Namespaces"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"Namespaces created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"Namespaces already exists."
          }
        }
      }
    },
    "/security/applications":{
      "post":{
        "summary":"Create a new web applications.",
        "description":"Create a new web applications.",
        "tags":[
          "WebApplication"
        ],
        "operationId":"PostWebApp",
        "parameters":[
          {
            "name":"model",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/WebApplication"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"OK",
            "headers":{
              "Location":{
                "type":"string"
              }
            }
          }
        }
      },
      "get":{
        "summary":"Get list of existing web applications.",
        "description":"Get list of existing web applications.",
        "tags":[
          "WebApplication"
        ],
        "operationId":"GetListOfWebApps",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfWebApplication"
            }
          }
        }
      }
    },
    "/security/applications/{name}":{
      "get":{
        "summary":"Get Web application.",
        "description":"Get Web application.",
        "tags":[
          "WebApplication"
        ],
        "operationId":"GetWebApp",
        "parameters":[
          {
            "name":"name",
            "description":"Web application url ex : /api/config don't forget to escape -> %2Fapi%2Fconfig",
            "required":true,
            "type":"string",
            "in":"path"
          }
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      },
      "put":{
        "summary":"Update Web application.",
        "description":"Update Web application.",
        "tags":[
          "WebApplication"
        ],
        "operationId":"PutWebApp",
        "parameters":[
          {
            "name":"name",
            "description":"Web application url ex : /api/config don't forget to escape -> %2Fapi%2Fconfig",
            "required":true,
            "type":"string",
            "in":"path"
          },
          {
            "name":"model",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/WebApplication"
            }
          }
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      },
      "delete":{
        "summary":"Delete Web application.",
        "description":"Delete Web application.",
        "tags":[
          "WebApplication"
        ],
        "operationId":"DeleteWebApp",
        "parameters":[
          {
            "name":"name",
            "description":"Web application url ex : /api/config don't forget to escape -> %2Fapi%2Fconfig",
            "required":true,
            "type":"string",
            "in":"path"
          }
        ],
        "responses":{
          "204":{
            "description":"Web Application Deleted."
          }
        }
      }
    },
    "/configfile":{
      "get":{
        "tags":[
          "System settings"
        ],
        "operationId":"GetConfigFile",
        "description":"Get ConfigFile.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ConfigFile"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"ConfigFile not found."
          }
        }
      },
      "put":{
        "tags":[
          "System settings"
        ],
        "operationId":"PutConfigFile",
        "description":"Update ConfigFile.",
        "parameters":[
          {
            "name":"model",
            "description":"ConfigFile to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/ConfigFile"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"ConfigFile to update not found."
          }
        }
      }
    },
    "/journal":{
      "get":{
        "tags":[
          "System settings"
        ],
        "operationId":"GetJournal",
        "description":"Get Journal.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Journal"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Journal not found."
          }
        }
      },
      "put":{
        "tags":[
          "System settings"
        ],
        "operationId":"PutJournal",
        "description":"Update Journal.",
        "parameters":[
          {
            "name":"model",
            "description":"Journal to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Journal"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Journal to update not found."
          }
        }
      }
    },
    "/config":{
      "get":{
        "tags":[
          "System settings"
        ],
        "operationId":"Getconfig",
        "description":"Get config.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/config"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"config not found."
          }
        }
      },
      "put":{
        "tags":[
          "System settings"
        ],
        "operationId":"Putconfig",
        "description":"Update config.",
        "parameters":[
          {
            "name":"model",
            "description":"config to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/config"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"config to update not found."
          }
        }
      }
    },
    "/security/services":{
      "get":{
        "tags":[
          "Services"
        ],
        "summary":"Get list of services.",
        "description":"Get list of services.",
        "parameters":[
        ],
        "operationId":"GetListOfServices",
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfServices"
            }
          }
        }
      }
    },
    "/security/services/{name}":{
      "get":{
        "tags":[
          "Services"
        ],
        "summary":"Get service detail by name",
        "description":"Get service detail by name",
        "operationId":"GetService",
        "parameters":[
          {
            "name":"name",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Services"
            }
          }
        }
      },
      "put":{
        "tags":[
          "Services"
        ],
        "summary":"Update service.",
        "description":"Update service.  Set Enable property to 1/0 to activate/disable.",
        "operationId":"PutService",
        "parameters":[
          {
            "name":"name",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Services"
            }
          }
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      }
    },
    "/cluster":{
      "get":{
        "tags":[
          "Others"
        ],
        "operationId":"GetCluster",
        "description":"Get Cluster.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Cluster"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Cluster not found."
          }
        }
      },
      "put":{
        "tags":[
          "Others"
        ],
        "operationId":"PutCluster",
        "description":"Update Cluster.",
        "parameters":[
          {
            "name":"model",
            "description":"Cluster to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Cluster"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Cluster to update not found."
          }
        }
      }
    },
    "/debug/{name}":{
      "get":{
        "tags":[
          "Others"
        ],
        "operationId":"GetDebug",
        "description":"Get Debug.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Debug"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Debug not found."
          }
        }
      },
      "put":{
        "tags":[
          "Others"
        ],
        "operationId":"PutDebug",
        "description":"Update Debug.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"Debug to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Debug"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Debug to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Others"
        ],
        "operationId":"DeleteDebug",
        "description":"Delete Debug.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"Debug deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Debug not found."
          }
        }
      }
    },
    "/debug":{
      "get":{
        "tags":[
          "Others"
        ],
        "operationId":"GetListDebug",
        "description":"Get List Of Debug.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfDebug"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Others"
        ],
        "operationId":"PostDebug",
        "description":"Create Debug.",
        "parameters":[
          {
            "name":"model",
            "description":"Debug to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Debug"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"Debug created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"Debug already exists."
          }
        }
      }
    },
    "/devicesubtypes/{name}":{
      "get":{
        "tags":[
          "Devices"
        ],
        "operationId":"GetDeviceSubTypes",
        "description":"Get DeviceSubTypes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/DeviceSubTypes"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"DeviceSubTypes not found."
          }
        }
      },
      "put":{
        "tags":[
          "Devices"
        ],
        "operationId":"PutDeviceSubTypes",
        "description":"Update DeviceSubTypes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"DeviceSubTypes to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/DeviceSubTypes"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"DeviceSubTypes to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Devices"
        ],
        "operationId":"DeleteDeviceSubTypes",
        "description":"Delete DeviceSubTypes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"DeviceSubTypes deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"DeviceSubTypes not found."
          }
        }
      }
    },
    "/devicesubtypes":{
      "get":{
        "tags":[
          "Devices"
        ],
        "operationId":"GetListDeviceSubTypes",
        "description":"Get List Of DeviceSubTypes.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfDeviceSubTypes"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Devices"
        ],
        "operationId":"PostDeviceSubTypes",
        "description":"Create DeviceSubTypes.",
        "parameters":[
          {
            "name":"model",
            "description":"DeviceSubTypes to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/DeviceSubTypes"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"DeviceSubTypes created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"DeviceSubTypes already exists."
          }
        }
      }
    },
    "/devices/{name}":{
      "get":{
        "tags":[
          "Devices"
        ],
        "operationId":"GetDevices",
        "description":"Get Devices.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Devices"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Devices not found."
          }
        }
      },
      "put":{
        "tags":[
          "Devices"
        ],
        "operationId":"PutDevices",
        "description":"Update Devices.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"Devices to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Devices"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Devices to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Devices"
        ],
        "operationId":"DeleteDevices",
        "description":"Delete Devices.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"Devices deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Devices not found."
          }
        }
      }
    },
    "/devices":{
      "get":{
        "tags":[
          "Devices"
        ],
        "operationId":"GetListDevices",
        "description":"Get List Of Devices.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfDevices"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Devices"
        ],
        "operationId":"PostDevices",
        "description":"Create Devices.",
        "parameters":[
          {
            "name":"model",
            "description":"Devices to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Devices"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"Devices created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"Devices already exists."
          }
        }
      }
    },
    "/ecp":{
      "get":{
        "tags":[
          "ECP"
        ],
        "operationId":"GetECP",
        "description":"Get ECP.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ECP"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"ECP not found."
          }
        }
      },
      "put":{
        "tags":[
          "ECP"
        ],
        "operationId":"PutECP",
        "description":"Update ECP.",
        "parameters":[
          {
            "name":"model",
            "description":"ECP to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/ECP"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"ECP to update not found."
          }
        }
      }
    },
    "/ecpservers/{name}":{
      "get":{
        "tags":[
          "ECP"
        ],
        "operationId":"GetECPServers",
        "description":"Get ECPServers.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ECPServers"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"ECPServers not found."
          }
        }
      },
      "put":{
        "tags":[
          "ECP"
        ],
        "operationId":"PutECPServers",
        "description":"Update ECPServers.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"ECPServers to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/ECPServers"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"ECPServers to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "ECP"
        ],
        "operationId":"DeleteECPServers",
        "description":"Delete ECPServers.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"ECPServers deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"ECPServers not found."
          }
        }
      }
    },
    "/ecpservers":{
      "get":{
        "tags":[
          "ECP"
        ],
        "operationId":"GetListECPServers",
        "description":"Get List Of ECPServers.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfECPServers"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "ECP"
        ],
        "operationId":"PostECPServers",
        "description":"Create ECPServers.",
        "parameters":[
          {
            "name":"model",
            "description":"ECPServers to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/ECPServers"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"ECPServers created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"ECPServers already exists."
          }
        }
      }
    },
    "/io":{
      "get":{
        "tags":[
          "Devices"
        ],
        "operationId":"GetIO",
        "description":"Get IO.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/IO"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"IO not found."
          }
        }
      },
      "put":{
        "tags":[
          "Devices"
        ],
        "operationId":"PutIO",
        "description":"Update IO.",
        "parameters":[
          {
            "name":"model",
            "description":"IO to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/IO"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"IO to update not found."
          }
        }
      }
    },
    "/licenseservers/{name}":{
      "get":{
        "tags":[
          "Others"
        ],
        "operationId":"GetLicenseServers",
        "description":"Get LicenseServers.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/LicenseServers"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"LicenseServers not found."
          }
        }
      },
      "put":{
        "tags":[
          "Others"
        ],
        "operationId":"PutLicenseServers",
        "description":"Update LicenseServers.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"LicenseServers to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/LicenseServers"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"LicenseServers to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Others"
        ],
        "operationId":"DeleteLicenseServers",
        "description":"Delete LicenseServers.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"LicenseServers deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"LicenseServers not found."
          }
        }
      }
    },
    "/licenseservers":{
      "get":{
        "tags":[
          "Others"
        ],
        "operationId":"GetListLicenseServers",
        "description":"Get List Of LicenseServers.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfLicenseServers"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Others"
        ],
        "operationId":"PostLicenseServers",
        "description":"Create LicenseServers.",
        "parameters":[
          {
            "name":"model",
            "description":"LicenseServers to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/LicenseServers"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"LicenseServers created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"LicenseServers already exists."
          }
        }
      }
    },
    "/magtapes/{name}":{
      "get":{
        "tags":[
          "Devices"
        ],
        "operationId":"GetMagTapes",
        "description":"Get MagTapes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/MagTapes"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"MagTapes not found."
          }
        }
      },
      "put":{
        "tags":[
          "Devices"
        ],
        "operationId":"PutMagTapes",
        "description":"Update MagTapes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"MagTapes to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MagTapes"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MagTapes to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Devices"
        ],
        "operationId":"DeleteMagTapes",
        "description":"Delete MagTapes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"MagTapes deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MagTapes not found."
          }
        }
      }
    },
    "/magtapes":{
      "get":{
        "tags":[
          "Devices"
        ],
        "operationId":"GetListMagTapes",
        "description":"Get List Of MagTapes.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfMagTapes"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Devices"
        ],
        "operationId":"PostMagTapes",
        "description":"Create MagTapes.",
        "parameters":[
          {
            "name":"model",
            "description":"MagTapes to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MagTapes"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"MagTapes created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"MagTapes already exists."
          }
        }
      }
    },
    "/mapglobals/{namespace}/{name}":{
      "get":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"GetMapGlobals",
        "description":"Get MapGlobals.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/MapGlobals"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"MapGlobals not found."
          }
        }
      },
      "put":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"PutMapGlobals",
        "description":"Update MapGlobals.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"MapGlobals to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MapGlobals"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MapGlobals to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"DeleteMapGlobals",
        "description":"Delete MapGlobals.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"MapGlobals deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MapGlobals not found."
          }
        }
      }
    },
    "/mapglobals/{namespace}":{
      "get":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"GetListMapGlobals",
        "description":"Get List Of MapGlobals.",
        "parameters":[
          {
            "name":"namespace",
            "description":"namespace.",
            "in":"path",
            "required":true,
            "type":"string"
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfMapGlobals"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"PostMapGlobals",
        "description":"Create MapGlobals.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"MapGlobals to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MapGlobals"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"MapGlobals created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"MapGlobals already exists."
          }
        }
      }
    },
    "/mapmirrors/{id}/{name}":{
      "get":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"GetMapMirrors",
        "description":"Get MapMirrors.",
        "parameters":[
          {
            "name":"id",
            "description":"ID where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"This is the name of this instance in the mirror. Mirror system names\r\nmust be unique (enforced by Enterprise Manager) across all of the mirrors which \r\nthe EM manages, as an instance has a single mirror system name which \r\nmay appear in multiple mirror sets (eg. a reporting member may connect\r\nto multiple mirrors). For the most part the <property>GUID </property>\r\nis used to identify a mirror member, the Name is used for display \r\npurposes. \r\n<br><br>\r\nThe name must not contain a colon (':') and is converted to uppercase before\r\nsaving.",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/MapMirrors"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"MapMirrors not found."
          }
        }
      },
      "put":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"PutMapMirrors",
        "description":"Update MapMirrors.",
        "parameters":[
          {
            "name":"id",
            "description":"ID where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"This is the name of this instance in the mirror. Mirror system names\r\nmust be unique (enforced by Enterprise Manager) across all of the mirrors which \r\nthe EM manages, as an instance has a single mirror system name which \r\nmay appear in multiple mirror sets (eg. a reporting member may connect\r\nto multiple mirrors). For the most part the <property>GUID </property>\r\nis used to identify a mirror member, the Name is used for display \r\npurposes. \r\n<br><br>\r\nThe name must not contain a colon (':') and is converted to uppercase before\r\nsaving.",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"MapMirrors to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MapMirrors"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MapMirrors to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"DeleteMapMirrors",
        "description":"Delete MapMirrors.",
        "parameters":[
          {
            "name":"id",
            "description":"ID where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"This is the name of this instance in the mirror. Mirror system names\r\nmust be unique (enforced by Enterprise Manager) across all of the mirrors which \r\nthe EM manages, as an instance has a single mirror system name which \r\nmay appear in multiple mirror sets (eg. a reporting member may connect\r\nto multiple mirrors). For the most part the <property>GUID </property>\r\nis used to identify a mirror member, the Name is used for display \r\npurposes. \r\n<br><br>\r\nThe name must not contain a colon (':') and is converted to uppercase before\r\nsaving.",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"MapMirrors deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MapMirrors not found."
          }
        }
      }
    },
    "/mapmirrors/{id}":{
      "get":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"GetListMapMirrors",
        "description":"Get List Of MapMirrors.",
        "parameters":[
          {
            "name":"id",
            "description":"ID where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfMapMirrors"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"PostMapMirrors",
        "description":"Create MapMirrors.",
        "parameters":[
          {
            "name":"id",
            "description":"ID where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"MapMirrors to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MapMirrors"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"MapMirrors created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"MapMirrors already exists."
          }
        }
      }
    },
    "/mappackages/{namespace}/{name}":{
      "get":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"GetMapPackages",
        "description":"Get MapPackages.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/MapPackages"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"MapPackages not found."
          }
        }
      },
      "put":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"PutMapPackages",
        "description":"Update MapPackages.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"MapPackages to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MapPackages"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MapPackages to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"DeleteMapPackages",
        "description":"Delete MapPackages.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"MapPackages deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MapPackages not found."
          }
        }
      }
    },
    "/mappackages/{namespace}":{
      "get":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"GetListMapPackages",
        "description":"Get List Of MapPackages.",
        "parameters":[
          {
            "name":"namespace",
            "description":"namespace.",
            "in":"path",
            "required":true,
            "type":"string"
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfMapPackages"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"PostMapPackages",
        "description":"Create MapPackages.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"MapPackages to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MapPackages"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"MapPackages created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"MapPackages already exists."
          }
        }
      }
    },
    "/maproutines/{namespace}/{name}":{
      "get":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"GetMapRoutines",
        "description":"Get MapRoutines.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/MapRoutines"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"MapRoutines not found."
          }
        }
      },
      "put":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"PutMapRoutines",
        "description":"Update MapRoutines.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"MapRoutines to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MapRoutines"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MapRoutines to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"DeleteMapRoutines",
        "description":"Delete MapRoutines.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"MapRoutines deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MapRoutines not found."
          }
        }
      }
    },
    "/maproutines/{namespace}":{
      "get":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"GetListMapRoutines",
        "description":"Get List Of MapRoutines.",
        "parameters":[
          {
            "name":"namespace",
            "description":"namespace.",
            "in":"path",
            "required":true,
            "type":"string"
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfMapRoutines"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"PostMapRoutines",
        "description":"Create MapRoutines.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"MapRoutines to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MapRoutines"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"MapRoutines created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"MapRoutines already exists."
          }
        }
      }
    },
    "/mapshadows/{id}/{name}":{
      "get":{
        "tags":[
          "Shadows"
        ],
        "operationId":"GetMapShadows",
        "description":"Get MapShadows.",
        "parameters":[
          {
            "name":"id",
            "description":"ID where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/MapShadows"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"MapShadows not found."
          }
        }
      },
      "put":{
        "tags":[
          "Shadows"
        ],
        "operationId":"PutMapShadows",
        "description":"Update MapShadows.",
        "parameters":[
          {
            "name":"id",
            "description":"ID where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"MapShadows to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MapShadows"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MapShadows to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Shadows"
        ],
        "operationId":"DeleteMapShadows",
        "description":"Delete MapShadows.",
        "parameters":[
          {
            "name":"id",
            "description":"ID where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"MapShadows deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MapShadows not found."
          }
        }
      }
    },
    "/mapshadows/{id}":{
      "get":{
        "tags":[
          "Shadows"
        ],
        "operationId":"GetListMapShadows",
        "description":"Get List Of MapShadows.",
        "parameters":[
          {
            "name":"id",
            "description":"ID where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfMapShadows"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Shadows"
        ],
        "operationId":"PostMapShadows",
        "description":"Create MapShadows.",
        "parameters":[
          {
            "name":"id",
            "description":"ID where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"MapShadows to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MapShadows"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"MapShadows created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"MapShadows already exists."
          }
        }
      }
    },
    "/mirrormember":{
      "get":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"GetMirrorMember",
        "description":"Get MirrorMember.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/MirrorMember"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"MirrorMember not found."
          }
        }
      },
      "put":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"PutMirrorMember",
        "description":"Update MirrorMember.",
        "parameters":[
          {
            "name":"model",
            "description":"MirrorMember to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MirrorMember"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MirrorMember to update not found."
          }
        }
      }
    },
    "/mirrors/{name}":{
      "get":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"GetMirrors",
        "description":"Get Mirrors.",
        "parameters":[
          {
            "name":"name",
            "description":"Mirror names are uppercase (alphanumeric)\r\nName of the mirror, restricted to 15 uppercase alphanumeric characters. \r\nMust be unique across the mirrors managed by the EMS",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Mirrors"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Mirrors not found."
          }
        }
      },
      "put":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"PutMirrors",
        "description":"Update Mirrors.",
        "parameters":[
          {
            "name":"name",
            "description":"Mirror names are uppercase (alphanumeric)\r\nName of the mirror, restricted to 15 uppercase alphanumeric characters. \r\nMust be unique across the mirrors managed by the EMS",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"Mirrors to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Mirrors"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Mirrors to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"DeleteMirrors",
        "description":"Delete Mirrors.",
        "parameters":[
          {
            "name":"name",
            "description":"Mirror names are uppercase (alphanumeric)\r\nName of the mirror, restricted to 15 uppercase alphanumeric characters. \r\nMust be unique across the mirrors managed by the EMS",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"Mirrors deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Mirrors not found."
          }
        }
      }
    },
    "/mirrors":{
      "get":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"GetListMirrors",
        "description":"Get List Of Mirrors.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfMirrors"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"PostMirrors",
        "description":"Create Mirrors.",
        "parameters":[
          {
            "name":"model",
            "description":"Mirrors to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Mirrors"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"Mirrors created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"Mirrors already exists."
          }
        }
      }
    },
    "/miscellaneous":{
      "get":{
        "tags":[
          "System settings"
        ],
        "operationId":"GetMiscellaneous",
        "description":"Get Miscellaneous.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Miscellaneous"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Miscellaneous not found."
          }
        }
      },
      "put":{
        "tags":[
          "System settings"
        ],
        "operationId":"PutMiscellaneous",
        "description":"Update Miscellaneous.",
        "parameters":[
          {
            "name":"model",
            "description":"Miscellaneous to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Miscellaneous"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Miscellaneous to update not found."
          }
        }
      }
    },
    "/monitor":{
      "get":{
        "tags":[
          "Others"
        ],
        "operationId":"GetMonitor",
        "description":"Get Monitor.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Monitor"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Monitor not found."
          }
        }
      },
      "put":{
        "tags":[
          "Others"
        ],
        "operationId":"PutMonitor",
        "description":"Update Monitor.",
        "parameters":[
          {
            "name":"model",
            "description":"Monitor to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Monitor"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Monitor to update not found."
          }
        }
      }
    },
    "/sql":{
      "get":{
        "tags":[
          "SQL"
        ],
        "operationId":"GetSQL",
        "description":"Get SQL.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/SQL"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"SQL not found."
          }
        }
      },
      "put":{
        "tags":[
          "SQL"
        ],
        "operationId":"PutSQL",
        "description":"Update SQL.",
        "parameters":[
          {
            "name":"model",
            "description":"SQL to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/SQL"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"SQL to update not found."
          }
        }
      }
    },
    "/shadows/{name}":{
      "get":{
        "tags":[
          "Shadows"
        ],
        "operationId":"GetShadows",
        "description":"Get Shadows.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Shadows"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Shadows not found."
          }
        }
      },
      "put":{
        "tags":[
          "Shadows"
        ],
        "operationId":"PutShadows",
        "description":"Update Shadows.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"Shadows to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Shadows"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Shadows to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Shadows"
        ],
        "operationId":"DeleteShadows",
        "description":"Delete Shadows.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"Shadows deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Shadows not found."
          }
        }
      }
    },
    "/shadows":{
      "get":{
        "tags":[
          "Shadows"
        ],
        "operationId":"GetListShadows",
        "description":"Get List Of Shadows.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfShadows"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Shadows"
        ],
        "operationId":"PostShadows",
        "description":"Create Shadows.",
        "parameters":[
          {
            "name":"model",
            "description":"Shadows to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Shadows"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"Shadows created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"Shadows already exists."
          }
        }
      }
    },
    "/sqlsysdatatypes/{name}":{
      "get":{
        "tags":[
          "SQL"
        ],
        "operationId":"GetSqlSysDatatypes",
        "description":"Get SqlSysDatatypes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/SqlSysDatatypes"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"SqlSysDatatypes not found."
          }
        }
      },
      "put":{
        "tags":[
          "SQL"
        ],
        "operationId":"PutSqlSysDatatypes",
        "description":"Update SqlSysDatatypes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"SqlSysDatatypes to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/SqlSysDatatypes"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"SqlSysDatatypes to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "SQL"
        ],
        "operationId":"DeleteSqlSysDatatypes",
        "description":"Delete SqlSysDatatypes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"SqlSysDatatypes deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"SqlSysDatatypes not found."
          }
        }
      }
    },
    "/sqlsysdatatypes":{
      "get":{
        "tags":[
          "SQL"
        ],
        "operationId":"GetListSqlSysDatatypes",
        "description":"Get List Of SqlSysDatatypes.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfSqlSysDatatypes"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "SQL"
        ],
        "operationId":"PostSqlSysDatatypes",
        "description":"Create SqlSysDatatypes.",
        "parameters":[
          {
            "name":"model",
            "description":"SqlSysDatatypes to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/SqlSysDatatypes"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"SqlSysDatatypes created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"SqlSysDatatypes already exists."
          }
        }
      }
    },
    "/sqluserdatatypes/{name}":{
      "get":{
        "tags":[
          "SQL"
        ],
        "operationId":"GetSqlUserDatatypes",
        "description":"Get SqlUserDatatypes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/SqlUserDatatypes"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"SqlUserDatatypes not found."
          }
        }
      },
      "put":{
        "tags":[
          "SQL"
        ],
        "operationId":"PutSqlUserDatatypes",
        "description":"Update SqlUserDatatypes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"SqlUserDatatypes to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/SqlUserDatatypes"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"SqlUserDatatypes to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "SQL"
        ],
        "operationId":"DeleteSqlUserDatatypes",
        "description":"Delete SqlUserDatatypes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"SqlUserDatatypes deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"SqlUserDatatypes not found."
          }
        }
      }
    },
    "/sqluserdatatypes":{
      "get":{
        "tags":[
          "SQL"
        ],
        "operationId":"GetListSqlUserDatatypes",
        "description":"Get List Of SqlUserDatatypes.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfSqlUserDatatypes"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "SQL"
        ],
        "operationId":"PostSqlUserDatatypes",
        "description":"Create SqlUserDatatypes.",
        "parameters":[
          {
            "name":"model",
            "description":"SqlUserDatatypes to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/SqlUserDatatypes"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"SqlUserDatatypes created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"SqlUserDatatypes already exists."
          }
        }
      }
    },
    "/startup":{
      "get":{
        "tags":[
          "System settings"
        ],
        "operationId":"GetStartup",
        "description":"Get Startup.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Startup"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Startup not found."
          }
        }
      },
      "put":{
        "tags":[
          "System settings"
        ],
        "operationId":"PutStartup",
        "description":"Update Startup.",
        "parameters":[
          {
            "name":"model",
            "description":"Startup to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Startup"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Startup to update not found."
          }
        }
      }
    },
    "/telnet":{
      "get":{
        "tags":[
          "System settings"
        ],
        "operationId":"GetTelnet",
        "description":"Get Telnet.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Telnet"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Telnet not found."
          }
        }
      },
      "put":{
        "tags":[
          "System settings"
        ],
        "operationId":"PutTelnet",
        "description":"Update Telnet.",
        "parameters":[
          {
            "name":"model",
            "description":"Telnet to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Telnet"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Telnet to update not found."
          }
        }
      }
    }
  },
  "definitions":{
    "ExportFilter":{
      "type":"object",
      "properties":{
      },
      "example":{
        "Namespaces":{
          "MYAPP":""
        },
        "MapGlobals":{
          "MYAPP":""
        },
        "MapPackages":{
          "MYAPP":""
        },
        "MapRoutines":{
          "MYAPP":""
        },
        "Security.Applications":{
          "/csp/zrestapp":"",
          "/csp/zwebapp":""
        },
        "Journal":"",
        "config":""
      }
    },
    "ListOfServices":{
      "type":"object",
      "properties":{
        "ListOfWebApps":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/Services"
          }
        }
      }
    },
    "Services":{
      "type":"object",
      "properties":{
        "AutheEnabled":{
          "type":"string",
          "default":0,
          "description":"Authentication methods enabled for the service<br>\r\nBit 0 = AutheK5CCache<br>\r\nBit 1 = AutheK5Prompt<br>\r\nBit 2 = AutheK5API<br>\r\nBit 3 = AutheK5KeyTab<br>\r\nBit 4 = AutheOS<br>\r\nBit 5 - AutheCache<br>\r\nBit 6 = AutheUnauthenticated<br>\r\nBit 7 = AutheKB<br>\r\nBit 8 = AutheKBEncryption<br>\r\nBit 9 = AutheKBIntegrity<br>\r\nBit 10 = AutheSystem<br>\r\nBit 11 = AutheLDAP<br>\r\nBit 13 = AutheDelegated<br>\r\nBit 14 = AutheLoginToken<br>\r\nBits 15-19 reserved<br>\r\nBit 20 = TwoFactorSMS<br>\r\nBit 21 = TwoFactorPW<br>"
        },
        "ClientSystems":{
          "type":"string",
          "default":"",
          "description":"List of valid IP addresses allowed to connect for this service."
        },
        "Description":{
          "type":"string",
          "default":"",
          "description":"Full name of the service"
        },
        "Enabled":{
          "type":"boolean",
          "default":0,
          "description":"Service enabled"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the service"
        }
      },
      "required":[
        "Description",
        "Name"
      ],
      "example":{
        "Description":"",
        "Name":""
      }
    },
    "ListOfWebApplication":{
      "type":"object",
      "properties":{
        "ListOfWebApps":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/WebApplication"
          }
        }
      }
    },
    "WebApplication":{
      "type":"object",
      "properties":{
        "AutheEnabled":{
          "type":"string",
          "default":64,
          "description":"Authentication and Session mechanisms enabled (CSP Only).<br>\r\nBit 2 = AutheK5API<br>\r\nBit 5 - AutheCache<br>\r\nBit 6 = AutheUnauthenticated<br>\r\nBit 11 = AutheLDAP<br>\r\nBit 13 = AutheDelegated<br>\r\nBit 14 = LoginToken<br>\r\nBit 20 = TwoFactorSMS<br>\r\nBit 21 = TwoFactorPW<br>"
        },
        "AutoCompile":{
          "type":"boolean",
          "default":1,
          "description":"This specifies whether CSP files should automatically compile or not (CSP Only).<br>\r\nIf this is turned on, then when a CSP file is more recent than its compiled class,<br>\r\nit is recompiled. This is normally something you would turn on in development environments<br>\r\nand turn off in production environments."
        },
        "CSPZENEnabled":{
          "type":"boolean",
          "default":1,
          "description":"Indicates whether this application will process CSP/Zen Pages (CSP Only)."
        },
        "CSRFToken":{
          "type":"boolean",
          "default":0,
          "description":"Prevent login CSRF attack (CSP only).<br>\r\nWhen enabled generate a token and cookie in the login page that is validated before accepting \r\nany username/password. Enabling this will prevent programatic access to pages in this application \r\nthat just pass in the username/password on the initial request. "
        },
        "ChangePasswordPage":{
          "type":"string",
          "default":"",
          "description":"A predefined change password page that can be sent out to the browser if the user account requires<br>\r\nthat a password change is required(CSP Only).<br>"
        },
        "ClientApplications":{
          "type":"string",
          "default":"",
          "description":"List of time stamps and hash values for valid executables (Client Applications Only).\r\nEach element is in the form $zdatetime($h,3)^HashValue"
        },
        "CookiePath":{
          "type":"string",
          "default":"",
          "description":"Scope of the session cookie (CSP Only).<br>\r\nThis determines which urls the browser will send the session cookie back to InterSystems IRIS.<br>\r\nIf your application name is 'myapp', it defaults to '/myapp/' meaning it will only send<br>\r\nthe cookie for pages under '/myapp/'. You should restrict this to only what is required<br>\r\nby your application to prevent this session cookie being used by other CSP application<br>\r\non this machine, or from being seen by any other application on this web server.<br>"
        },
        "DeepSeeEnabled":{
          "type":"boolean",
          "default":0,
          "description":"Indicates whether DeepSee access is enabled for this application"
        },
        "Description":{
          "type":"string",
          "default":"",
          "description":"Application description.<br>"
        },
        "DispatchClass":{
          "type":"string",
          "default":"",
          "description":"If defined this will dispatch all requests in this CSP application to this one class.\r\nThis will bypass the normal url to classname conversion so allowing the specified\r\nclass complete control over this dispatch of the page. A predefined dispatch class\r\nthat can be used is 'CSP.REST' which provides REST dispatch capabilities."
        },
        "Enabled":{
          "type":"boolean",
          "default":1,
          "description":"Application is enabled.<br>"
        },
        "ErrorPage":{
          "type":"string",
          "default":"",
          "description":"A CSP or CLS page that will be displayed if an error occurs when generating the page (CSP Only).<br>"
        },
        "EventClass":{
          "type":"string",
          "default":"",
          "description":"This specifies the class whose methods are invoked for CSP application events,<br>\r\nsuch as a timeout (CSP Only)."
        },
        "GroupById":{
          "type":"string",
          "default":"",
          "description":"Indicates whether this application's authentication will move in sync with other applications in the same id group (CSP Only)."
        },
        "InbndWebServicesEnabled":{
          "type":"boolean",
          "default":1,
          "description":"Indicates whether this application will process Web Services (CSP Only)."
        },
        "IsNameSpaceDefault":{
          "type":"boolean",
          "default":0,
          "description":"Indicates that this application is the default application for its namespace. \r\nAs such it will be returned by the call $System.CSP.GetDefaultApp()"
        },
        "LockCSPName":{
          "type":"boolean",
          "default":1,
          "description":"Lock CSP Name (CSP Only). <br>\r\nIf true then you can only access this CSP page if the url you enter matches\r\nthe url stored in the CSPURL parameter value in the class. CSP pages have\r\nthe CSPURL set to the original url requested automatically when they are\r\ncompiled. If the url does not match you get a page not found error. For\r\nexample if you have two CSP applications defined that both map to the same\r\nnamespace and the same directory '/A' and '/B'. Then you view '/A/page.csp'\r\nthis will load this page and create the class 'csp.page' with the CSPURL\r\nparameter set to '/A/page.csp'. With this flag set you may only access this\r\npage using the url '/A/page.csp'. If this flag is false you may access it\r\nvia the pages '/B/page.csp', '/A/csp.page.cls', '/B/csp.page.cls'.  Note that the flag is checked on\r\nthe application associated with the CSPURL parameter, so even if the '/B'\r\napplication has the flag turned off, if the '/A' application has it turned\r\non you will get a page not found error from '/B/page.csp'. If you modify the\r\nCSP class and change the CSPURL=\"\" then this disables checking for this\r\npage."
        },
        "LoginPage":{
          "type":"string",
          "default":"",
          "description":"A predefined login page that can be sent out to the browser if the application requires<br>\r\nan authenticated identity and one is not available yet (CSP Only).<br>"
        },
        "MatchRoles":{
          "type":"string",
          "default":"",
          "description":"Mapping of Match Roles to added Target Roles.<br>\r\nMatchRoles are in the format:<br>\r\nMatchRole:TargetRole1:TargetRole2<br>\r\nTo specify a role to always be granted to an application, set\r\nMatchRole=\"\", i.e. (:TargetRole1)<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Short Name for Application. \r\nWeb applications should start with a  \"/\".<br>\r\nClient Applications are in the format AppName.EXE.<br>\r\nPrivileged routines can be any format.<br>"
        },
        "NameSpace":{
          "type":"string",
          "default":"",
          "description":"The namespace where pages for this application are run (CSP Only).<br>"
        },
        "Package":{
          "type":"string",
          "default":"",
          "description":"Specifies the package to prefix to the class name for all CSP files in this application.<br>\r\nIf not specified it defaults to \"csp\" (CSP Only).<br>"
        },
        "Path":{
          "type":"string",
          "default":"",
          "description":"This specifies the physical path (directory) for the CSP files on the InterSystems IRIS server (CSP Only).<br>"
        },
        "PermittedClasses":{
          "type":"string",
          "default":"",
          "description":"A name pattern which is used by the CSP Server to limit the classes which may be run in this application. <br>\r\nThis is a COS pattern, (1\"B\",1\"A\".1N) match {B.cls, A0.cls ... A9.cls} <br>"
        },
        "Recurse":{
          "type":"boolean",
          "default":1,
          "description":"This specifies whether to use subdirectories (CSP Only).<br>\r\nIf WPath is the Web Path and PPath is the Physical Path, then with recurse turned on,<br>\r\nWPath/xxx/yyy will look in PPath/xxx/yyy. If recurse is turned off, only files directly<br>\r\ncontained in WPath are used."
        },
        "Resource":{
          "type":"string",
          "default":"",
          "description":"The Resource name that controls access to this application.<br>\r\nIf no resource is defined, then it is a public application which\r\nanyone can run.<br>"
        },
        "Routines":{
          "type":"string",
          "default":"",
          "description":"List of Routines that can invoke this application (Privileged routine applications only).<br>\r\nThese are in the format Routine/Class:dbname:Flag, where dbname is \r\nthe name of the database where the routine resides; Flag=0 is a routine, Flag=1 is a class name."
        },
        "ServeFiles":{
          "type":"integer",
          "default":1,
          "description":"Allows the web server built into InterSystems IRIS to serve up static files, e.g., html or jpg files,<br>\r\nfrom this application path (CSP Only).<br>\r\nThis also allows the stream server to serve files from this path.<br>\r\n0 - No - Never serve files from this application path<br>\r\n1 - Always - Always serve files from this application path, ignore CSP security setting for this path for static files. This is the default for new applications as it is backward compatible with serving files from the web server.<br>\r\n2 - Always and cached - Always serve files from this application path and allow the CSP gateway to cache these files to avoid having to request them from InterSystems IRIS. This is the mode we expect deployed application to use<br>\r\n3 - Use CSP security - If the user has permissions to view a csp/cls page in this application then allow them to view a static file, if they do not have permissions to view a csp/cls page then return a 404 page not found page.<br>"
        },
        "ServeFilesTimeout":{
          "type":"integer",
          "default":3600,
          "description":"Time, in seconds, of how long to cache static files.<br>"
        },
        "SessionScope":{
          "type":"integer",
          "default":2,
          "description":"SameSite value that is used for CSP Session cookies.<br>\r\nThis setting affects whether session cookies are sent for cross-site requests. <br>\r\nThe default setting for a new application is Strict.<br>\r\n0 - None - Send cookie with cross-site requests .<br>\r\n1 - Lax - Send cookie with top-level cross-site navigation. <br>\r\n2 - Strict - Do not send cookie with cross-site requests. <br>"
        },
        "SuperClass":{
          "type":"string",
          "default":"",
          "description":"This specifies the default superclass (CSP Only).<br>\r\nIf blank, it defaults to %CSP.Page.<br>"
        },
        "Timeout":{
          "type":"integer",
          "default":900,
          "description":"This specifies the default session timeout, in seconds (CSP Only).<br>"
        },
        "Type":{
          "type":"string",
          "default":2,
          "description":"Type - Bitmap describing the type of application<br>\r\nBit 0 = System Application - Reserved<br>\r\nBit 1 = CSP Application (Default)<br>\r\nBit 2 = Privileged routine application<br>\r\nBit 3 - Client Application<br>"
        },
        "UseCookies":{
          "type":"integer",
          "default":2,
          "description":"This specifies whether to use cookies for CSP session management or not (CSP Only).<br>\r\nYou can set this on a per-application basis. It does NOT affect the user's use of<br>\r\ncookies in their application, simply how the session is managed. The available<br>\r\noptions are:<br>\r\n'Never' use cookies - This will just use the CSPCHD parameter to persist the session<br>\r\nstate from page to page and will not send a cookie to the browser at all.<br>\r\n'AutoDetect' (the default) - This will start by sending the cookie to the browser and<br>\r\nalso including the CSPCHD parameter in all the links and forms. Then when the user clicks<br>\r\non the next link if the browser accepted the cookie it will switch to the 'Always'<br>\r\nmode and turn off the use of the CSPCHD parameters. If the browser did not accept<br>\r\nthe cookie it will turn into the 'Never' mode.<br>\r\n'Always' use cookies - Do not include the CSPCHD parameter.<br>\r\n0 = Never, 1 = AutoDetect, 2 = Always"
        },
        "UserCookieScope":{
          "type":"integer",
          "default":2,
          "description":"Default SameSite value for cookies created by users' calls to %CSP.Response.SetCookie().<br>\r\nThis setting affects whether session cookies are sent for cross-site requests. <br>\r\nUsers can override the default by specifying the SameSite value in their SetCookie call.<br>\r\n0 - None - Send cookie with cross-site requests .<br>\r\n1 - Lax - Send same-site cookies with top-level cross-site navigation. <br>\r\n2 - Strict - Do not send same-site cookies with cross-site requests. "
        },
        "iKnowEnabled":{
          "type":"boolean",
          "default":0,
          "description":"Indicates whether iKnow access is enabled for this application"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "AutheEnabled":"32",
        "AutoCompile":true,
        "CSPZENEnabled":true,
        "CSRFToken":false,
        "ChangePasswordPage":"",
        "CookiePath":"/api/config/",
        "DeepSeeEnabled":true,
        "Description":"",
        "DispatchClass":"Api.Config.REST.disp",
        "Enabled":true,
        "ErrorPage":"",
        "EventClass":"",
        "GroupById":"",
        "InbndWebServicesEnabled":true,
        "IsNameSpaceDefault":false,
        "LockCSPName":true,
        "LoginPage":"",
        "MatchRoles":"",
        "Name":"/api/config",
        "NameSpace":"USER",
        "Package":"",
        "Path":"",
        "PermittedClasses":"",
        "Recurse":true,
        "Resource":"",
        "ServeFiles":1,
        "ServeFilesTimeout":3600,
        "SessionScope":2,
        "SuperClass":"",
        "Timeout":900,
        "Type":"2",
        "UseCookies":2,
        "UserCookieScope":2,
        "iKnowEnabled":true
      }
    },
    "ListOfDirectory":{
      "type":"object",
      "properties":{
        "ListOfDirectory":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/Directory"
          }
        }
      }
    },
    "Directory":{
      "type":"object",
      "properties":{
        "BlockFormat":{
          "type":"integer",
          "default":2
        },
        "BlockSize":{
          "type":"integer",
          "default":""
        },
        "Blocks":{
          "type":"integer",
          "default":0
        },
        "BlocksPerMap":{
          "type":"integer",
          "default":0
        },
        "ClusterMountMode":{
          "type":"boolean",
          "default":0
        },
        "ClusterMounted":{
          "type":"boolean",
          "default":0
        },
        "CompressionEngine":{
          "type":"integer",
          "default":0
        },
        "CurrentMaps":{
          "type":"integer",
          "default":""
        },
        "Directory":{
          "type":"string",
          "default":""
        },
        "DirectoryBlock":{
          "type":"integer",
          "default":3
        },
        "EncryptedDB":{
          "type":"boolean",
          "default":0
        },
        "EncryptionKeyID":{
          "type":"string",
          "default":""
        },
        "Expanding":{
          "type":"boolean",
          "default":0
        },
        "ExpansionSize":{
          "type":"integer",
          "default":0
        },
        "Full":{
          "type":"boolean",
          "default":0
        },
        "GlobalJournalState":{
          "type":"string",
          "default":""
        },
        "InActiveMirror":{
          "type":"boolean",
          "default":0
        },
        "LastExpansionTime":{
          "type":"string",
          "default":0
        },
        "MaxSize":{
          "type":"integer",
          "default":0
        },
        "MirrorActivationRequired":{
          "type":"boolean",
          "default":0
        },
        "MirrorDBCatchup":{
          "type":"boolean",
          "default":0
        },
        "MirrorDBCreatedNew":{
          "type":"boolean",
          "default":0
        },
        "MirrorDBName":{
          "type":"string",
          "default":""
        },
        "MirrorDBPaused":{
          "type":"boolean",
          "default":0
        },
        "MirrorFailoverDB":{
          "type":"boolean",
          "default":0
        },
        "MirrorNoWrite":{
          "type":"boolean",
          "default":0
        },
        "MirrorObsolete":{
          "type":"boolean",
          "default":0
        },
        "MirrorSetName":{
          "type":"string",
          "default":""
        },
        "Mirrored":{
          "type":"boolean",
          "default":0
        },
        "Mounted":{
          "type":"boolean",
          "default":0
        },
        "NewGlobalCollation":{
          "type":"string",
          "default":5
        },
        "NewGlobalGrowthBlock":{
          "type":"integer",
          "default":50
        },
        "NewGlobalIsKeep":{
          "type":"boolean",
          "default":0
        },
        "NewGlobalPointerBlock":{
          "type":"integer",
          "default":16
        },
        "NumberOfConfigDB":{
          "type":"integer",
          "default":0
        },
        "ROReasonCode":{
          "type":"integer",
          "default":0
        },
        "ROReasonText":{
          "type":"string",
          "default":""
        },
        "ReCreate":{
          "type":"boolean",
          "default":0
        },
        "ReadOnly":{
          "type":"boolean",
          "default":0
        },
        "ReadOnlyMounted":{
          "type":"boolean",
          "default":0
        },
        "Reinitialize":{
          "type":"boolean",
          "default":0
        },
        "RequestSize":{
          "type":"integer",
          "default":0
        },
        "ResourceName":{
          "type":"string",
          "default":""
        },
        "RunCatchupDBOnCreate":{
          "type":"boolean",
          "default":1
        },
        "SFN":{
          "type":"integer",
          "default":""
        },
        "Size":{
          "type":"integer",
          "default":1
        },
        "Skeleton":{
          "type":"boolean",
          "default":0
        },
        "SparseDB":{
          "type":"boolean",
          "default":0
        }
      },
      "example":{
        "Directory":"/usr/irissys/mgr/user/ztestapidata/",
        "ExpansionSize":0,
        "NewGlobalCollation":"5",
        "ReadOnly":false
      }
    },
    "ConfigDocument":{
      "type":"object",
      "example":{
        "Defaults":{
          "DBDIR":"${MGRDIR}",
          "WEBAPPDIR":"${CSPDIR}",
          "DBDATA":"${DBDIR}myappdata/",
          "DBARCHIVE":"${DBDIR}myapparchive/",
          "DBCODE":"${DBDIR}myappcode/",
          "DBLOG":"${DBDIR}myapplog/"
        },
        "SYS.Databases":{
          "${DBDATA}":{
            "ExpansionSize":128
          },
          "${DBARCHIVE}":{
          },
          "${DBCODE}":{
          },
          "${DBLOG}":{
          }
        },
        "Databases":{
          "MYAPPDATA":{
            "Directory":"${DBDATA}"
          },
          "MYAPPCODE":{
            "Directory":"${DBCODE}"
          },
          "MYAPPARCHIVE":{
            "Directory":"${DBARCHIVE}"
          },
          "MYAPPLOG":{
            "Directory":"${DBLOG}"
          }
        },
        "Namespaces":{
          "MYAPP":{
            "Globals":"MYAPPDATA",
            "Routines":"MYAPPCODE"
          }
        },
        "Security.Applications":{
          "/csp/zrestapp":{
            "DispatchClas":"my.dispatch.class",
            "Namespace":"MYAPP",
            "Enabled":"1",
            "AuthEnabled":"64",
            "CookiePath":"/csp/zrestapp/"
          },
          "/csp/zwebapp":{
            "Path":"${WEBAPPDIR}zwebapp/",
            "Namespace":"MYAPP",
            "Enabled":"1",
            "AuthEnabled":"64",
            "CookiePath":"/csp/zwebapp/"
          }
        },
        "MapGlobals":{
          "MYAPP":[
            {
              "Name":"Archive.Data",
              "Database":"MYAPPARCHIVE"
            },
            {
              "Name":"App.Log",
              "Database":"MYAPPLOG"
            }
          ]
        },
        "MapPackages":{
          "MYAPP":[
            {
              "Namespace":"MYAPP",
              "Name":"PackageName",
              "Database":"USER"
            }
          ]
        },
        "MapRoutines":{
          "MYAPP":[
            {
              "Namespace":"MYAPP",
              "Name":"RoutineName",
              "Database":"USER"
            }
          ]
        },
        "Journal":{
          "FreezeOnError":1
        },
        "Security.Services":{
          "%Service_Mirror":{
            "Enabled":0
          }
        },
        "SQL":{
          "LockThreshold":2500
        },
        "config":{
          "locksiz":33554432
        },
        "Startup":{
          "SystemMode":"DEVELOPMENT"
        }
      }
    },
    "Roles":{
      "type":"object",
      "properties":{
        "Description":{
          "type":"string",
          "default":"",
          "description":"Description of the role."
        },
        "GrantedRoles":{
          "type":"string",
          "default":"",
          "description":"Roles assigned to the Role."
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Role Name"
        },
        "Resources":{
          "type":"string",
          "default":"",
          "description":"Resource/Permission pairs the role holds"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "Name":"RoleName"
      }
    },
    "Resources":{
      "type":"object",
      "properties":{
        "Description":{
          "type":"string",
          "default":"",
          "description":"Description of the resource.<br>\r\nDescription cannot be modified if a system defined resource.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the resource.<br>"
        },
        "PublicPermission":{
          "type":"string",
          "default":0,
          "description":"Public permissions on the resource.<br>\r\nBit 0 - Read<br>\r\nBit 1 - Write<br>\r\nBit 2 - Use<br>"
        },
        "Type":{
          "type":"string",
          "default":0,
          "description":"Type - Bitmap describing the type of resource.<br>\r\nBit 0 = System initialized resource<br>\r\nBit 1 = Database resource<br>\r\nBit 2 = Service resource<br>\r\nBit 3 - Application resource<br>\r\nBit 4 - DeepSee resource<br>\r\nBits 5-30 reserved<br>\r\nBit 31 = User defined Resource<br>\r\nBits 31-64 user defined <Reserved for future use><br>\r\nNote that this property is set automatically by the filer and should\r\nnot be set for user defined resources.<br>\r\nDo not modify this field directly except on initialization of system defaults."
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "Name":""
      }
    },
    "Cluster":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "CommIPAddress":{
          "type":"string",
          "default":"",
          "description":"Defines the IP Address to advertise in the PIJ to the other cluster members.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "JoinCluster":{
          "type":"boolean",
          "default":0,
          "description":"Set to True if this configuration is part of a cluster.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "CommIPAddress":"",
        "JoinCluster":false
      }
    },
    "ConfigFile":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "Product":{
          "type":"string",
          "default":"IRIS",
          "description":""
        },
        "Version":{
          "type":"string",
          "default":"",
          "description":"Version of the CPF file.<br>"
        }
      },
      "required":[
        "Name",
        "Version"
      ],
      "example":{
        "Product":"IRIS",
        "Version":"2020.4"
      }
    },
    "Databases":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "ClusterMountMode":{
          "type":"boolean",
          "default":0,
          "description":" Specifies whether the database should be mounted privately or clustered.<br>\r\n 0 - Mount private<br>\r\n 1 - Mount clustered<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Directory":{
          "type":"string",
          "default":"",
          "description":" Directory where the database resides.<br><br>\r\n On ECP Clients of a mirror this contains logical references to the databases on the\r\n failover miror memebers as the path may be different on the various nodes. <br>\r\n This has two forms:<br>\r\n &nbsp&nbsp&nbsp&nbsp&nbsp:mirror:&ltmirror name&gt:&ltmirror database name&gt <br>\r\n &nbsp&nbsp&nbsp&nbsp&nbsp:ds:&ltconfig database name&gt <br>\r\n <br>\r\n The 1st form, :mirror:&ltmirror name&gt:&ltmirror database name&gt, refers to a mirrored database. The mirror\r\n database name is the internal mirror name assigned to the database when it was added to\r\n the mirror. This is generally the same as the database name in the configuration.\r\n <br><br>\r\n The 2nd form, :ds:&ltconfig database name&gt, refers to a non-mirrored database on the server.\r\n The config database name is the name of the database in the configuration and this database name\r\n is expected to exist on all of the failover members. This form is only used in special circumstances\r\n as normally non-mirrored databases are hosted on the ECP Client, not the ECP Server. This is used\r\n in cases where scratch data (eg. the data will be lost during a mirror failover) needs to be hosted\r\n on the server for some reason."
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "MountAtStartup":{
          "type":"boolean",
          "default":0,
          "description":" On a clustered system, specifies whether the database should be mounted at startup.<br>\r\n This property is valid for cluster systems only, and is ignored \r\n for non-cluster systems.<br>\r\n 0 - Don't mount at startup<br>\r\n 1 - Mount at startup<br>"
        },
        "MountRequired":{
          "type":"boolean",
          "default":0,
          "description":" Specifies that the database MUST be successfully mounted at startup.<br>\r\n 0 - Successful mount not required for startup to succeed.<br>\r\n 1 - Successful mount required for startup to succeed.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "Server":{
          "type":"string",
          "default":"",
          "description":" Name of the remote server where the DB resides.<br>\r\n If empty, the database is local.<br>\r\n Remote server must already be configured to be entered here.<br>"
        },
        "StreamLocation":{
          "type":"string",
          "default":"",
          "description":" Directory where the streams associated with this database go.<br>\r\n By default (value=\"\"), the location is in the subdirectory \"stream\", underneath the\r\n database directory, e.g. for a database located in c:\\abc, the default would be\r\n c:\\abc\\stream. InterSystems recommends leaving this parameter as \"\".<br>"
        }
      },
      "required":[
        "Directory",
        "Name"
      ],
      "example":{
        "ClusterMountMode":false,
        "Directory":"/usr/irissys/mgr/user/",
        "MountAtStartup":false,
        "MountRequired":false,
        "Name":"USER",
        "Server":"",
        "StreamLocation":""
      }
    },
    "ListOfDatabases":{
      "type":"object",
      "properties":{
        "Databases":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/Databases"
          }
        }
      }
    },
    "Debug":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "Name":""
      }
    },
    "ListOfDebug":{
      "type":"object",
      "properties":{
        "Debug":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/Debug"
          }
        }
      }
    },
    "DeviceSubTypes":{
      "type":"object",
      "properties":{
        "Backspace":{
          "type":"string",
          "default":"",
          "description":"Enter the ASCII code that represents the backspace character on the selected<br>\r\ndevice in this form: $C(code1). Default depends on the device type.<br>"
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "CursorControl":{
          "type":"string",
          "default":"",
          "description":"Enter the cursor control keys for the selected device.<br>\r\nDefault depends on the device type.<br>"
        },
        "EraseEOF":{
          "type":"string",
          "default":"",
          "description":"Enter the ASCII code that represents erasing to the end of file on the<br>\r\nselected device in this form: $C(code1,code2...).<br>\r\nDefault depends on the device type.<br>"
        },
        "EraseEOL":{
          "type":"string",
          "default":"",
          "description":"Enter the ASCII code that represents erasing to the end of line on this device<br>\r\nin the form $C(code1,code2).<br>\r\nDefault depends on the device type.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "FormFeed":{
          "type":"string",
          "default":"",
          "description":"Enter the ASCII code that represents a form feed on the selected device in this form:<br>\r\n#,$C(code1,code2...).<br>\r\nDefault depends on the device type.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "RightMargin":{
          "type":"integer",
          "default":80,
          "description":"Enter the number that represents the location of the right margin.<br>\r\nDevice output will wrap at that number of characters.<br>\r\nDefault depends on the device type.<br>"
        },
        "ScreenLength":{
          "type":"integer",
          "default":0,
          "description":"Enter the number of lines that comprise one screen or page for the device.<br>"
        },
        "ZU22Backspace":{
          "type":"string",
          "default":"",
          "description":"Enter the ASCII code that represents a backspace on the selected device in the form $C(code).<br>\r\nDefault depends on the device type.<br>"
        },
        "ZU22FormFeed":{
          "type":"string",
          "default":"",
          "description":"Enter the ASCII code that represents a form feed on the selected device in the form $C(code1,code2).<br>\r\nDefault depends on the device type.<br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "Backspace":"",
        "CursorControl":"",
        "EraseEOF":"",
        "EraseEOL":"",
        "FormFeed":"",
        "Name":"ZDEVSUB",
        "RightMargin":80,
        "ScreenLength":0,
        "ZU22Backspace":"",
        "ZU22FormFeed":""
      }
    },
    "ListOfDeviceSubTypes":{
      "type":"object",
      "properties":{
        "DeviceSubTypes":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/DeviceSubTypes"
          }
        }
      }
    },
    "Devices":{
      "type":"object",
      "properties":{
        "Alias":{
          "type":"integer",
          "default":"",
          "description":"Alternate device ID (number) for this device. <br>\r\nAll aliases must be unique. You can use this value to specify a device in an OPEN command, e.g 0PEN 210<br>"
        },
        "AlternateDevice":{
          "type":"string",
          "default":"",
          "description":"Device ID of an alternate device.<br>\r\nThis allows a user using %IS to specify A as the device.\r\nThe alternate device must be a defined mnemonic.<br>"
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Description":{
          "type":"string",
          "default":"",
          "description":"Enter a description of where the device is located. This field is for your<br>\r\nown reference to help you identify what machine you're configuring.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "OpenParameters":{
          "type":"string",
          "default":"",
          "description":"Values that will be sent as the second argument for an OPEN command.<br>\r\nThis value allows you to specify more specific terminal information.<br>"
        },
        "PhysicalDevice":{
          "type":"string",
          "default":"",
          "description":"Physical device name used to refer to the device.<br>"
        },
        "Prompt":{
          "type":"integer",
          "default":"",
          "description":"Number of the prompt option desired.<br>\r\nOptions:<br>\r\nNULL (blank) = user sees the device selection prompt with the default device defined<br>\r\n1 = automatically uses this device, if it is the current device<br>\r\n2 = automatically uses this device with predefined Right Margin and Parameter settings.<br>"
        },
        "SubType":{
          "type":"string",
          "default":"",
          "description":"Options to refine the definition of your device SubTypes.<br>\r\nSubTypes specify terminal charactistics. They are used to create the appropriate\r\nOPEN command for the device. There should be SubType information for every terminal type.<br>"
        },
        "Type":{
          "type":"string",
          "default":"",
          "description":"Enter the type of device.<br>\r\nOptions:<br>\r\nTRM = Terminal<br>\r\nSPL = Spooling device<br>\r\nMT = Magnetic Tape drive<br>\r\nBT = Cartridge tape drive<br>\r\nIPC = Interprocess communication<br>\r\nOTH = any other device including printers and sequential files.<br>\r\nDefault depends on the device type.<br>"
        }
      },
      "required":[
        "Name",
        "PhysicalDevice",
        "SubType",
        "Type"
      ],
      "example":{
        "Name":"",
        "PhysicalDevice":"",
        "SubType":"",
        "Type":""
      }
    },
    "ListOfDevices":{
      "type":"object",
      "properties":{
        "Devices":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/Devices"
          }
        }
      }
    },
    "ECP":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "ClientReconnectDuration":{
          "type":"integer",
          "default":1200,
          "description":"How long a client should keep trying to re-establish a connection before giving up\r\nor declaring connection failed (in seconds).<br>"
        },
        "ClientReconnectInterval":{
          "type":"integer",
          "default":5,
          "description":"When a server is not available, how long to wait between each reconnection attempt (in seconds).<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "ServerTroubleDuration":{
          "type":"integer",
          "default":60,
          "description":"Duration a connection will stay in troubled state (in seconds).\r\nOnce this period of time has elapsed, the server will declare the connection dead and\r\npresume recovery is not possible.<br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "Name":""
      }
    },
    "ECPServers":{
      "type":"object",
      "properties":{
        "Address":{
          "type":"string",
          "default":"",
          "description":"IP Address to connect to.<br>"
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "MirrorConnection":{
          "type":"integer",
          "default":0,
          "description":"Specifies the behavior of this connection with regard to mirrored database servers.\r\n<p>\r\nValue:\r\n<li>0: Non-mirrored connection.  Access databases on non-mirror members.  Also\r\nused to connect to async members to access mirror databases, configured by\r\ntheir database paths.\r\n<li>1: Mirrored connection. ECP will automatically find the primary mirror\r\nmember and will only connect to the primary. Access to mirrored databases \r\nis configured by mirror database name.</li>\r\n<li>-1: Mirrored connection restricted to the configured mirror member only. The\r\nconfigured member is the one specified by <PROPERTY>Address</PROPERTY> and\r\n<PROPERTY>Port</PROPERTY>. Like value '1', a connection will be established \r\nif the configured member is primary and access to mirrored databases is\r\nconfigured by mirror database name. Unlike '1', if the configured member is\r\na Disaster Recovery member, the connection will be established, allowing\r\nread-only access to mirrored databases. If the DR member is promoted, the \r\nconnection will be dropped and will be re-established when it becomes primary. \r\n<b>Warning</b>: This setting is not appropriate in typical configurations where\r\n mirroring will automatically fail over, as the new primary won't be found.\r\nThis is for use in specialized DR configurations, or other long-distance\r\nconfigurations, to prevent the application server from being automatically \r\nredirected to a primary in a different data center while allowing local \r\nread-only access. There is no system utility to set the value of '-1', but it\r\ncan be specified via this class interface.</li>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "Port":{
          "type":"integer",
          "default":1972,
          "description":"IP Port to connect to.<br>"
        },
        "SSLConfig":{
          "type":"integer",
          "default":0,
          "description":"Use SSL configuration (%ECPClient) for the ECP connection.<br>"
        }
      },
      "required":[
        "Address",
        "Name"
      ],
      "example":{
        "Address":"",
        "Name":""
      }
    },
    "ListOfECPServers":{
      "type":"object",
      "properties":{
        "ECPServers":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/ECPServers"
          }
        }
      }
    },
    "IO":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "File":{
          "type":"string",
          "default":"^%X364",
          "description":"Routine to use in WRITE commands for sequential files.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "MagTape":{
          "type":"string",
          "default":"^%XMAG",
          "description":"Routine to use in WRITE commands for magnetic tapes.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "Other":{
          "type":"string",
          "default":"^%X364",
          "description":"Routine to use in WRITE commands for Other devices.<br>"
        },
        "Terminal":{
          "type":"string",
          "default":"^%X364",
          "description":"Routine to use in WRITE commands for terminals.<br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "File":"^%X364",
        "MagTape":"^%XMAG",
        "Other":"^%X364",
        "Terminal":"^%X364"
      }
    },
    "Journal":{
      "type":"object",
      "properties":{
        "AlternateDirectory":{
          "type":"string",
          "default":"",
          "description":"Alternate journal directory.<br>"
        },
        "BackupsBeforePurge":{
          "type":"integer",
          "default":2,
          "description":"Number of backups before the journal files are automatically purged.<br>"
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "CurrentDirectory":{
          "type":"string",
          "default":"",
          "description":"Primary journal directory.<br>"
        },
        "DaysBeforePurge":{
          "type":"integer",
          "default":2,
          "description":"Number of days before the journal files are purged.<br>"
        },
        "FileSizeLimit":{
          "type":"integer",
          "default":1024,
          "description":"Maximum size of each journal file in MB.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "FreezeOnError":{
          "type":"boolean",
          "default":0,
          "description":"Freeze the system if there is an error writing to the journal.<br>\r\nIf this option is set to true (1), as soon as the error occurs all global activities \r\nthat are normally journaled are blocked, which causes other jobs to block. \r\nThe typical outcome is that the system goes into a hang state until the journaling problem is \r\nresolved, and then resumes running. While InterSystems IRIS is hanging, the administrator can take \r\ncorrective measures, such as freeing up space on a disk that is full, switching the journal \r\nto a new disk, etc. This option has the advantage that once the problem is fixed and \r\nInterSystems IRIS resumes running, no journal information has been lost. \r\nIt has the disadvantage that the system is less available while the problem is being solved.<br>\r\nIf this option is set to false (0), when a journaling error occurs journaling is \r\nentirely disabled, while the system continues running as normal. \r\nThe system sends a console message to alert the administrator, who can fix the problem and then\r\nrun ^JRNSWTCH at the console to restart journaling. "
        },
        "JournalFilePrefix":{
          "type":"string",
          "default":"",
          "description":"Prefixes journal file names with this string.<br>\r\nMay be used to distinguish journal files from different instances in the same directory.<br>"
        },
        "JournalcspSession":{
          "type":"boolean",
          "default":0,
          "description":"%cspSession global will be mapped to the TEMP database and not journaled.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "AlternateDirectory":"/usr/irissys/mgr/journal/",
        "BackupsBeforePurge":2,
        "CurrentDirectory":"/usr/irissys/mgr/journal/",
        "DaysBeforePurge":2,
        "FileSizeLimit":1024,
        "FreezeOnError":false,
        "JournalFilePrefix":"",
        "JournalcspSession":false
      }
    },
    "LicenseServers":{
      "type":"object",
      "properties":{
        "Address":{
          "type":"string",
          "default":"127.0.0.1",
          "description":"IP Address of the license server.<br>"
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "KeyDirectory":{
          "type":"string",
          "default":"",
          "description":"Directory used to load license keys for distribution. At startup of a local\r\nLicense Server, the system will attempt to load license keys from all *.key files\r\nin this directory. These keys can then be requested by other Instances using this\r\nLicense Server."
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "Port":{
          "type":"integer",
          "default":4002,
          "description":"IP Port of the license server.<br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "Address":"127.0.0.1",
        "KeyDirectory":"",
        "Port":4002
      }
    },
    "ListOfLicenseServers":{
      "type":"object",
      "properties":{
        "LicenseServers":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/LicenseServers"
          }
        }
      }
    },
    "MagTapes":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "SystemDevice":{
          "type":"string",
          "default":"",
          "description":"Physical tape device name.<br>"
        }
      },
      "required":[
        "Name",
        "SystemDevice"
      ],
      "example":{
        "Name":"54",
        "SystemDevice":"/dev/st1m"
      }
    },
    "ListOfMagTapes":{
      "type":"object",
      "properties":{
        "MagTapes":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/MagTapes"
          }
        }
      }
    },
    "MapGlobals":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Collation":{
          "type":"integer",
          "default":5,
          "description":"Default collation of the global"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Database":{
          "type":"string",
          "default":"",
          "description":"Database to map global to.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<var>Bit $$$CPFSave</var> - Save object to disk.<br>\r\n<var>Bit $$$CPFWrite</var> - Write CPF file from object.<br>\r\n<var>Bit $$$CPFActivate</var> - Activate object into memory if CPFFile is the same as what is currently active.<br>"
        },
        "LockDatabase":{
          "type":"string",
          "default":"",
          "description":"Database to map global lock to.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the mapping.<br>"
        },
        "Namespace":{
          "type":"string",
          "default":"",
          "description":"Namespace where the mapping is.<br>"
        }
      },
      "required":[
        "Database",
        "Name",
        "Namespace"
      ],
      "example":{
        "Collation":5,
        "Database":"ENSLIB",
        "LockDatabase":"ENSLIB",
        "Name":"EnsDICOM.Dictionary",
        "Namespace":"USER"
      }
    },
    "ListOfMapGlobals":{
      "type":"object",
      "properties":{
        "MapGlobals":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/MapGlobals"
          }
        }
      }
    },
    "MapMirrors":{
      "type":"object",
      "properties":{
        "AgentAddress":{
          "type":"string",
          "default":"",
          "description":"Network address (IP address preferred to avoid DNS issues)\r\nmirror members which connect to the primary should use to \r\ncontact the Agent on this failover member. This is omitted\r\nreporting members as the agent is not used for mirroring\r\non those systems. This is required on failover members. This\r\nfield does not need to be specified on DR members although it will\r\nneed to be filled in before promotion of the DR to a Failover member. \r\nIt is best to configure the agent and the address information earlier \r\nrather than later.\r\n<br><br>\r\nThe agent can transfer journal data so a private address may\r\nbe desirable here to avoid network congestion. "
        },
        "AgentPort":{
          "type":"integer",
          "default":"",
          "description":"Port # which the agent on this system is configured to listen\r\non. <classmethod>##class(SYS.Agent).GetApplicationPort()</classmethod>\r\nwill return the current value if the local agent is active."
        },
        "AsyncMemberType":{
          "type":"integer",
          "default":0,
          "description":"AsyncMemberType indicates the async member is a disaster recovery (DR), read-only reporting or read-write reporting async member.<br>\r\n0 - Disaster Recovery (DR). This is a disaster recovery async member, all its mirrored databases are read-only mirrored databases.<br>\r\n1 - Read-Only Reporting. This is a reporting async member, all its mirrored databases could be read-only or read-write databases, the default is read-only when the database is\r\ncreated.<br>\r\n2 - Read-Write Reporting. This is a reporting async member, all its mirrored databases could be read-only or read-write databases, the default is read-write when the database is\r\ncreated.<br>"
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "ConnectsTo":{
          "type":"string",
          "default":"",
          "description":"Reserved for future use."
        },
        "DejournalFilter":{
          "type":"string",
          "default":"",
          "description":"The name of the filter class for mirror dejournaling, null string means the dejournal filter is disabled. <br> \r\nThis property is meaningful only for Reporting Async members. "
        },
        "ECPAddress":{
          "type":"string",
          "default":"",
          "description":"This is the superserver address referenced in the documentation for this \r\ninstance. External mirror-aware systems can connect to the primary using \r\nthis address. Currently the only such external systems are ECP application \r\nservers connecting to failover members. This is distributed to\r\nthe ECP clients, along with the address for the other failover member\r\n(if there is one) when an ECP client builds a connection to a mirror. \r\n<br><br>\r\nOther mirror members may also make connections to a member's superserver \r\naddress for certain control and monitoring purposes. When a member is primary, \r\nasync members attempt to establish their data channel to the member using this \r\naddress if the mirror private address is not accessible, which means that \r\njournal data may travel over the network via this address.\r\n<br><br>\r\nThis a required field on failover members, optional on others."
        },
        "EncryptCommunication":{
          "type":"integer",
          "default":0,
          "description":"When SSL is not required by <Property>Config.Mirrors.UseSSL</Property> mirror wide\r\nsetting, this property controls whether this member uses SSL for its outgoing\r\nconnections and/or whether it requires SSL for its incoming connections. Whenever SSL is\r\nused to encrypt a connection, the endpoints also perform authorization and verify that the\r\nDN name in the SSL configuration matches the listed <property>SSLComputerName</property>\r\nfor that system in the Mirror configuration.\r\n<br><br>\r\nValues are:\r\n<ul>\r\n <li><p>0 - Encryption is not required. Outgoing connections may still be\r\n            encrypted if the member we connect to requires SSL for incoming\r\n            connections.\r\n\t\t\t</p></li>\r\n <li><p>1 - SSL is used to encrypt outgoing connections.\r\n            the server must have an SSL Mirror configuration or the\r\n            connection will fail\r\n            </p></li>\r\n <li><p>2 - Encryption is required for incoming connections. The clients\r\n            which connect must have an SSL Mirror configuration or the\r\n            connection will fail\r\n            </p></li>\r\n <li><p>3 - Both 1+2: Outgoing connections are encrypted, encryption is\r\n            required for incoming connections\r\n            </p></li>\r\n</ol>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<var>Bit $$$CPFSave</var> - Save object to disk.<br>\r\n<var>Bit $$$CPFWrite</var> - Write CPF file from object.<br>\r\n<var>Bit $$$CPFActivate</var> - Activate object into memory if CPFFile is the same as what is currently active.<br>"
        },
        "GUID":{
          "type":"string",
          "default":"",
          "description":"Uniquely identifies this node in the mirror. Apart from identifying\r\nthe nodes, primary used to identify the instance that owns a particular \r\ncopy of a mirrored database."
        },
        "ID":{
          "type":"string",
          "default":"",
          "description":"ID where the mapping is.<br>"
        },
        "InstanceDirectory":{
          "type":"string",
          "default":"",
          "description":"The installation directory of the instance (the parent of the mgr directory).\r\nUsed primarily on failover members to identify the instance to the agent"
        },
        "MemberType":{
          "type":"integer",
          "default":0,
          "description":"Numeric value indicating the type of mirror member.\r\n<br><br>\r\n0 - Failover member<br>\r\n1 - &ltreserved for future use&gt<br>\r\n2 - Async member (doesn't accept client connections)<br>\r\n(defined in %syMirror.inc as FailoverMemberType, AsyncMemberType)"
        },
        "MirrorAddress":{
          "type":"string",
          "default":"",
          "description":"Address (IP preferred to avoid DNS troubles) the other mirror members\r\nshould use to contact the superserver on this instance. \r\nWhen a InterSystems IRIS instance is running as the primary failover member, \r\neach of the other mirror members uses the mirror private address to \r\nestablish its mirror data channel, the channel over which it receives \r\njournal data from the primary and the most heavily used mirror \r\ncommunication channel. \r\n<br><br>\r\nFailover members are restricted in that they can only use this address\r\nfor establishing the connection to receive live updates. Async members\r\nattempt to use this address to connect to the primary but fall back to\r\nthe superserver address (<property>ECPAddress</property> property) if necessary.\r\n<br><br>\r\nThis documentation refers to ths property as the Mirror Private Address."
        },
        "MirrorSSPort":{
          "type":"integer",
          "default":"",
          "description":"SuperServer port for this instance. Used in conjunction with both the\r\n<property>MirrorAddress</property> and the <property>ECPAddress</property>\r\nby clients establishing connections to this instance."
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"This is the name of this instance in the mirror. Mirror system names\r\nmust be unique (enforced by Enterprise Manager) across all of the mirrors which \r\nthe EM manages, as an instance has a single mirror system name which \r\nmay appear in multiple mirror sets (eg. a reporting member may connect\r\nto multiple mirrors). For the most part the <property>GUID </property>\r\nis used to identify a mirror member, the Name is used for display \r\npurposes. \r\n<br><br>\r\nThe name must not contain a colon (':') and is converted to uppercase before\r\nsaving."
        },
        "SSLComputerName":{
          "type":"string",
          "default":"",
          "description":"Value of the DN field in the SSL certificate which is part of\r\nthe %Mirror SSL configuration on this instance. When SSL is enabled\r\nan instance sends this value as part of establishing a TCP connection. Both\r\nsides of the connection verify that the other side's DN value matches a value\r\nstored in the configuration. It is best for every mirror member to have a unique\r\nDN value as otherwise it may be possible for a system that was removed from the\r\nmirror to still connect if it's DN value matches the DN stored with another system\r\nof the same type (eg. async v. failover). "
        }
      },
      "required":[
        "GUID",
        "ID",
        "InstanceDirectory",
        "MirrorAddress",
        "MirrorSSPort",
        "Name"
      ],
      "example":{
        "GUID":"",
        "ID":"",
        "InstanceDirectory":"",
        "MirrorAddress":"",
        "MirrorSSPort":0,
        "Name":""
      }
    },
    "ListOfMapMirrors":{
      "type":"object",
      "properties":{
        "MapMirrors":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/MapMirrors"
          }
        }
      }
    },
    "MapPackages":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Database":{
          "type":"string",
          "default":"",
          "description":"Database to map Package to.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<var>Bit $$$CPFSave</var> - Save object to disk.<br>\r\n<var>Bit $$$CPFWrite</var> - Write CPF file from object.<br>\r\n<var>Bit $$$CPFActivate</var> - Activate object into memory if CPFFile is the same as what is currently active.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the mapping.<br>"
        },
        "Namespace":{
          "type":"string",
          "default":"",
          "description":"Namespace where the mapping is.<br>"
        }
      },
      "required":[
        "Database",
        "Name",
        "Namespace"
      ],
      "example":{
        "Database":"ENSLIB",
        "Name":"EnsLib",
        "Namespace":"USER"
      }
    },
    "ListOfMapPackages":{
      "type":"object",
      "properties":{
        "MapPackages":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/MapPackages"
          }
        }
      }
    },
    "MapRoutines":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Database":{
          "type":"string",
          "default":"",
          "description":"Database to map routine to.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<var>Bit $$$CPFSave</var> - Save object to disk.<br>\r\n<var>Bit $$$CPFWrite</var> - Write CPF file from object.<br>\r\n<var>Bit $$$CPFActivate</var> - Activate object into memory if CPFFile is the same as what is currently active.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the mapping.<br>"
        },
        "Namespace":{
          "type":"string",
          "default":"",
          "description":"Namespace where the mapping is.<br>"
        }
      },
      "required":[
        "Database",
        "Name",
        "Namespace"
      ],
      "example":{
        "Database":"ENSLIB",
        "Name":"Ens*",
        "Namespace":"USER"
      }
    },
    "ListOfMapRoutines":{
      "type":"object",
      "properties":{
        "MapRoutines":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/MapRoutines"
          }
        }
      }
    },
    "MapShadows":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Directory":{
          "type":"string",
          "default":"",
          "description":"Database to map global to.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<var>Bit $$$CPFSave</var> - Save object to disk.<br>\r\n<var>Bit $$$CPFWrite</var> - Write CPF file from object.<br>\r\n<var>Bit $$$CPFActivate</var> - Activate object into memory if CPFFile is the same as what is currently active.<br>"
        },
        "ID":{
          "type":"string",
          "default":"",
          "description":"ID where the mapping is.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the mapping.<br>"
        }
      },
      "required":[
        "Directory",
        "ID",
        "Name"
      ],
      "example":{
        "Directory":"",
        "ID":"",
        "Name":""
      }
    },
    "ListOfMapShadows":{
      "type":"object",
      "properties":{
        "MapShadows":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/MapShadows"
          }
        }
      }
    },
    "MirrorMember":{
      "type":"object",
      "properties":{
        "AgentAddress":{
          "type":"string",
          "default":"",
          "description":""
        },
        "AsyncMemberGUID":{
          "type":"string",
          "default":"",
          "description":""
        },
        "AsyncMemberType":{
          "type":"integer",
          "default":0,
          "description":"AsyncMemberType indicates the async member is a disaster recovery (DR), read-only reporting or read-write reporting async member.<br>\r\n0 - Disaster Recovery (DR). This is a disaster recovery async member, all its mirrored databases are read-only mirrored databases.<br>\r\n1 - Read-Only Reporting. This is a reporting async member, all its mirrored databases could be read-only or read-write databases, the default is read-only when the database is\r\ncreated.<br>\r\n2 - Read-Write Reporting. This is a reporting async member, all its mirrored databases could be read-only or read-write databases, the default is read-write when the database is\r\ncreated.<br>"
        },
        "AsyncUseSystemPurgeInterval":{
          "type":"boolean",
          "default":0,
          "description":"AsyncUseSystemPurgeInterval when set indicates that the async member should\r\npurge mirror journal files according to the same criteria it uses for purging\r\nlocal journal files (eg. after a certain number of days or a certain number\r\nof backups). When this parameter is missing, or clear, the default state, mirror\r\njournal files are purged as soon as they are no longer needed because they\r\nhave been replayed to the local databases and/or sent on to the various clients\r\nthat connect (if this is a relay member)."
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "JoinMirror":{
          "type":"boolean",
          "default":0,
          "description":"Flag indicating whether this system processes its mirror configuration\r\nat startup. When set to NO, the mirror configuration is ignored and the\r\nsystem is not considered a mirror member. This can be used if there is a \r\nproblem in the configuration which prevents the system from starting or\r\nas part of removing a system from the mirror as if a system is the primary\r\nit needs to be restarted but we also need to block the system from joining\r\nthe mirror when it restarts and becoming the primary again."
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "SystemName":{
          "type":"string",
          "default":"",
          "description":"This is the name by which the system is known in the mirror (the mirror \r\nmember name). The name is converted to uppercase before storing. \r\nThe following characters are not permitted in mirror system names:\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: # , ; = ^ ~ \" &ltspace&gt &lttab&gt \r\n<br>\r\nThe following character sequences are not allowed in mirror system names:\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;/*  \r\n<br>\r\n\r\nMirror system names must be unique across all\r\nmirror members as some mirror members (eg. relay and async members) may\r\nparticipate in multiple mirrors and they will have the same system name\r\nin all of the mirrors."
        },
        "VirtualAddressInterface":{
          "type":"string",
          "default":"",
          "description":"When the mirror is configured to keep a virtual ip address assigned\r\nto the primary, this is the local interface which hosts the IP address.<br><br>\r\nConsult the documentation for the format specific to the operating system.<br><br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "AgentAddress":"",
        "AsyncMemberGUID":"",
        "AsyncMemberType":0,
        "AsyncUseSystemPurgeInterval":false,
        "JoinMirror":false,
        "SystemName":"",
        "VirtualAddressInterface":""
      }
    },
    "Mirrors":{
      "type":"object",
      "properties":{
        "AllowParallelDejournaling":{
          "type":"integer",
          "default":0,
          "description":"Determines the type of mirror members can run parallel dejournaling updaters.\r\n<br>\r\n0 - Failover and Disaster Recover members.<br>\r\n1 - Failover members only.<br>\r\n2 - All members including Failover, Disaster Recovery and Reporting Async members.<br>\r\n<br>"
        },
        "ArbiterNode":{
          "type":"string",
          "default":"",
          "description":"An address for the arbiter node used by this mirror.<br>\r\nThe arbiter node is used by the failover members as an observer to provide\r\ninformation to an active backup that allows it to take over when the agent\r\non the primary cannot be contacted (eg. the primary loses power).<br><br>"
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "CompressionForAsyncMembers":{
          "type":"integer",
          "default":0,
          "description":"Determines whether journal data is compressed before being transmitted to async members (disaster recovery and reporting).\r\n<br>\r\n0 - System Selected: The system will use a compression strategy expected to balance network utilization with performance.<br>\r\n1 - Uncompressed: No compression will be used.<br>\r\n2 - Compressed: Compression will be used.<br>\r\n<br>"
        },
        "CompressionForFailoverMembers":{
          "type":"integer",
          "default":0,
          "description":"Determines whether journal data is compressed before being transmitted between failover members.\r\n<br>\r\n0 - System Selected: The system will use compression only in configurations where it is expected to improve the response time for synchronization between the primary and backup.<br>\r\n1 - Uncompressed: No compression will be used.<br>\r\n2 - Compressed: Compression will be used.<br>\r\n<br>"
        },
        "CompressionTypeForAsyncMembers":{
          "type":"integer",
          "default":0,
          "description":"Compress type when CompressionForAsyncMembers is set to 'Compressed' mode. It is meanlinless if CompressionForAsyncMembers is not 'Compressed' mode.\r\n<br>\r\n0 - ZLIB.<br>\r\n1 - ZSTD.<br>\r\n2 - LZ4.<br>\r\n<br>"
        },
        "CompressionTypeForFailoverMembers":{
          "type":"integer",
          "default":0,
          "description":"Compress type when CompressionForFailoverMembers is set to 'Compressed' mode. It is meanlinless if CompressionForFailoverMembers is not 'Compressed' mode.\r\n<br>\r\n0 - ZLIB.<br>\r\n1 - ZSTD.<br>\r\n2 - LZ4.<br>\r\n<br>"
        },
        "DefinedPrimary":{
          "type":"string",
          "default":"",
          "description":"Field used internally when mirror failover is disabled, \r\ngenerally for maintenance purposes. Manipulated via the nofailover options\r\nwhen shutting down InterSystems IRIS. This contains the mirror system name of the node\r\nwhich is allowed to become the primary. It is cleared automatically when that\r\nnode starts up and becomes the primary (eg. starting it NOSTU will not clear\r\nthis field). This can also be set and cleared manually via ^MIRROR."
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "GUID":{
          "type":"string",
          "default":"",
          "description":"Internal GUID which is unique to this mirror"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Mirror names are uppercase (alphanumeric)\r\nName of the mirror, restricted to 15 uppercase alphanumeric characters. \r\nMust be unique across the mirrors managed by the EMS"
        },
        "QOSTimeout":{
          "type":"integer",
          "default":8000,
          "description":"Contains the time in milliseconds which the primary will wait for the backup\r\nto acknowledge receipt of a chunk of journal data before the primary\r\nmarks the backup as inactive."
        },
        "UseSSL":{
          "type":"boolean",
          "default":0,
          "description":"Yes/No field for whether the mirror uses to encrypt the communication \r\nbetween members for every mirror connection. \r\nWhen set to Yes the Mirror SSL configuration is used for client/server connections by this\r\nnode. When set to No, encryption setting are controlled on a per-connection basis via\r\n<property>Config.MapMirrors.EncryptCommunication</property> and by\r\n<property>Config.MapMirrors.RequireEncryption MapMirrors</property>.\r\n<br><br>\r\nSetting this field to Yes forces <property>RequireAuthentication</property> to be set to \r\nYes and <property>RequireAuthentication</property> cannot be set to No while this field is\r\nenabled.\r\n<br><br>\r\nThis must be enabled when journal files are encrypted on the \r\nfailover mirror members or when there are any encrypted mirrored databases."
        },
        "VirtualAddress":{
          "type":"string",
          "default":"",
          "description":"Optional Virtual IP address which the mirror maintains pointing to the\r\ncurrent primary. When this is specified the failover members must be\r\nconfigured to host the Virtual IP on one of their interfaces. This is used\r\nby TCP/IP Client applications to connect to the primary mirror member."
        }
      },
      "required":[
        "GUID",
        "Name"
      ],
      "example":{
        "GUID":"",
        "Name":""
      }
    },
    "ListOfMirrors":{
      "type":"object",
      "properties":{
        "Mirrors":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/Mirrors"
          }
        }
      }
    },
    "Miscellaneous":{
      "type":"object",
      "properties":{
        "AsyncDisconnectErr":{
          "type":"boolean",
          "default":0,
          "description":"This setting modifies the behavior of InterSystems IRIS when DisconnectErr is enabled.<br>\r\n0 - The process receives a <DSCON> error at the next read or write command.<br>\r\n1 - The process receives an asynchronous <DSCON> error at the time a disconnect occurs on the device. This error will occur at the next command executed. Hang commands will be interrupted. <br>\r\nAsyncDisconnectError is only applicable to Telnet connections on Windows. It has no effect on any other device type or operating system. If DisconnectErr is set to 0 (false), then AsyncDisconnectError has no effect. "
        },
        "AsynchError":{
          "type":"boolean",
          "default":1,
          "description":"Enable processes to receive asynchronous errors.<br>\r\n0 - Processes cannot receive asynchronous errors.<br>\r\n1 - Processes can receive asynchronous errors.<br>\r\nThis setting applies to ECP networking. "
        },
        "BreakMode":{
          "type":"boolean",
          "default":1,
          "description":"Process action when debug BREAK command executed.<br>\r\n0 - Breaks are ignored.<br>\r\n1 - Breaks are taken.<br>"
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "CollectResourceStats":{
          "type":"boolean",
          "default":0,
          "description":"Controls whether the system resource statistics are updated or not (seize, nseize, \r\naseize, bseize).<br>\r\n0 - Statistics are not collected<br>\r\n1 - Statistics are collected.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "DX":{
          "type":"boolean",
          "default":0,
          "description":"Sets $X update mode for escape sequences system-wide.<br>\r\nYou can control the way the system updates $X when writing a string containing an escape sequence. \r\nDefault behaviors for various system implementations are as follows: <br>\r\nUNIX - parses the ANSI standard escape sequence and counts the rest of the non-escape \r\ncharacters in the string against $X. <br>\r\nVMS - Do not count any more characters in the string against $X as soon as they encounter an \r\nescape character ($CHAR(27)). <br>\r\nOpen M [DSM] - Counts all characters in a string, including the escape character, against $X.<br>\r\nOpen M [DTM] and Open M [MSM] - Count all characters except for the escape character against $X.<br>\r\nA numeric code that controls a nondefault, consistent, system-wide way of updating $X.<br>\r\n0 - Use UNIX default behavior on system. <br>\r\n1 = Use Open M [DSM] default behavior on system.<br> \r\n2 = Use Open M [DTM]/Open M [MSM] default behavior on system.<br> \r\n3 = Use OpenVMS Alpha default behavior on system. <br>\r\nThe default behavior on UNIX zero (0).<br> \r\nThe default behavior on VMS is three (3).<br>"
        },
        "DisconnectErr":{
          "type":"boolean",
          "default":0,
          "description":"Enable a process to receive disconnect errors.<br>\r\nThis setting conditions how a process responds to a disconnect of the principal \r\nI/O device. <br>\r\nBe aware that when error on disconnect is enabled, a process continues to execute after \r\nits principal device has been disconnected. It is the responsibility of the application to \r\ndetect the disconnect condition and exit gracefully. Use care when enabling error on disconnect. \r\nThe application must be prepared to recognize the <DSCON> error and handle it appropriately \r\nin error traps. Error on disconnect is only applicable to TCP devices and to terminal devices \r\nwhere a disconnect can be recognized. Examples are modem controlled terminals and Windows \r\nTelnet, Windows LAT, and Windows local cterm (TRM:) connections. Error on disconnect is only \r\napplicable to the principal device.\r\n0 - Process exits without reporting an error to the application when a disconnect is detected.<br>\r\n1 - Process receives a <DSCON> error when a disconnect is detected during a Write or Read command.<br>"
        },
        "FileMode":{
          "type":"boolean",
          "default":0,
          "description":"Create a file if it does not exist when called with Write or Read/Write.<br>\r\nWhen 0 (false) and a file is opened for writing that does not exist, a new file is not created \r\nunless the N parameter was provided with the OPEN command.<br>\r\nWhen 1 (true) and a file is opened for writing that does not exist, a new file is created.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "GlobalKillEnabled":{
          "type":"boolean",
          "default":1,
          "description":"Enable KILL of an unsubscripted global.<br>\r\n0 - KILL of an unsubscripted global results in a <PROTECT> error.\r\n1 - KILL of an unsubscripted global is allowed, so you can kill all subscripts of a global with a single kill instead if killing them individually. "
        },
        "IEEEError":{
          "type":"boolean",
          "default":1,
          "description":"Enables or disables $DOUBLE returning INF and NAN values system-wide.<br>\r\nThis property sets the $DOUBLE function return value behavior system-wide. \r\nIf 0, $DOUBLE returns INF (infinity), -INF, and NAN (Not A Number) for unresolvable IEEE \r\nfloating point conversions. If 1, $DOUBLE generates ObjectScript errors for unresolvable IEEE \r\nfloating point conversions. The property controls the issuing of INF, -INF, and NAN when \r\na $DOUBLE numeric operation cannot be resolved to a numeric value. It does not control\r\nthe issuing of INF, -INF, and NAN in all cases. $DOUBLE always returns INF, -INF, or \r\nNAN when you supply one of these strings as the input value, regardless of this property.\r\nMathematical operations on $DOUBLE numbers that result in an INF, -INF, or NAN are controlled \r\nby this property. These include arithmetic operations, exponentiation, and logarithmic and \r\ntrigonometric functions. <br>\r\n0 - $DOUBLE returns INF, -INF, or NAN when given an unresolvable numeric expression. <br>\r\n1 - $DOUBLE generates <MAXNUMBER>, <ILLEGAL VALUE>, and <DIVIDE> errors when given an unresolvable numeric expression."
        },
        "LineRecall":{
          "type":"boolean",
          "default":1,
          "description":"Enable command line recall for READ commands. <br>\r\nRead line recall is only used by terminal devices.<br>\r\nThe OPEN command sets the read line recall mode for a terminal. You can specify the \r\nR protocol (enable) or the N protocol (disable). If neither protocol is specified, \r\nOPEN takes its setting from the current default established by %SYS.ProcessQuery.LineRecall,\r\nthis property. The USE command can specify the R protocol (enable) or the N protocol (disable) \r\nto change the OPEN mode. If neither protocol is specified, USE takes its setting from the \r\ninitial OPEN mode value.\r\nAn implicit open of an active device, such as issuing a BREAK command, reopens the device \r\nin the same mode as the initial OPEN command. \r\nModifying this property does not override an OPEN or USE setting for an active terminal. \r\nTo change read line recall for an already open terminal device, you must explicitly reopen \r\nthe device. You can use this property  or %SYS.ProcessQuery.LineRecall to change the default, \r\nthen issue an OPEN 0 command, which reopens the active terminal device, applying the current \r\ndefault. See Terminal I/O in InterSystems IRIS I/O Device Guide for details on using protocols. <br><br>\r\nRead Line Recall<br>\r\nRead line recall mode provides line recall of editable lines as input for READ operations \r\nfrom a terminal. These recallable lines include both previous READ input lines and previous \r\ncommand lines. Echoing of input lines is a necessary precondition for read line recall. \r\nThe system supports read line recall for both variable-length terminal reads (READ var) \r\nand fixed-length terminal reads (READ var#n). The system does not support read line recall \r\nfor single-character terminal reads (READ *var). For a fixed-length terminal read, the \r\nrecalled line is truncated to one character less than the number of characters specified in \r\nthe READ. This final READ character position is reserved for typing a line termination \r\ncharacter, specifying an edit character, or adding one more data character. \r\nWhen read line recall is active, you can provide input to a READ by using the Up Arrow and \r\nDown Arrow keys to recall a previous terminal input line. You can then use the Left Arrow,\r\nRight Arrow, Home, and End keys to position the cursor for editing the recalled line. \r\nYou can use the Backspace key to delete a character, Ctrl-X to delete the entire line, \r\nor Ctrl-U to delete all of the line to the left of the cursor. \r\nWhen read line recall is not active, the four Arrow keys, the Home key, and the End key \r\nall issue a line termination character. You can use the Backspace key to delete a single \r\ninput character, and Ctrl-X (or Ctrl-U) to delete the entire input line. Read line recall \r\ncan be deactivated by using the -R protocol, or by specifying the N, I, S, or T protocols, \r\nas described in the Terminal I/O chapter of the InterSystems IRIS I/O Device Guide. <br><br>\r\n0 - Command line recall is not enabled.<br>\r\n1 - Command line recall is enabled.<br>"
        },
        "ListFormat":{
          "type":"integer",
          "default":0,
          "description":"Enable compression of some $LIST types.<br>\r\nThe value is bit flags controlling these types:<br>\r\n1 - Compress IEEE floating point values ($DOUBLE)<br>\r\n2 - Compress Unicode strings"
        },
        "LogRollback":{
          "type":"boolean",
          "default":0,
          "description":"Enable logging for transaction rollbacks.<br>\r\n0 - Do not log transaction rollbacks.<br>\r\n1 - Log transaction rollbacks to the console log file.<br>"
        },
        "MVDefined":{
          "type":"boolean",
          "default":0,
          "description":"Sets MVBasic handling of undefined variables system-wide.<br>\r\nThis property function defines MVBasic behavior when it encounters a reference to an \r\nundefined variable. By default, if an MVBasic routine references an undefined variable, \r\nThe system generates an <UNDEFINED> error. You can change this default behavior to have \r\nthe system substitute an empty string for an undefined variable, without signaling an error.<br> \r\n0 - issue an <UNDEFINED> error for an undefined variable.<br>\r\n1 - substitute the empty string for an undefined variable.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "NodeNameInPid":{
          "type":"boolean",
          "default":0,
          "description":"Behavior when there is a reference to the special variable $JOB. <br>\r\n0 - $JOB returns only the process ID number. \r\n1 - $JOB returns the process ID number of the current process, concatenated to the nodename."
        },
        "NullSubscripts":{
          "type":"boolean",
          "default":0,
          "description":"Enable null subscript references.<br>\r\n0 - Throw <SUBSCRIPT> error when referencing a null subscript.<br>\r\n1 - Null subscript references do not throw an error.<br>"
        },
        "OldZU5":{
          "type":"boolean",
          "default":0,
          "description":"When switching namespace to the same namespace via $namespace or ZN, clear global vectors.<br>\r\n0 - Switching to the same namespace is a NOOP.<br>\r\n1 - Switching to the same namespace clears the globals vector cache.<br>"
        },
        "OpenMode":{
          "type":"integer",
          "default":0,
          "description":"The read/write mode you want used when opening sequential files and no mode is specified in the OPEN command.<br>\r\n0 - Read<br>\r\n1 - Read-Write<br>"
        },
        "PopError":{
          "type":"boolean",
          "default":0,
          "description":"When to pop $ZTRAP error handlers off the stack.<br><br>\r\nWhen a $ZTRAP error handler is invoked by the system, that error handler remains on the stack of\r\nestablished error handlers. Therefore, if an error occurs when the error handler is executing,\r\nthat error handler attempts to invoke itself, receives the same error again and enters an\r\ninfinite loop, unless that error handler explicitly sets $ZTRAP to a new value.<br>\r\nWhen a $ZTRAP error handler is invoked in DSM, the error handler is removed from the stack. \r\nTherefore, if an error occurs while the error handler is executing, that error is handled \r\nby the previous error handler on the stack.<br><br>\r\n0 - Normal behavior: A $ZTRAP error handler stays active when the error handler is invoked.<br>\r\n1 - Pop the $ZTRAP error handler off the stack when an error is triggered (DSM compatibility mode). <br>"
        },
        "RefInKind":{
          "type":"boolean",
          "default":0,
          "description":"Result of $NAME and $QUERY when an extended global reference is the argument.<br>\r\n0 - Return the global with an extended reference. <br>\r\n1 - Return the global without reference to where it is on the network. <br>"
        },
        "ScientificNotation":{
          "type":"boolean",
          "default":1,
          "description":"Enables or disables lowercase \"e\" as scientific notation symbol system-wide.<br>\r\n0 - Disable lowercase \"e\".<br>\r\n1 - Enable lowercase \"e\".<br>"
        },
        "SetZEOF":{
          "type":"boolean",
          "default":0,
          "description":"Behavior when the system encounters an unexpected end-of-file when reading a sequential file.<br>\r\n0 - Throw an <ENDOFFILE> error.<br>\r\n1 - Set the special variable $ZEOF to indicate that you have reached the end of the file. <br>"
        },
        "ShutDownLogErrors":{
          "type":"boolean",
          "default":0,
          "description":"Write ^SYSLOG errors to the console log file at shutdown.<br>\r\n0 - Do not write ^SYSLOG errors.<br>\r\n1 - Write ^SYSLOG errors.<br>"
        },
        "StopID":{
          "type":"boolean",
          "default":0,
          "description":"Sets $ZF process deletion behavior for OpenVMS STOP/ID system-wide.<br>\r\nUsing the OpenVMS STOP/ID command to delete a process can cause your \r\nsystem to fail. For this reason, the system on OpenVMS systems prevent you \r\nfrom deleting processes with STOP/ID.\r\nFor processes that are executing $ZF functions, you may need to be able to delete \r\na process from OpenVMS. Set this value to 0 if you need to terminate processes in a $ZF function.<br>\r\n0 - Enable deletion of processes with STOP/ID.<br>\r\n1 - Disable deletion of processes with STOP/ID.<br>"
        },
        "SwitchOSdir":{
          "type":"boolean",
          "default":0,
          "description":"Behavior of the current working O/S directory when changing namespaces.<br>\r\n0 - When you change namespaces, the current working directory is changed to the directory of the default database of the new namespace. However, if this dataset is remote (networked to a different system), the current working directory is left unchanged.<br>\r\n1 - When you change namespaces, the current working directory remains unaltered no matter what namespace you switch to.<br>"
        },
        "SynchCommit":{
          "type":"boolean",
          "default":0,
          "description":"Synchronize TCOMMIT with the corresponding journal write operation.<br>\r\n0 - TCOMMIT does not wait for the write operation to complete. <br>\r\n1 - TCOMMIT does not complete until the journal data write operation completes. Note that setting this\r\nproperty to 1 will have performance implications.<br>"
        },
        "TelnetNUL":{
          "type":"boolean",
          "default":0,
          "description":"Suppress Telnet NUL at end-of-line system-wide.<br>\r\nThis property disables or enables the issuance of a NUL character (ASCII 0) following a CR \r\ncharacter (ASCII 13) at end-of-line during Telnet transmission on Windows systems only. It has\r\nno affect of Unix or VMS systems. On output, a Telnet network virtual terminal (NVT) \r\nperforms the following default end-of-line behavior: either issues a CR \r\n(carriage return character) followed by a LF (linefeed character), or issues a CR \r\n(carriage return character) followed by a NUL character (if no LF is issued). <br>\r\n0 - do not suppress NUL. <br>\r\n1 - suppress NUL. <br>"
        },
        "TruncateOverflow":{
          "type":"boolean",
          "default":0,
          "description":"Enable the <MAXNUMBER> error on numeric overflow.<br>\r\nWhen the system encounters a number larger than 9223372036854775807 E127 (or smaller than -9223372036854775808 E127) it throws the <MAXNUMBER> error. <br>\r\n0 - <MAXNUMBER> error is thrown.<br> \r\n1 - <MAXNUMBER> error is suppressed.<br> "
        },
        "Undefined":{
          "type":"integer",
          "default":0,
          "description":"ObjectScript response to undefined variables.<br>\r\n0 - Always throw an <UNDEFINED> error.<br>\r\n1 - If the undefined variable has subscripts, return a null string, but if the undefined variable is single-valued, throw an <UNDEFINED> error.<br>\r\n2 - Always return a null string.<br>"
        },
        "UseNagleAlgorithm":{
          "type":"boolean",
          "default":0,
          "description":"Enable the Nagle algorithm for Telnet (Windows only).<br>\r\n0 - Nagle algorithm is disabled.<br>\r\n1 - Nagle algorithm is enabled.<br>"
        },
        "ViewPastData":{
          "type":"boolean",
          "default":0,
          "description":"Enable $VIEW command to examine data outside of the InterSystems IRIS memory area.<br>\r\n0 - $VIEW command throws an error.<br>\r\n1 - $view command does not throw an error.<br>"
        },
        "ZDateNull":{
          "type":"boolean",
          "default":0,
          "description":"$ZDATE response to an invalid value. <br>\r\n0 - The valid range is from 0 through 2980013, inclusive, which corresponds to dates from \r\n12/31/1840 through 12/31/9999. This range can be restricted by setting the $ZDATE mindate \r\nand maxdate parameters. If the date is invalid, the error message <ILLEGAL VALUE> or \r\n<VALUE OUT OF RANGE> will be generated. The behavior can be overridden by supplying an \r\nerropt to the $ZDATE call. <br>\r\n1 - (ISM compatibility) The valid range is from 1 through 94232, inclusive, which corresponds to dates from 01/01/1841 \r\nthrough 12/30/2098. This date range is set for any $ZDATE function call which has three or \r\nfewer parameters. If a $ZDATE function call has more than three parameters, the valid date \r\nrange is taken either from the $ZDATE mindate and maxdate parameters (if specified) or \r\nfrom the date range established for the current locale. If the date is invalid, \r\n$ZDATE will return the null string if you submit an invalid date. This behavior is set for \r\nany $ZDATE function call, regardless of the number of parameters. "
        },
        "ZaMode":{
          "type":"boolean",
          "default":0,
          "description":"Determines how the ZALLOCATE (ZA) and ZDEALLOCATE (ZD) commands behave, according to InterSystems IRIS rules or DSM-11 rules.<br>\r\n0 - InterSystems IRIS rules, which means that ZA and ZD behave exactly like LOCK + and LOCK -.<br>\r\n1 - DSM-11 rules, which means that ZA locks can only be unlocked by ZD and LOCK + locks can only be unlocked by LOCK.<br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "AsyncDisconnectErr":false,
        "AsynchError":true,
        "BreakMode":true,
        "CollectResourceStats":false,
        "DisconnectErr":false,
        "FileMode":false,
        "GlobalKillEnabled":true,
        "IEEEError":true,
        "LineRecall":true,
        "ListFormat":0,
        "LogRollback":false,
        "MVDefined":false,
        "NodeNameInPid":false,
        "NullSubscripts":false,
        "OldZU5":false,
        "OpenMode":0,
        "PopError":false,
        "RefInKind":false,
        "ScientificNotation":true,
        "SetZEOF":false,
        "ShutDownLogErrors":false,
        "StopID":false,
        "SwitchOSdir":false,
        "SynchCommit":false,
        "TelnetNUL":false,
        "TruncateOverflow":false,
        "Undefined":0,
        "UseNagleAlgorithm":false,
        "ViewPastData":false,
        "ZDateNull":false,
        "ZaMode":false
      }
    },
    "Monitor":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "PatrolCollectionInterval":{
          "type":"integer",
          "default":30,
          "description":"** DEPRECATED - No longer Supported. **\r\nEnter the number of seconds between each time the system collects data and sends it to Patrol.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "PatrolDisplayMode":{
          "type":"integer",
          "default":0,
          "description":"** DEPRECATED - No longer Supported. **\r\nControl how the metric data is displayed in the Patrol console.<br>\r\n0 - 'Total' displays the total counts since the collection was started.<br>\r\n1 - 'Delta' displays the count for the last collection period.<br>\r\n2 - 'Rate' displays a calculated count per second.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "PatrolEnabled":{
          "type":"boolean",
          "default":0,
          "description":"** DEPRECATED - No longer Supported. **\r\nAautomatically starts the connection to Patrol when the system is started.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "PatrolTopProcesses":{
          "type":"integer",
          "default":20,
          "description":"** DEPRECATED - No longer Supported. **\r\nNumber of processes to be displayed in the Process Status window on the Patrol console.<br>\r\nThis will show the top processes as sorted by global or routine.<br>\r\nA value of 0 tells the PATROL utility to stop calculating the top processes.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "SNMPEnabled":{
          "type":"boolean",
          "default":0,
          "description":"Automatically starts the SNMP agent when the system is started.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "WMIEnabled":{
          "type":"boolean",
          "default":0,
          "description":"** DEPRECATED - No longer Supported. **\r\nIdentifies this configuration as one that should be monitored by the WMI DLL.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "PatrolCollectionInterval":30,
        "PatrolDisplayMode":0,
        "PatrolEnabled":false,
        "PatrolTopProcesses":20,
        "SNMPEnabled":false,
        "WMIEnabled":false
      }
    },
    "Namespaces":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "Globals":{
          "type":"string",
          "default":"",
          "description":"Default database for globals.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "Routines":{
          "type":"string",
          "default":"",
          "description":"Default database for routines.<br>"
        },
        "TempGlobals":{
          "type":"string",
          "default":"IRISTEMP",
          "description":"Default database for temporary globals.<br>"
        }
      },
      "required":[
        "Globals",
        "Name",
        "Routines"
      ],
      "example":{
        "Globals":"USER",
        "Name":"USER",
        "Routines":"USER",
        "TempGlobals":"IRISTEMP"
      }
    },
    "ListOfNamespaces":{
      "type":"object",
      "properties":{
        "Namespaces":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/Namespaces"
          }
        }
      }
    },
    "SQL":{
      "type":"object",
      "properties":{
        "ANSIPrecedence":{
          "type":"boolean",
          "default":1,
          "description":"Apply SQL92 operator precedence if this flag is set<br>"
        },
        "AllowRowIDUpdate":{
          "type":"boolean",
          "default":0,
          "description":"1 - The table compiler omits the checks to see if the RowID field(s) are being updated.<br>\r\n0 - The checks are performed."
        },
        "AutoParallel":{
          "type":"boolean",
          "default":1,
          "description":"Enable auto hinting for %PARALLEL<br>"
        },
        "AutoParallelThreshold":{
          "type":"integer",
          "default":3200,
          "description":"The threshold for auto hinting for %PARALLEL, the lower the value is, the higher the chance this query would be paralleded executed<br>"
        },
        "BiasQueriesAsOutlier":{
          "type":"boolean",
          "default":0,
          "description":"Set to 1 if queries on fields with non-null outliers often refer to the outlier.<br>"
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comment":{
          "type":"boolean",
          "default":1,
          "description":"Set the flag that determines if embedded SQL statements are retained as comments in the .INT code version of the routine.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "DBMSSecurity":{
          "type":"boolean",
          "default":1,
          "description":"Set the flag that determines if SQL security is enabled. If SQL security is ON, all SQL security is active. This means: Each user must specify a valid username and password when logging in through ODBC (or by setting the %msql variable directly); Privilege-based table/view security is active, and the user may only perform actions on a table or view they have been granted access to. If SQL Security is off: Any user may access SQL through ODBC, and may be prompted for a username/password but will not be validated; Privilege-based table/view security is suppressed, and user's may perform actions on tables and views to which they have not been given access.<br>"
        },
        "DDLDefineBitmapExtent":{
          "type":"boolean",
          "default":1,
          "description":"Sets the flag which determines if a class created by a DDL CREATE TABLE statement defines a bitmap extent index for the class.\r\nThis setting only applies to classes created through DDL that do not also define an explicit IdKey index.\r\nDDLDefineBitmapExtent=0 means a bitmap extent index will not be defined.\r\nDDLDefineBitmapExtent=1 means a bitmap extent index will be defined, if possible."
        },
        "DDLFinal":{
          "type":"boolean",
          "default":1,
          "description":"Sets the flag which determines if a class created by a DDL CREATE TABLE statement is Final.<br>\r\nDDLFinal=0 means the class created by the statement will not be defined as Final<br>\r\nDDLFinal=1 means the class created by the statement will be defined as Final.<br>"
        },
        "DDLNo201":{
          "type":"boolean",
          "default":0,
          "description":"Set the flag that determines if an SQLCODE -201 error is returned when an attempt is made to CREATE a previously existing table through DDL.<br>"
        },
        "DDLNo30":{
          "type":"boolean",
          "default":0,
          "description":"Set the flag that determines if an SQLCODE -30 error is returned when an attempt is made to DROP a non-existing table through DDL.<br>"
        },
        "DDLNo307":{
          "type":"boolean",
          "default":0,
          "description":"Set the flag that determines if an SQLCODE -307 error is returned when an attempt is made to a primary key constraint to a table through DDL, when a primary key constraint already exists for that table.<br>"
        },
        "DDLNo311":{
          "type":"boolean",
          "default":0,
          "description":"Setting this parameter to 'Yes' allows you to ADD a foreign key through DDL even if one with the same name already exists. Setting this parameter to 'No' disallows this action and returns an error code.<br>"
        },
        "DDLNo315":{
          "type":"boolean",
          "default":0,
          "description":"Set the flag that determines if an SQLCODE -315 error is returned when an attempt is made to DROP a non-existant constraint through DDL.<br>"
        },
        "DDLNo324":{
          "type":"boolean",
          "default":0,
          "description":"Set the flag that determines if an SQLCODE -324 error is returned when an attempt is made to CREATE a previously existing index through DDL.<br>"
        },
        "DDLNo333":{
          "type":"boolean",
          "default":0,
          "description":"Set the flag that determines if an SQLCODE -333 error is returned when an attempt is made to drop a non-existant index through DDL.<br>"
        },
        "DDLSQLOnlyCompile":{
          "type":"boolean",
          "default":0,
          "description":"1 - any class compilation performed as a result of executing a DDL statement will compile the class with the \"q\" (sqlonly) flag.<br>\r\n0 - the \"q\" flag is not used. This is the default."
        },
        "DDLUseExtentSet":{
          "type":"boolean",
          "default":1,
          "description":"Sets the flag which determines if a class created by a DDL CREATE TABLE statement defines the USEEXTENTSET class parameter to a value of 1.\r\nUSEEXTENTSET=1 will generally bind the table to better improving global names, especially the index globals.  It does mean the global names the class is mapped to is not a name that attempts to match the classname.\r\nSee documentation for USEEXTENTSET parameter for more information."
        },
        "DDLUseSequence":{
          "type":"boolean",
          "default":1,
          "description":"Sets the flag which determines if a class created by a DDL CREATE TABLE statement uses $Sequence for ID assignment.\r\nThe storage keyword IDFUNCTION can be defined as INCREMENT or SEQUENCE. This keyword value is used by the class compiler to determine \r\nwhich system function - $increment or $sequence - is to be used for assigning new ID values for a persistent class using default storage.\r\nThe default value for IDFUNCTION is INCREMENT, however the default behavior for classes defined through DDL is to define IDFUNCTION as SEQUENCE.\r\nTo configure the system to have classes created through DDL to define IDFUNCTION as INCREMENT, define DDLUseSequence=0.\r\nTo configure the system to have classes created through DDL to define IDFUNCTION as SEQUENCE, define DDLUseSequence=1."
        },
        "DefaultSchema":{
          "type":"string",
          "default":"SQLUser",
          "description":"This setting provides the ability to define a default schema name other than SQLUser, the default. When an unqualified table name is encountered in an SQL statement (and there is no #import statement specified), the default schema will be used.  You may specify _CURRENT_USER for the default schema name if you wish to use the SQL username the process logged in as the name of the default schema. If the process has not logged in to SQL, SQLUser will be used as the default schema name.  You may also specify _CURRENT_USER/<default name>.  In this case, if the process has not logged in to SQL, <default name> will be used as the default schema name.  For example:  _CURRENT_USER/HMO will use HMO as the default schema if the process has not logged in to SQL.  This setting has nothing to do with the mappings between SQL schema names and the class package name, it only specifies the default schema.<br>"
        },
        "DelimitedIds":{
          "type":"boolean",
          "default":1,
          "description":"Set the flag that determines if double quotes (\") in an SQL statement are used for delimited (quoted) identifiers or string constants.  If \"Yes\", a double quoted string (\"My String\") will be considered an identifier within an SQL statement.  If \"No\", a double quoted string (\"My String\") will be considered a string literal within an SQL statement.<br>"
        },
        "DropDelete":{
          "type":"boolean",
          "default":1,
          "description":"Set the flag that determines whether a DDL DROP TABLE statement deletes the table's data.<br>"
        },
        "ECPSync":{
          "type":"boolean",
          "default":0,
          "description":"When an SQL Select statement is executed, forces all pending ECP requests to the DB-server.\r\nOn completion it guarantees that the client cache is in sync."
        },
        "ExtrinsicFunctions":{
          "type":"boolean",
          "default":0,
          "description":"Allows/disallows extrinsic functions to be used in SQL statements through ODBC, JDBC, and Dynamic Query.<br>"
        },
        "FastDistinct":{
          "type":"boolean",
          "default":1,
          "description":"Set the flag that determines if SQL DISTINCT optimization is turned on.  If true (the default) many SQL queries involving DISTINCT (and GROUP BY) \r\n\twill run much more efficiently by making better use of indices (if available). \r\n\tThe downside of this is that the values returned by such queries will be collated \r\n\tin the same way they are stored within the index (i.e., results may be in upper case). \r\n\tSome applications care about the case of values returned by such queries. \r\n\tIf \"Fast DISTINCT\" is set to false (0), the SQL will revert to its pre-Cache 5.1 \r\n\tbehavior with regards to DISTINCT behavior.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "IdKey":{
          "type":"boolean",
          "default":1,
          "description":"Set the flag that determines whether a Primary Key constraint specified through DDL also<br>\r\nbecomes the IDKey index in the class definition or not. By default, the primary key does<br>\r\nalso become the idkey index. This generally gives better performance, but means that<br>\r\nthe Primary Key fields cannot be updated.<br>"
        },
        "IdTrxFrom":{
          "type":"string",
          "default":"",
          "description":"Modifies the DDL Identifier Translation mappings. This is for filtering/modifying valid SQL identifier characters when translating SQL identifiers into Objects identifiers. When converting an SQL identifier to an Objects identifier at DDL run-time, the characters in the 'From' list are converted to the characters in the 'To' list.<br>"
        },
        "IdTrxTo":{
          "type":"string",
          "default":"",
          "description":"Modifies the DDL Identifier Translation mappings. This is for filtering/modifying valid SQL identifier characters when translating SQL identifiers into Objects identifiers. When converting an SQL identifier to an Objects identifier at DDL run-time, the characters in the 'From' list are converted to the characters in the 'To' list.<br>"
        },
        "JDBCGatewayJVMArgs":{
          "type":"string",
          "default":"",
          "description":"Optional JVM arguments to include in the command line when starting the JDBC Gateway.<br>"
        },
        "JDBCGatewayLog":{
          "type":"string",
          "default":"",
          "description":"Name of the JDBC Gateway log file.<br>"
        },
        "JDBCGatewayPort":{
          "type":"integer",
          "default":62972,
          "description":"Port number for the JDBC Gateway.<br>"
        },
        "JDBCGatewayUsePassphrase":{
          "type":"boolean",
          "default":0,
          "description":"Require Passhphrase for JDBC connection"
        },
        "JavaClassPath":{
          "type":"string",
          "default":"",
          "description":""
        },
        "JavaHome":{
          "type":"string",
          "default":"",
          "description":""
        },
        "LockThreshold":{
          "type":"integer",
          "default":1000,
          "description":"The value n is the lock threshold. This is the number of inserts, updates, or deletes for a single table\r\nwithin a single transaction that will trigger a table-level lock when reached. For example, if the lock\r\nthreshold is 1000 and a process starts a transaction and then inserts 2000 rows, after the 1001st row is\r\ninserted the process will attempt to acquire a table-level lock instead of continue to lock individual\r\nrows. This is to help keep the lock table from becoming too full."
        },
        "LockTimeout":{
          "type":"integer",
          "default":10,
          "description":"Set the Lock Timeout for locks made during execution of SQL statements. This value is in seconds.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "ODBCVarcharMaxlen":{
          "type":"integer",
          "default":4096,
          "description":"Defines the MaxLen for ODBC fields of type VarChar.<br>"
        },
        "QueryProcedures":{
          "type":"boolean",
          "default":0,
          "description":"Defines whether or not all class queries project as SQL Stored Procedures \r\nregardless of the query's SqlProc setting.<br>\r\nDefault is 0, only class queries defined with SqlProc=1 will project as \r\nStored Procedures. When set to 1, all class queries will project as stored\r\nprocedures. When changing this setting, you must recompile the classes with \r\nthe class queries in order for this change to have an affect."
        },
        "RTPC":{
          "type":"boolean",
          "default":0,
          "description":"Enable Run Time Plan Choice<br>"
        },
        "ReferentialChecks":{
          "type":"boolean",
          "default":1,
          "description":"For INSERT, UPDATE, and DELETE, setting this parameter to 'Yes' instructs InterSystems IRIS to validate the foreign key constraint. Setting this parameter to 'No' will bypass foreign key constraint checking.<br>"
        },
        "SaveMAC":{
          "type":"boolean",
          "default":0,
          "description":"Defines whether or not the source code (.MAC and .INT) is saved or not. The default is that no source code is saved. This setting is made on a per-system basis.<br>"
        },
        "TCPKeepAlive":{
          "type":"integer",
          "default":300,
          "description":"Set the TCP Keep Alive timeout for xDBC TCP connections.<br>\r\nThis is the number of seconds between keep alive-messages.  The default for this is 300 seconds (5 minutes).]]]]><![CDATA[></Description>"
        },
        "TODATEDefaultFormat":{
          "type":"string",
          "default":"DD MON YYYY",
          "description":"Default date format for the SQL TO_DATE() function.<br>"
        },
        "TimePrecision":{
          "type":"integer",
          "default":0,
          "description":"Set the default precision for the Time component of the value returned by the GETDATE(), CURRENT_TIME, and CURRENT_TIMESTAMP SQL Scalar functions.  The precision, the number of decimal places for the millisecond portion of the time value, has a default is 0, which means milliseconds are not returned in the values returned by the GETDATE(), CURRENT_TIME, and CURRENT_TIMESTAMP functions.<br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "ANSIPrecedence":true,
        "AllowRowIDUpdate":false,
        "AutoParallel":true,
        "AutoParallelThreshold":3200,
        "BiasQueriesAsOutlier":false,
        "Comment":true,
        "DBMSSecurity":true,
        "DDLDefineBitmapExtent":true,
        "DDLFinal":true,
        "DDLNo201":false,
        "DDLNo30":false,
        "DDLNo307":false,
        "DDLNo311":false,
        "DDLNo315":false,
        "DDLNo324":false,
        "DDLNo333":false,
        "DDLSQLOnlyCompile":false,
        "DDLUseExtentSet":true,
        "DDLUseSequence":true,
        "DefaultSchema":"SQLUser",
        "DelimitedIds":true,
        "DropDelete":true,
        "ECPSync":false,
        "ExtrinsicFunctions":false,
        "FastDistinct":true,
        "IdKey":true,
        "IdTrxFrom":"~ `!@#$%^&*()_+-=[]\\{}|;':\",./<>?",
        "IdTrxTo":"",
        "JDBCGatewayJVMArgs":"",
        "JDBCGatewayLog":"",
        "JDBCGatewayPort":53773,
        "JDBCGatewayUsePassphrase":false,
        "JavaClassPath":"",
        "JavaHome":"",
        "LockThreshold":1000,
        "LockTimeout":10,
        "ODBCVarcharMaxlen":4096,
        "QueryProcedures":false,
        "RTPC":false,
        "ReferentialChecks":true,
        "SaveMAC":false,
        "TCPKeepAlive":300,
        "TODATEDefaultFormat":"DD MON YYYY",
        "TimePrecision":0
      }
    },
    "Shadows":{
      "type":"object",
      "properties":{
        "Address":{
          "type":"string",
          "default":"",
          "description":"IP Address to connect to.<br>"
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "DaysBeforePurge":{
          "type":"integer",
          "default":0,
          "description":""
        },
        "DisableJournalUpdates":{
          "type":"boolean",
          "default":0,
          "description":"If true, updates that the shadow applies to the shadow databases are NOT\r\njournaled, regardless of the journal settings on the databases. By default,\r\nthis is false, that is, shadow updates are journaled."
        },
        "Enabled":{
          "type":"boolean",
          "default":0,
          "description":"Specifies whether the shadow should be running or stopped.<br>\r\n0 - Stopped<br>\r\n1 - Running<br>"
        },
        "FilterRoutine":{
          "type":"string",
          "default":"",
          "description":""
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "JournalDirectory":{
          "type":"string",
          "default":"shadow",
          "description":"Directory where the shadow journal files reside.<br>"
        },
        "MaxErrors":{
          "type":"integer",
          "default":10,
          "description":"Maximum number of errors to retain.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "SSLConfig":{
          "type":"string",
          "default":"",
          "description":"SSL configuration to use on the shadow connection.<br>"
        }
      },
      "required":[
        "Address",
        "Name"
      ],
      "example":{
        "Address":"",
        "Name":""
      }
    },
    "ListOfShadows":{
      "type":"object",
      "properties":{
        "Shadows":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/Shadows"
          }
        }
      }
    },
    "SqlSysDatatypes":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Datatype":{
          "type":"string",
          "default":"",
          "description":""
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        }
      },
      "required":[
        "Datatype",
        "Name"
      ],
      "example":{
        "Datatype":"",
        "Name":""
      }
    },
    "ListOfSqlSysDatatypes":{
      "type":"object",
      "properties":{
        "SqlSysDatatypes":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/SqlSysDatatypes"
          }
        }
      }
    },
    "SqlUserDatatypes":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Datatype":{
          "type":"string",
          "default":"",
          "description":""
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        }
      },
      "required":[
        "Datatype",
        "Name"
      ],
      "example":{
        "Datatype":"",
        "Name":""
      }
    },
    "ListOfSqlUserDatatypes":{
      "type":"object",
      "properties":{
        "SqlUserDatatypes":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/SqlUserDatatypes"
          }
        }
      }
    },
    "Startup":{
      "type":"object",
      "properties":{
        "ArbiterURL":{
          "type":"string",
          "default":"",
          "description":"When configuring a mirror using ShardMirrorRole, this field can be\r\nused to specify an Arbiter.<br>\r\nThe format of this field is  <i>host</i>:<i>port</i>"
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "CallinHalt":{
          "type":"boolean",
          "default":1,
          "description":"Execute the CALLIN^%ZSTOP routine entry during calling Halt.<br>"
        },
        "CallinStart":{
          "type":"boolean",
          "default":1,
          "description":"Executes the CALLIN^%ZSTART routine entry during Callin startup.<br>"
        },
        "CliSysName":{
          "type":"string",
          "default":"",
          "description":"Name used to append to $J when Config.Miscellaneous.NodeNameInPid is set.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "DBSizesAllowed":{
          "type":"string",
          "default":"8192",
          "description":"Stores a list of allowed database block sizes.<br>"
        },
        "DefaultPort":{
          "type":"integer",
          "default":1972,
          "description":"Port for the SuperServer.<br>"
        },
        "DefaultPortBindAddress":{
          "type":"string",
          "default":"",
          "description":"IP Address SuperServer will bind to.<br>\r\nBy default, the SuperServer accepts requests on all addresses, but if a DefaultPortBindAddress is specified it will accept requests only on that address.\r\nYou should insure that all clients, including the CSP Gateway, are also configured to connect to the address you specify.\r\nIf no address is specified, the SuperServer will accept requests directed to any address on the server."
        },
        "EnableVSSBackup":{
          "type":"boolean",
          "default":0,
          "description":"Start the VSS Backup Daemon.<br>"
        },
        "EnsembleAutoStart":{
          "type":"boolean",
          "default":0,
          "description":"Auto start the Interoperability productions.<br>"
        },
        "ErrorPurge":{
          "type":"integer",
          "default":30,
          "description":"Number of days to store application error logs before purging them.<br>"
        },
        "FIPSMode":{
          "type":"boolean",
          "default":0,
          "description":"Use FIPS 140-2 compliant library for database encryption.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "IPv6":{
          "type":"boolean",
          "default":0,
          "description":"System is operating in an IPv6 network, with IPv6 addresses.<br>\r\n0 - IPv6 is not enabled.<br>\r\n1 - IPv6 is enabled.<br>"
        },
        "JobHalt":{
          "type":"boolean",
          "default":1,
          "description":"Execute the JOB^%ZSTOP routine entry during JOB process Halt.<br>"
        },
        "JobServers":{
          "type":"integer",
          "default":0,
          "description":"Number of job servers you want the system to start up with.<br>"
        },
        "JobStart":{
          "type":"boolean",
          "default":1,
          "description":"Execute the JOB^%ZSTART routine entry during JOB process startup.<br>"
        },
        "LicenseID":{
          "type":"string",
          "default":"",
          "description":"LicenseID is used to request the license key from the License Server at startup, if there is no local key file.<br>"
        },
        "MaxConsoleLogSize":{
          "type":"integer",
          "default":5,
          "description":"Maximum size in megabytes of the messages.log after which it will be automatically switched.<br>"
        },
        "MaxIRISTempSizeAtStart":{
          "type":"integer",
          "default":0,
          "description":"Maximum size in megabytes the IRISTEMP database will be when the system is\r\nrestarted.<br> When the system restarts, the IRISTEMP database will be truncated to\r\nthis size. If 0, the IRISTEMP database will not be truncated.<br>"
        },
        "MirrorMember":{
          "type":"string",
          "default":"",
          "description":"Make this node part of a mirror:<br>\r\n<ul>\r\n<li> primary: This node will be the primary failover member\r\n<li> backup: This node will be the backup failover member\r\n<li> drasync This node will be a DR async member\r\n</ul>\r\nNote that these are only initial designations, and that failover may occur at any time. "
        },
        "MirrorPrimary":{
          "type":"string",
          "default":"",
          "description":"Specifies the host or IP of the initial mirror primary. This parameter is required for any\r\nnon-empty value of parameter <i>MirrorMember</i> other than \"primary\"."
        },
        "MirrorSetName":{
          "type":"string",
          "default":"",
          "description":"MirrorSetName is the name of the mirror set to be created. This name is converted to uppercase before storing.\r\nOnly alphanumeric characters are allowed to be in the mirror set name. This name can not be a null string."
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "PasswordHash":{
          "type":"string",
          "default":"",
          "description":"Set the IRIS password using a cryptographic hash and salt.<br>\r\nThe format of this field is:  <i>hash</i>,<i>salt</i>,<i>workFactor</i>,<i>algorithm</i><br>\r\n<ul>\r\n<li>Hash: Hex-encoded output of PBKDF2 function.  Must be correct number of bits for Algorithm.\r\n<li>Salt: Hex-encoded salt input to PBKDF2.  Must be correct number of bits for Algorithm.\r\n<li>WorkFactor: WorkFactor input for PBKDF2.\r\n<li>Algorithm: A valid <a href=\"%25CSP.Documatic.cls?PAGE=CLASS&LIBRARY=%25SYS&CLASSNAME=Security.PBKDF2Alg\">Security.Datatype.PBKDF2Alg</a> value.\r\n</ul>\r\n"
        },
        "ProcessHalt":{
          "type":"boolean",
          "default":1,
          "description":"Execute the LOGIN^%ZSTOP routine entry during terminal user Halt.<br>"
        },
        "ProcessStart":{
          "type":"boolean",
          "default":1,
          "description":"Execute the LOGIN^%ZSTART routine entry during terminal user startup.<br>"
        },
        "ShardClusterURL":{
          "type":"string",
          "default":"",
          "description":"In node-level architecture, specifies the location of the initial data node.\r\nThis field should be populated for all values of <i>ShardRole</i> other than <b>NODE1</b>.<br>\r\nThe format of this field is:  IRIS://<i>host</i>:<i>port</i>/<i>namespace</i><br>"
        },
        "ShardMasterRegexp":{
          "type":"string",
          "default":"-0$",
          "description":"Regular expression used to determine node type when <i>ShardRole</i> is <b>AUTO</b>.\r\nIf the hostname matches this expression, role will be <b>NODE1</b>, otherwise <b>DATA</b>.\r\nThe default regular expression assumes that the hostname for the <b>NODE1</b> node ends in \"-0\":<br>\r\n<ul>\r\niris-data-0 &nbsp&nbsp&nbsp&nbsp // NODE1<br>\r\niris-data-1 &nbsp&nbsp&nbsp&nbsp // DATA<br>\r\n. . .<br>\r\niris-data-N &nbsp&nbsp&nbsp&nbsp // DATA<br>\r\n</ul>\r\nHowever, suppose your hostname convention was the following:\r\n<ul>\r\niris-data-0-0 &nbsp&nbsp&nbsp&nbsp // Shard 0 primary<br>\r\niris-data-0-1 &nbsp&nbsp&nbsp&nbsp // Shard 0 backup<br>\r\niris-data-1-0 &nbsp&nbsp&nbsp&nbsp // Shard 1 primary<br>\r\niris-data-1-1 &nbsp&nbsp&nbsp&nbsp // Shard 1 backup<br>\r\n. . .<br>\r\niris-data-N-0 &nbsp&nbsp&nbsp&nbsp // Shard N primary<br>\r\niris-data-N-1 &nbsp&nbsp&nbsp&nbsp // Shard N backup<br>\r\n</ul>\r\nIn this case, we choose a value for <i>ShardMasterRegexp</i> that matches the first node only: \"-0-0$\"<br>"
        },
        "ShardMirrorMember":{
          "type":"string",
          "default":"",
          "description":"Make this node part of a mirror:<br>\r\n<ul>\r\n<li> primary: This node will be the primary failover member\r\n<li> backup: This node will be the backup failover member\r\n<li> drasync This node will be a DR async member\r\n<li> auto: Automatic failover member selection based on whether the hostname (which must conform with <i>ShardRegexp</i>)\r\ncontains an even or odd number after the final dash:\r\n  <ul>\r\n  iris-data-0: primary<br>\r\n  iris-data-1: backup<br>\r\n  iris-data-2: primary<br>\r\n  iris-data-3: backup<br>\r\n  </ul>\r\n</ul>\r\nNote that these are only initial designations, and that failover may occur at any time. "
        },
        "ShardRegexp":{
          "type":"string",
          "default":"-[0-9]+$",
          "description":"Regular expression used to make sure that hostnames conform to a regular numbering scheme,\r\nwhich is a prerequisite for using <i>ShardRole</i> and <i>ShardMirrorMember</i> in automatic mode.  The default assumes\r\na scheme such as the following:\r\n<ul>\r\niris-data-0<br>\r\niris-data-1<br>\r\n. . .<br>\r\niris-data-N<br>\r\n</ul>"
        },
        "ShardRole":{
          "type":"string",
          "default":"",
          "description":"Specify the role of this IRIS instance in nod-level architecture:<br>\r\n<ul>\r\n<li> NODE1: This is the initial data node; if mirrored, set on primary failover member only\r\n<li> DATA: For all data nodes other than NODE1\r\n<li> AUTO: Automatically determine role by comparing hostname with <i>ShardMasterRegexp</i>:\r\n  <ul>\r\n  <li>Match: NODE1\r\n  <li>Non-match: DATA\r\n  </ul>\r\n<li> COMPUTE: This will be a compute node\r\n</ul>\r\nFor all roles other than <b>NODE1</b>, requires that <i>ShardClusterURL</i> be provided."
        },
        "ShutdownTimeout":{
          "type":"integer",
          "default":300,
          "description":"Enter the time, in seconds, InterSystems IRIS should wait for shutdown to complete normally before\r\ntiming out and forcing a shutdown.<br>"
        },
        "SystemHalt":{
          "type":"boolean",
          "default":1,
          "description":"Execute the SYSTEM^%ZSTOP routine entry during system shutdown.<br>"
        },
        "SystemMode":{
          "type":"string",
          "default":"",
          "description":"The SystemMode is displayed in the title of the Management Portal web page. Currently, SystemMode string values recognized by the Management Portal include:<br>\r\n<ul>\r\n<li>LIVE\r\n<li>TEST\r\n<li>DEVELOPMENT\r\n<li>FAILOVER\r\n</ul>"
        },
        "SystemStart":{
          "type":"boolean",
          "default":1,
          "description":"Executes the SYSTEM^%ZSTART routine entry during system startup.<br>"
        },
        "TempDirectory":{
          "type":"string",
          "default":"Temp",
          "description":"Directory for temporary files.<br>"
        },
        "TerminalPrompt":{
          "type":"string",
          "default":"8,2",
          "description":"Set the format of the terminal prompt.<br>\r\nThis is a comma separated string of values which set the default terminal prompt for the system.<br>\r\nValues:<br>\r\n0 - Use only \">\" for the prompt.<br>\r\n1 - Host name, also known as the current system name. The name assigned to your\r\ncomputer. For example, LABLAPTOP&gt;. This is the same for all of your terminal\r\nprocesses.<br>\r\n2 - Namespace name. For example, %SYS&gt;. The current namespace name is contained\r\nin the $NAMESPACE special variable. It can be an explicit namespace name or an\r\nimplied namespace name.<br>\r\n3 - Config name. The name of your system installation. For example, DEVELOPMENT&gt;.\r\nThis is the same for all of your terminal processes.<br>\r\n4 - Current time, expressed as local time in 24-hour format with whole seconds.\r\nFor example, 15:59:36&gt;. This is the static time value for when the prompt was\r\nreturned. This value changes for each prompt.<br>\r\n5 - pid. The Process ID for your terminal. For example, 2336&gt;. This is different\r\nfor each terminal process. This value can also be returned from the $JOB special\r\nvariable.<br>\r\n6 - Username. For example, fred&gt;. This is the same for all of your terminal\r\nprocesses.<br>\r\n7 - Elapsed time executing the last command, in seconds.milliseconds. For example,\r\n.000495&gt;. Leading and trailing zeros are suppressed. This changes for each prompt.<br>\r\n8 - Transaction Level. For example, TL1&gt;.<br><br>\r\nThe order of the values in the string determines the order the values appear in the prompt.\r\nFor example TerminalPrompt=\"2,1\" will give you a terminal prompt of \"%SYS:HostName>\""
        },
        "WebServer":{
          "type":"boolean",
          "default":1,
          "description":"Start the private WebServer.<br>"
        },
        "WebServerName":{
          "type":"string",
          "default":"",
          "description":"Webserver name or IP address the private web server is running on.<br>\r\nIf not specified, it defaults to localhost. For Unix and Windows, the\r\nprivate web server will be started on this node, on the specified IP address\r\nand port. For VMS, This is the IP address of the node where the webserver\r\nis running."
        },
        "WebServerPort":{
          "type":"integer",
          "default":57772,
          "description":"Private WebServer port.<br>"
        },
        "WebServerURLPrefix":{
          "type":"string",
          "default":"",
          "description":"URL prefix.<br>"
        },
        "ZSTU":{
          "type":"boolean",
          "default":1,
          "description":"Run the user defined startup from the ZSTU routine at system startup.<br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "ArbiterURL":"",
        "CallinHalt":true,
        "CallinStart":true,
        "CliSysName":"",
        "DBSizesAllowed":"8192",
        "DefaultPort":1972,
        "DefaultPortBindAddress":"",
        "EnableVSSBackup":false,
        "EnsembleAutoStart":true,
        "ErrorPurge":30,
        "FIPSMode":false,
        "IPv6":false,
        "JobHalt":true,
        "JobServers":0,
        "JobStart":true,
        "LicenseID":"",
        "MaxConsoleLogSize":5,
        "MaxIRISTempSizeAtStart":0,
        "MirrorMember":"",
        "MirrorPrimary":"",
        "MirrorSetName":"",
        "PasswordHash":"",
        "ProcessHalt":true,
        "ProcessStart":true,
        "ShardClusterURL":"",
        "ShardMasterRegexp":"-0$",
        "ShardMirrorMember":"",
        "ShardRegexp":"-[0-9]+$",
        "ShardRole":"",
        "ShutdownTimeout":300,
        "SystemHalt":true,
        "SystemMode":"",
        "SystemStart":true,
        "TempDirectory":"Temp",
        "TerminalPrompt":"8,2",
        "WebServer":true,
        "WebServerName":"",
        "WebServerPort":52773,
        "WebServerURLPrefix":"",
        "ZSTU":true
      }
    },
    "Telnet":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "DNSLookup":{
          "type":"string",
          "default":"ON",
          "description":"Determines whether DNS lookup should be enabled.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "Port":{
          "type":"integer",
          "default":23,
          "description":"Telnet port.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "DNSLookup":"ON",
        "Port":23
      }
    },
    "config":{
      "type":"object",
      "properties":{
        "BackoffDisabled":{
          "type":"boolean",
          "default":0,
          "description":"Upon failure to allocate memory, do not retry with a reduced amount.  If shared\r\nmemory cannot be allocated at its configured size, startup is aborted.\r\n<br><br>\r\nMakes up part of the CPF parameter memlock=\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "ConsoleFile":{
          "type":"string",
          "default":"",
          "description":"Location of the messages.log file.<br>\r\nNull means the MGR directory.<br>\r\nThis is the second piece of the CPF parameter console=VMSConsoleTerminal,ConsoleFile\r\n<br><br>\r\nModifying this property does not require a restart of the system to make it active."
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "LargePagesDisabled":{
          "type":"boolean",
          "default":0,
          "description":"If true, on platforms supporting large/huge pages, instructs the system not\r\nto use them for global and routine buffers.\r\n<br><br>\r\nMakes up part of the CPF parameter memlock=\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "LargePagesRequired":{
          "type":"boolean",
          "default":0,
          "description":"If true, on platforms supporting large or huge pages, requires shared memory to\r\nbe allocated from them.  Ignored on other platforms or if large pages are \r\ndisabled by <PROPERTY>LargePagesDisabled</PROPERTY>.  If true and not ignored, \r\nand memory cannot be allocated in large/huge pages, startup is aborted.  Note: \r\nstartup may retry with a small reduction in memory size, but the extent to which\r\nmemory may be reduced is smaller than would be allowed in absence of this flag.\r\nYou can disable this retry altogether with <PROPERTY>BackoffDisabled</PROPERTY>.\r\n<br><br>\r\nMakes up part of the CPF parameter memlock=\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "LibPath":{
          "type":"string",
          "default":"",
          "description":"On Unix systems this sets the LD_LIBRARY_PATH environment variable to set \r\nsearch paths for third-party shared libraries. Ignored on Windows and VMS.\r\n<br><br>\r\nModifying this property does not require a restart of the system to make it active."
        },
        "LineRecallBuffer":{
          "type":"integer",
          "default":1024,
          "description":"The size in bytes of the command line/read line buffer.<br>\r\nThis is the second piece of the CPF parameter history=LineRecallEntries,LineRecallBuffer\r\n<br><br>\r\nModifying this property does not require a restart of the system to make it active."
        },
        "LineRecallEntries":{
          "type":"integer",
          "default":500,
          "description":"The number of entries held in the command line/read line recall buffer.<br>\r\nThis is the first piece of the CPF parameter history=LineRecallEntries,LineRecallBuffer\r\n<br><br>\r\nModifying this property does not require a restart of the system to make it active."
        },
        "LockSharedMemory":{
          "type":"boolean",
          "default":0,
          "description":"On platforms that support it, requests control structures, global and routine\r\nbuffers to be locked in physical memory.  When using large or huge pages for\r\nshared memory, there is no need to set this property since they are \r\nautomatically locked in physical memory.\r\n<br><br>\r\nMakes up part of the CPF parameter memlock=.\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "LockTextSegment":{
          "type":"boolean",
          "default":0,
          "description":"On some UNIX platforms, requests the text segment (executable image) to be\r\nlocked in physical memory.\r\n<br><br>\r\nMakes up part of the CPF parameter memlock=\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "MaxServerConn":{
          "type":"integer",
          "default":1,
          "description":"Maximum number of clients that can access this server simultaneously.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "MaxServers":{
          "type":"integer",
          "default":2,
          "description":"Maximum number of ECP servers that can be accessed from this system.<br>\r\n<br><br>\r\nModifying this property does not require a restart of the system to make it active if memory is available in the shared memory heap."
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "VMSConsoleTerminal":{
          "type":"string",
          "default":"",
          "description":"Location of the VMS console terminal.<br>\r\nThis is the first piece of the CPF parameter console=VMSConsoleTerminal,ConsoleFile\r\n<br><br>\r\nModifying this property does not require a restart of the system to make it active."
        },
        "ZFSize":{
          "type":"integer",
          "default":0,
          "description":"The total number of bytes allocated in virtual memory for $ZF input and output parameters, including strings.<br>\r\nThis is the second piece of the CPF parameter zfheap=ZFString,ZFSize\r\n<br><br>\r\nModifying this property does not require a restart of the system to make it active."
        },
        "ZFString":{
          "type":"integer",
          "default":0,
          "description":"Number of bytes allocated for the each output byte array or string parameter on the $ZF heap.<br>\r\nThis is the First piece of the CPF parameter zfheap=ZFString,ZFSize\r\n<br><br>\r\nModifying this property does not require a restart of the system to make it active."
        },
        "bbsiz":{
          "type":"integer",
          "default":262144,
          "description":"Maximum amount of memory a process can use (in KB).<br>\r\n<br><br>\r\nModifying this property does not require a restart of the system to make it active."
        },
        "console":{
          "type":"string",
          "default":",",
          "description":"CPF file representation of console=VMSConsoleTerminal,ConsoleFile.<br>"
        },
        "errlog":{
          "type":"integer",
          "default":500,
          "description":"Maximum number of entries you want to store in the SYSLOG log file.<br>\r\nThe log file will expire old entries when this limit is reached.\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "globals":{
          "type":"string",
          "default":"0,0,0,0,0,0",
          "description":"List of configured sizes (in MBytes) for the global caches.<br>\r\nElement #1 corresponds to 2KB blocks (deprecated, always 0 now).<br>\r\nElement #2 corresponds to 4KB blocks.<br>\r\nElement #3 corresponds to 8KB blocks.<br>\r\nElement #4 corresponds to 16KB blocks.<br>\r\nElement #5 corresponds to 32KB blocks.<br>\r\nElement #6 corresponds to 64KB blocks.<br>"
        },
        "globals16kb":{
          "type":"integer",
          "default":0,
          "description":"Number of 16KB buffers in MB.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "globals32kb":{
          "type":"integer",
          "default":0,
          "description":"Number of 32KB buffers in MB.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "globals4kb":{
          "type":"integer",
          "default":0,
          "description":"Number of 4KB buffers in MB.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "globals64kb":{
          "type":"integer",
          "default":0,
          "description":"Number of 64KB buffers in MB.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "globals8kb":{
          "type":"integer",
          "default":0,
          "description":"Number of 8KB buffers in MB.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "gmheap":{
          "type":"integer",
          "default":37568,
          "description":"Generic Memory Heap Size (in KB).<br>\r\nThis is the place from where the Lock\r\ntable, the NLS tables and the PID table are allocated. The absolute minimum value is\r\n2048KB. If you specify a big Lock Table, the minimum value will increase so that there's\r\nalways room for it. If you are using an Asian locale you may want to add an extra MB (1024KB).\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "history":{
          "type":"string",
          "default":"500,1024",
          "description":"CPF file representation of history=LineRecallEntries,LineRecallBuffer.<br>"
        },
        "ijcbuff":{
          "type":"integer",
          "default":512,
          "description":"Number of bytes allocated for each InterJob Communication Device.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "ijcnum":{
          "type":"integer",
          "default":16,
          "description":"The number of InterJob Communication devices.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "jrnbufs":{
          "type":"integer",
          "default":64,
          "description":"Size of journal buffer pool in MBs. Modifying this property will require a restart of the system to make it active. The maximum value is 1024 and the minimum, 16 on Unicode platforms or 8 otherwise."
        },
        "locksiz":{
          "type":"integer",
          "default":16777216,
          "description":"The amount of memory allocated on your system for locks, in bytes.<br>\r\nThe maximum value depends on the gmheap size and not exceeding gmheap size. Memory is allocated in multiples\r\nof 64k (65536 bytes) chunks. If you enter a value which is not on a 64k boundary, the\r\nvalue will be rounded to the next higher 64k boundary.\r\nIncrease the gmheap size if you need more room for the Lock Table.\r\n<br><br>\r\nModifying this property does not require a restart of the system to make it active."
        },
        "memlock":{
          "type":"integer",
          "default":0,
          "description":"When checked, this allows you to lock control structures in memory to improve access time.<br>\r\nCPF file representation of memlock="
        },
        "netjob":{
          "type":"boolean",
          "default":1,
          "description":"Allows jobs from remote connections to run on your server.<br>\r\n<br><br>\r\nModifying this property does not require a restart of the system to make it active."
        },
        "nlstab":{
          "type":"integer",
          "default":50,
          "description":"Enter the maximum number of collation tables. This instructs InterSystems IRIS to reserve space for that many tables at startup.<sp>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "overview":{
          "type":"string",
          "default":"Windows (Intel)~Windows",
          "description":""
        },
        "pijdir":{
          "type":"string",
          "default":"",
          "description":"Directory to store the cluster image journal.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "routines":{
          "type":"string",
          "default":0,
          "description":"Number of MB allocated for caching routine buffers.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "targwijsz":{
          "type":"integer",
          "default":0,
          "description":"When targwijsz is non-zero it is the desired size of the WIJ file in MB.\r\nThe maximum effective value is the size of the buffer pool. While it would not hurt\r\nto have a larger WIJ, it does not help anything. The minimum value is 100MB. When\r\nthe size of the global buffer pool is less than 100MB at startup the WIJ is sized\r\nto hold the entire buffer pool; the minimum size of the WIJ at startup is either\r\n100MB or the size required to hold the entire buffer pool (which is slightly larger\r\nthan the actual size of the buffer pool). If an existing WIJ is larger than\r\nthe specified target, the size of the WIJ is not reduced. <br><br>\r\nWhen the target size is larger than the size of the existing WIJ, the system will\r\nexpand the WIJ while the write daemon is idle up to the specified target (but\r\nnot to exceed the actual size of the WIJ needed to hold the entire buffer pool). The\r\nsystem can expand the WIJ past the target size if that becomes necessary to\r\ncomplete a write cycle.<br><br>\r\nLeaving this value set to 0 is fine. The system will grow the WIJ as needed based\r\non activity. Generally the WIJ quickly reaches whatever size is needed to \r\nsupport the activity level/the size of the buffer pool.  The purpose of setting\r\na target size is that if space has been reserved for the WIJ, setting a target\r\nallows the WIJ to grow to occupy that space early on in the life of the system.\r\nSince user activity can be blocked if the WIJ is too small (the WIJ will try to expand\r\nif this happens), setting the target may lead to a better user experience after\r\nstartup. If the target is set to 0, the WIJ may quickly expand as needed however\r\nusers may be blocked at times when this happens until the WIJ reaches the size\r\nrequired by the system."
        },
        "udevtabsiz":{
          "type":"integer",
          "default":24576,
          "description":"Maximum size in bytes of the device table.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "useresidentmem":{
          "type":"string",
          "default":"",
          "description":"VMS system resident memory name.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "wijdir":{
          "type":"string",
          "default":"",
          "description":"Enter the directory for the Write Image Journal file into this text box.<br>\r\n<br><br>\r\nModifying this property does not require an instance restart to activate the change except on cluster members."
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "BackoffDisabled":false,
        "ConsoleFile":"",
        "LargePagesDisabled":false,
        "LargePagesRequired":false,
        "LibPath":"",
        "LineRecallBuffer":1024,
        "LineRecallEntries":500,
        "LockSharedMemory":false,
        "LockTextSegment":false,
        "MaxServerConn":1,
        "MaxServers":2,
        "VMSConsoleTerminal":"",
        "ZFSize":0,
        "ZFString":0,
        "bbsiz":262144,
        "errlog":500,
        "globals16kb":0,
        "globals32kb":0,
        "globals4kb":0,
        "globals64kb":0,
        "globals8kb":0,
        "gmheap":37568,
        "ijcbuff":512,
        "ijcnum":16,
        "jrnbufs":64,
        "locksiz":16777216,
        "netjob":true,
        "nlstab":50,
        "pijdir":"",
        "routines":"0",
        "targwijsz":0,
        "udevtabsiz":24576,
        "wijdir":""
      }
    },
    "SecurityUsers":{
      "type":"object",
      "properties":{
        "AccountNeverExpires":{
          "type":"boolean",
          "default":0,
          "description":"Account Expiration behavior.<br>\r\n0 - Account expires normally.<br>\r\n1 - Account will never expire.<br>"
        },
        "Attributes":{
          "type":"string",
          "default":"",
          "description":"Attributes to apply to user when they log in."
        },
        "AutheEnabled":{
          "type":"integer",
          "default":0,
          "description":"Two factor Authentication options which are enabled for this user.<br>\r\nOptions are:<br>\r\n$$$AutheTwoFactorSMS - SMS Text authentication<br>\r\n$$$AutheTwoFactorPW\t- Time-based One-time Password<br>"
        },
        "ChangePassword":{
          "type":"boolean",
          "default":0,
          "description":"Change password on next login.<br>\r\n0 - Password change not required.<br>\r\n1 - Password change required before next login.<br>"
        },
        "Comment":{
          "type":"string",
          "default":"",
          "description":"Comment.<br>"
        },
        "CreateDateTime":{
          "type":"string",
          "default":"65838,66352.34806",
          "description":"Account creation date and time.<br>\r\n$H format in utc.<br>"
        },
        "CreateUsername":{
          "type":"string",
          "default":"irisowner",
          "description":"$username of user who created the account.<br>"
        },
        "EmailAddress":{
          "type":"string",
          "default":"",
          "description":"Email address of the user.<br>"
        },
        "Enabled":{
          "type":"boolean",
          "default":1,
          "description":"Allow user to log in.<br>\r\n0 - Disable login.<br>\r\n1 - Enable login.<br>"
        },
        "ExpirationDate":{
          "type":"string",
          "default":"",
          "description":"Last date an account can be used.<br>\r\n$H date value of when an account becomes disabled.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":1,
          "description":"Flags associated with user.<br>\r\nBit 0 - User created via normal security mechanisms (InterSystems IRIS Password User).<br>\r\nBit 1 - User created via LDAP.<br>\r\nBit 2 - User created via Delegated Authentication.<br>"
        },
        "FullName":{
          "type":"string",
          "default":"",
          "description":"Full name of the user.<br>"
        },
        "HOTPKey":{
          "type":"string",
          "default":"]9:-ñ\u001BÓÖ\u001E\u0004_H\u00043Ûo",
          "description":"Time-based One-time Password key.<br>\r\nThis property is automatically generated when the user is created using the \r\n$System.Encryption.GenCryptRand() method.<br>"
        },
        "HOTPKeyDisplay":{
          "type":"boolean",
          "default":0,
          "description":"Display the Time-based One-time Password QR code or key on next login for the\r\nuser to scan with their authentication device.<br>"
        },
        "HOTPKeyGenerate":{
          "type":"boolean",
          "default":0,
          "description":"0 - Do not generate a new Time-based One-time Password key when user is saved.<br>\r\n1 - Generate a new Time-based One-time Password key when user is saved.<br>"
        },
        "InvalidLoginAttempts":{
          "type":"integer",
          "default":0,
          "description":"Number of invalid login attempts since last successful one.<br>"
        },
        "InvalidLoginDateTime":{
          "type":"string",
          "default":0,
          "description":"Last invalid login date and time"
        },
        "InvalidLoginDevice":{
          "type":"string",
          "default":"",
          "description":"Last invalid login device"
        },
        "InvalidLoginService":{
          "type":"string",
          "default":"",
          "description":"Last invalid login Service"
        },
        "InvalidLoginStatus":{
          "type":"string",
          "default":1,
          "description":"Last login error"
        },
        "LastModifiedDateTime":{
          "type":"string",
          "default":"65838,66352.348077",
          "description":"Account modified date and time.<br>\r\n$H format in utc.<br>"
        },
        "LastModifiedInfo":{
          "type":"string",
          "default":"",
          "description":"Information describing last modification of the user.<br>"
        },
        "LastModifiedUsername":{
          "type":"string",
          "default":"irisowner",
          "description":"$username of the person who last modified it.<br>"
        },
        "LoginDateTime":{
          "type":"string",
          "default":0,
          "description":"Last Successful login date and time.<br>\r\n$H format in utc."
        },
        "LoginDevice":{
          "type":"string",
          "default":"",
          "description":"Last Successful login device"
        },
        "LoginService":{
          "type":"string",
          "default":"",
          "description":"Last Successful login Service.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"User Name.<br>\r\nIncludes domain if multiple domains are enabled in the\r\nformat username@domain."
        },
        "NameSpace":{
          "type":"string",
          "default":"",
          "description":"NameSpace to run in only if a terminal session.<br>"
        },
        "Password":{
          "type":"string",
          "default":"",
          "description":"PBKDF2 hashed password for InterSystems IRIS Authentication.<br>\r\nThis is used with a salt function obtained from \r\n$System.Encryption.GenCryptRand. This property is set by the class when the\r\nPasswordExternal property is modified. Do not set this property directly.<br>\r\nTo modify the password for a user using objects, get an instance of the object and\r\nmodify the PasswordExternal property:<br>\r\ni '..Exists(Username,.User,.Status) q Status<br>\r\ns User.PasswordExternal=Password<br>\r\ns Status=User.%Save()<br>\r\nWhen using the Modify() class method to change a user's method, you can either set\r\nProperties(\"Password\")=NewPassword, or Properties(\"ExternalPassword\")=NewPassword.<br>"
        },
        "PasswordChangedDateTime":{
          "type":"string",
          "default":"65838,66352.348078",
          "description":"Last password change date and time.<br>\r\n$H format in utc.<br>"
        },
        "PasswordExternal":{
          "type":"string",
          "default":"\u0000",
          "description":"Clear text password.<br>\r\nThis property is not stored in permanent storage. It is initially set to\r\nthe value of $c(0). When it is modified, the Password property is updated\r\nto the PBKDF2 salted hashed value."
        },
        "PasswordHashAlgorithm":{
          "type":"string",
          "default":"",
          "description":"Algorithm used to calculate user's current PBKDF2 password hash.\r\n\r\nIrrelevant for users without passwords."
        },
        "PasswordHashWorkFactor":{
          "type":"integer",
          "default":"",
          "description":"Work Factor used to calculate user's current PBKDF2 password hash.\r\n\r\nIrrelevant for users without passwords."
        },
        "PasswordNeverExpires":{
          "type":"boolean",
          "default":0,
          "description":"Password expires behavior.<br>\r\n0 - Password expires normally.<br>\r\n1 - Password never expires.<br>"
        },
        "PhoneNumber":{
          "type":"string",
          "default":"",
          "description":"Phone number for two-factor authentication"
        },
        "PhoneProvider":{
          "type":"string",
          "default":"",
          "description":"Mobile phone service provider for two-factor authentication"
        },
        "Roles":{
          "type":"string",
          "default":"",
          "description":"Roles assigned to the user.<br>"
        },
        "Routine":{
          "type":"string",
          "default":"",
          "description":"Routine to run only if terminal session, \"\"=Programmer mode.<br>"
        },
        "Salt":{
          "type":"string",
          "default":"",
          "description":"Salt value for Hashed password from $System.Encryption.GenCryptRand.<br>"
        },
        "SuperUser":{
          "type":"boolean",
          "default":0,
          "description":"User holds the %All role.<br>"
        }
      },
      "required":[
        "Name",
        "PasswordHashAlgorithm",
        "PasswordHashWorkFactor"
      ],
      "example":{
        "Name":"",
        "PasswordHashAlgorithm":"",
        "PasswordHashWorkFactor":0
      }
    },
    "ListOfSecurityUsers":{
      "type":"object",
      "properties":{
        "list":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/SecurityUsers"
          }
        }
      }
    },
    "SecurityRoles":{
      "type":"object",
      "properties":{
        "Description":{
          "type":"string",
          "default":"",
          "description":"Description of the role."
        },
        "GrantedRoles":{
          "type":"string",
          "default":"",
          "description":"Roles assigned to the Role."
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Role Name"
        },
        "Resources":{
          "type":"string",
          "default":"",
          "description":"Resource/Permission pairs the role holds"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "Name":""
      }
    },
    "ListOfSecurityRoles":{
      "type":"object",
      "properties":{
        "list":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/SecurityRoles"
          }
        }
      }
    },
    "SecurityResources":{
      "type":"object",
      "properties":{
        "Description":{
          "type":"string",
          "default":"",
          "description":"Description of the resource.<br>\r\nDescription cannot be modified if a system defined resource.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the resource.<br>"
        },
        "PublicPermission":{
          "type":"string",
          "default":0,
          "description":"Public permissions on the resource.<br>\r\nBit 0 - Read<br>\r\nBit 1 - Write<br>\r\nBit 2 - Use<br><br>\r\nAlternatively, you can set to this any of \"RWU\" or \"READ,WRITE,USE\"<br>"
        },
        "Type":{
          "type":"string",
          "default":0,
          "description":"Type - Bitmap describing the type of resource.<br>\r\nBit 0 = System initialized resource<br>\r\nBit 1 = Database resource<br>\r\nBit 2 = Service resource<br>\r\nBit 3 - Application resource<br>\r\nBit 4 - DeepSee resource<br>\r\nBits 5-30 reserved<br>\r\nBit 31 = User defined Resource<br>\r\nBits 31-64 user defined <Reserved for future use><br>\r\nNote that this property is set automatically by the filer and should\r\nnot be set for user defined resources.<br>\r\nDo not modify this field directly except on initialization of system defaults."
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "Name":""
      }
    },
    "ListOfSecurityResources":{
      "type":"object",
      "properties":{
        "list":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/SecurityResources"
          }
        }
      }
    },
    "SecuritySSLConfigs":{
      "type":"object",
      "properties":{
        "CAFile":{
          "type":"string",
          "default":"",
          "description":"File containing X.509 certificate(s) of trusted Certificate Authorities.<br>\r\nCan be an absolute pathname, a pathname relative to the manager's directory, or a special value \"%OSCertificateStore\" for OS-provided trusted CA certificate stores.<br>\r\nClients:  Specify CAFile and/or CAPath<br>\r\nServers:  Specify CAFile and/or CAServer if VerifyPeer > 0"
        },
        "CAPath":{
          "type":"string",
          "default":"",
          "description":"Directory containing file(s) with X.509 certificate(s) of trusted Certificate Authorities.<br>\r\nCan be an absolute pathname or a pathname relative to the manager's directory.<br>\r\nClients:  Specify CAFile and/or CAPath<br>\r\nServers:  Specify CAFile and/or CAServer if VerifyPeer > 0"
        },
        "CertificateFile":{
          "type":"string",
          "default":"",
          "description":"File containing this configuration's X.509 certificate.<br>\r\nCan be an absolute pathname or a pathname relative to the manager's directory.\r\nIf not null, PrivateKeyFile must also be specified."
        },
        "CipherList":{
          "type":"string",
          "default":"ALL:!aNULL:!eNULL:!EXP:!SSLv2",
          "description":"Colon-delimited list of enabled ciphersuites for TLSv1.2 and below.<br>\r\nBy default, disable anonymous, unencrypted, export, and SSLv2 ciphersuites."
        },
        "Ciphersuites":{
          "type":"string",
          "default":"TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256",
          "description":"Colon-delimited lists of enabled ciphersuites for TLSv1.3."
        },
        "Description":{
          "type":"string",
          "default":"",
          "description":"Description of the SSL configuration.<br>"
        },
        "Enabled":{
          "type":"boolean",
          "default":1,
          "description":"Configuration is enabled.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"SSL configuration name.<br>"
        },
        "PrivateKeyFile":{
          "type":"string",
          "default":"",
          "description":"File containing this configuration's private key.<br>\r\nCan be an absolute pathname or a pathname relative to the manager's directory.\r\nIf not null, CertificateFile must also be specified."
        },
        "PrivateKeyPassword":{
          "type":"string",
          "default":"",
          "description":"Optional password used to decrypt this configuration's private key.<br>\r\nIf not null, PrivateKeyFile and CertificateFile must also be specified."
        },
        "PrivateKeyType":{
          "type":"string",
          "default":2,
          "description":"Private key type, one of:<br>\r\n1 = DSA<br>\r\n2 = RSA"
        },
        "Protocols":{
          "type":"string",
          "default":"",
          "description":"Protocols enabled.<br>\r\nBit 2 - TLSv1.0<br>\r\nBit 3 - TLSv1.1<br>\r\nBit 4 - TLSv1.2<br>\r\nBit 5 - TLSv1.3<br>\r\nDEPRECATED.  Use TLSMinVersion and TLSMaxVersion instead."
        },
        "SNIName":{
          "type":"string",
          "default":"",
          "description":"The fully qualified DNS hostname of the server for use with the Subject Name Indication (SNI)\r\nTLS extension\r\nDEPRECATED."
        },
        "TLSMaxVersion":{
          "type":"string",
          "default":32,
          "description":"Maximum TLS protocol version enabled.<br>\r\n4 - TLSv1.0\r\n8 - TLSv1.1\r\n16 - TLSv1.2\r\n32 - TLSv1.3\r\nDefault = TLSv1.3\r\nRequirement is TLSMaxVersion >= TLSMinVersion"
        },
        "TLSMinVersion":{
          "type":"string",
          "default":16,
          "description":"Minimum TLS protocol version enabled.<br>\r\n4 - TLSv1.0\r\n8 - TLSv1.1\r\n16 - TLSv1.2\r\n32 - TLSv1.3\r\nDefault is TLSv1.2<br>\r\nRequirement is TLSMinVersion <= TLSMaxVersion"
        },
        "Type":{
          "type":"string",
          "default":0,
          "description":"Intended type for this configuration.<br>\r\n0 = client<br>\r\n1 = server<br>\r\nDefault is client (0)"
        },
        "VerifyDepth":{
          "type":"integer",
          "default":9,
          "description":"Maximum number of CA certificates allowed in peer certificate chain.<br>"
        },
        "VerifyPeer":{
          "type":"integer",
          "default":0,
          "description":"Peer certificate verification level.<br>\r\n<br>\r\nClients:<br>\r\n0 = None (continue even if certificate verification fails)<br>\r\n1 = Require server certificate (continue only if certificate verification succeeds)<br>\r\n<br>\r\nServers:<br>\r\n0 = None (do not request client certificate)<br>\r\n1 = Request client certificate (terminate if certificate is provided and verification fails)<br>\r\n3 = Require client certificate (continue only if certificate is provided and verification succeeds)<br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "Name":""
      }
    },
    "ListOfSecuritySSLConfigs":{
      "type":"object",
      "properties":{
        "list":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/SecuritySSLConfigs"
          }
        }
      }
    },
    "SecuritySQLAdminPrivilegeSet":{
      "type":"object",
      "properties":{
        "AlterTable":{
          "type":"string",
          "default":"",
          "description":"AlterTable - 0/1/2, can this privilege be granted by the user 0 - No, 1 - Yes, 2 - Yes and grantable"
        },
        "AlterView":{
          "type":"string",
          "default":"",
          "description":"AlterView - 0/1/2, can this privilege be granted by the user 0 - No, 1 - Yes, 2 - Yes and grantable"
        },
        "BuildIndex":{
          "type":"string",
          "default":"",
          "description":"BuildIndex - 0/1/2, can this privilege be granted by the user 0 - No, 1 - Yes, 2 - Yes and grantable"
        },
        "CreateFunction":{
          "type":"string",
          "default":"",
          "description":"CreateFunction - 0/1/2, can this privilege be granted by the user 0 - No, 1 - Yes, 2 - Yes and grantable"
        },
        "CreateMethod":{
          "type":"string",
          "default":"",
          "description":"CreateMethod - 0/1/2, can this privilege be granted by the user 0 - No, 1 - Yes, 2 - Yes and grantable"
        },
        "CreateProcedure":{
          "type":"string",
          "default":"",
          "description":"CreateProcedure - 0/1/2, can this privilege be granted by the user 0 - No, 1 - Yes, 2 - Yes and grantable"
        },
        "CreateQuery":{
          "type":"string",
          "default":"",
          "description":"CreateQuery - 0/1/2, can this privilege be granted by the user 0 - No, 1 - Yes, 2 - Yes and grantable"
        },
        "CreateTable":{
          "type":"string",
          "default":"",
          "description":"CreateTable - 0/1/2, can this privilege be granted by the user 0 - No, 1 - Yes, 2 - Yes and grantable"
        },
        "CreateTrigger":{
          "type":"string",
          "default":"",
          "description":"CreateTrigger - 0/1/2, can this privilege be granted by the user 0 - No, 1 - Yes, 2 - Yes and grantable"
        },
        "CreateView":{
          "type":"string",
          "default":"",
          "description":"CreateView - 0/1/2, can this privilege be granted by the user 0 - No, 1 - Yes, 2 - Yes and grantable"
        },
        "DropFunction":{
          "type":"string",
          "default":"",
          "description":"DropFunction - 0/1/2, can this privilege be granted by the user 0 - No, 1 - Yes, 2 - Yes and grantable"
        },
        "DropMethod":{
          "type":"string",
          "default":"",
          "description":"DropMethod - 0/1/2, can this privilege be granted by the user 0 - No, 1 - Yes, 2 - Yes and grantable"
        },
        "DropProcedure":{
          "type":"string",
          "default":"",
          "description":"DropProcedure - 0/1/2, can this privilege be granted by the user 0 - No, 1 - Yes, 2 - Yes and grantable"
        },
        "DropQuery":{
          "type":"string",
          "default":"",
          "description":"DropQuery - 0/1/2, can this privilege be granted by the user 0 - No, 1 - Yes, 2 - Yes and grantable"
        },
        "DropTable":{
          "type":"string",
          "default":"",
          "description":"DropTable - 0/1/2, can this privilege be granted by the user 0 - No, 1 - Yes, 2 - Yes and grantable"
        },
        "DropTrigger":{
          "type":"string",
          "default":"",
          "description":"DropTrigger - 0/1/2, can this privilege be granted by the user 0 - No, 1 - Yes, 2 - Yes and grantable"
        },
        "DropView":{
          "type":"string",
          "default":"",
          "description":"DropView - 0/1/2, can this privilege be granted by the user 0 - No, 1 - Yes, 2 - Yes and grantable"
        },
        "Grantee":{
          "type":"string",
          "default":"",
          "description":"Grantee - user/role the privilege was granted to"
        },
        "Namespace":{
          "type":"string",
          "default":"",
          "description":"Namespace the privilege is defined in"
        },
        "NoCheck":{
          "type":"string",
          "default":"",
          "description":"NoCheck - 0/1/2, can this privilege be granted by the user 0 - No, 1 - Yes, 2 - Yes and grantable"
        },
        "NoIndex":{
          "type":"string",
          "default":"",
          "description":"NoIndex - 0/1/2, can this privilege be granted by the user 0 - No, 1 - Yes, 2 - Yes and grantable"
        },
        "NoLock":{
          "type":"string",
          "default":"",
          "description":"NoLock - 0/1/2, can this privilege be granted by the user 0 - No, 1 - Yes, 2 - Yes and grantable"
        },
        "NoTrigger":{
          "type":"string",
          "default":"",
          "description":"NoTrigger - 0/1/2, can this privilege be granted by the user 0 - No, 1 - Yes, 2 - Yes and grantable"
        }
      },
      "required":[
        "Grantee",
        "Namespace"
      ],
      "example":{
        "Grantee":"",
        "Namespace":""
      }
    },
    "ListOfSecuritySQLAdminPrivilegeSet":{
      "type":"object",
      "properties":{
        "list":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/SecuritySQLAdminPrivilegeSet"
          }
        }
      }
    },
    "LibrarySQLConnection":{
      "type":"object",
      "properties":{
        "DSN":{
          "type":"string",
          "default":"",
          "description":""
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":""
        },
        "OnConnectStatement":{
          "type":"string",
          "default":"",
          "description":"Statement to execute on remote system immediately after connection.\r\nThis is only for a Gateway conenction through %Library.GTWConnection.Connect() method.\r\nAn example usage of this would be to set a session parameter on an Oracle connection:\r\n   ALTER SESSION SET NLS_TIMESTAMP_FORMAT = 'YYYY-MM-DD HH24:MI:SS.FF6'"
        },
        "ReverseOJ":{
          "type":"boolean",
          "default":"",
          "description":""
        },
        "URL":{
          "type":"string",
          "default":"",
          "description":""
        },
        "Usr":{
          "type":"string",
          "default":"",
          "description":""
        },
        "bUnicodeStream":{
          "type":"boolean",
          "default":1,
          "description":""
        },
        "bindTSasString":{
          "type":"boolean",
          "default":0,
          "description":"Bind TIMESTAMP type parmaters as VARCHAR.\r\nWhen binding parameter values via the GateWay, some remote systems consider TIMESTAMP as a special structure that does not\r\nmatch the the %TimeStamp datatype format of YYYY-MM-DD HH24:MI;SS[.ssssss].\r\nSetting this property to 1 will bind TIMESTAMP parameters as VARCHARs instead of TIMESTAMP.\r\nYou might need this setting when binding TIMESTAMP parameters to Oracle, depending on the Oracle driver used."
        },
        "classpath":{
          "type":"string",
          "default":"",
          "description":""
        },
        "driver":{
          "type":"string",
          "default":"",
          "description":""
        },
        "isJDBC":{
          "type":"boolean",
          "default":"",
          "description":""
        },
        "needlongdatalen":{
          "type":"boolean",
          "default":"",
          "description":""
        },
        "noconcat":{
          "type":"boolean",
          "default":"",
          "description":""
        },
        "nodefq":{
          "type":"boolean",
          "default":"",
          "description":""
        },
        "nofnconv":{
          "type":"boolean",
          "default":"",
          "description":""
        },
        "nvl":{
          "type":"boolean",
          "default":"",
          "description":""
        },
        "properties":{
          "type":"string",
          "default":"",
          "description":""
        },
        "pwd":{
          "type":"string",
          "default":"",
          "description":""
        },
        "useCAST":{
          "type":"boolean",
          "default":"",
          "description":""
        },
        "useCASTCHAR":{
          "type":"boolean",
          "default":"",
          "description":""
        },
        "useCOALESCE":{
          "type":"boolean",
          "default":1,
          "description":""
        },
        "xadriver":{
          "type":"string",
          "default":"",
          "description":""
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "Name":""
      }
    },
    "ListOfLibrarySQLConnection":{
      "type":"object",
      "properties":{
        "list":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/LibrarySQLConnection"
          }
        }
      }
    },
    "SecuritySQLPrivileges":{
      "type":"object",
      "properties":{
        "Grantable":{
          "type":"string",
          "default":"",
          "description":"Grantable - 1/0, can this privilege be granted by the user"
        },
        "Grantee":{
          "type":"string",
          "default":"",
          "description":"Grantee - user/role the privilege was granted to"
        },
        "Grantor":{
          "type":"string",
          "default":"",
          "description":"Grantor - user/role that granted the privilege"
        },
        "Namespace":{
          "type":"string",
          "default":"",
          "description":"Namespace the privilege is defined in"
        },
        "Privilege":{
          "type":"string",
          "default":"",
          "description":"Privilege assigned to the user/role"
        },
        "SQLObject":{
          "type":"string",
          "default":"",
          "description":"ObjectType,ObjectName e.g. \"1,Sample.Person\" or \"3,Sample.PersonView\""
        }
      },
      "required":[
        "Grantable",
        "Grantee",
        "Grantor",
        "Namespace",
        "Privilege",
        "SQLObject"
      ],
      "example":{
        "Grantable":"",
        "Grantee":"",
        "Grantor":"",
        "Namespace":"",
        "Privilege":"",
        "SQLObject":""
      }
    },
    "ListOfSecuritySQLPrivileges":{
      "type":"object",
      "properties":{
        "list":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/SecuritySQLPrivileges"
          }
        }
      }
    }
  }
}
]]></Data>
</XData>
</Class>


<Class name="Api.Config.Services.Cluster">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29866.968643</TimeChanged>
<TimeCreated>66011,29866.968643</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.Cluster</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.Common.Methods">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.MethodsObjectGenerator</Super>
<TimeChanged>66011,29867.302875</TimeChanged>
<TimeCreated>66011,29867.302875</TimeCreated>

<Parameter name="SYSCLASS">
</Parameter>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit $CLASSMETHOD(..#SYSCLASS, "Exists", Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Name) ""
	$$$switchNSSys
	$$$ThrowOnError($CLASSMETHOD(..#SYSCLASS, "Get", Name,.properties))
	Set properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit $CLASSMETHOD(..#SYSCLASS, "Create",model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit $CLASSMETHOD(..#SYSCLASS, "Modify", model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit $CLASSMETHOD(..#SYSCLASS, "Delete",Name)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Names:%String="*"</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	Set list = [], tmp=0
	Try{
		Do ..ExecQry(Names,.tmp)
	}Catch(ex) {
		
		Throw ex
	}
	
	Set k = ""
	For  {
		Set k = $order(tmp(k),1,v)
		Quit:k=""
		Do list.%Push(..Get(v))
	}
	Return list
]]></Implementation>
</Method>

<Method name="ExecQry">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Names,&tmp]]></FormalSpec>
<Implementation><![CDATA[
	$$$switchNSSys
	Try{
		Set tStatement = ##class(%SQL.Statement).%New()
		Set sc = tStatement.%PrepareClassQuery(..#SYSCLASS,"List")
		If $$$ISERR(sc) $$$ThrowStatus(sc)
		Set tResult = tStatement.%Execute(Names)
		If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
		While tResult.%Next() {
			Set tmp($i(tmp))=tResult.%Get("Name")
		}
		Kill tResult,tStatement
	} Catch(ex) {
		Throw ex
	}

	Quit
]]></Implementation>
</Method>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Common.MethodsObjectGenerator">
<IncludeCode>Api.Config.inc</IncludeCode>
<TimeChanged>66011,29867.296361</TimeChanged>
<TimeCreated>66011,29867.296361</TimeCreated>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<ForceGenerate>1</ForceGenerate>
<Implementation><![CDATA[
	Quit:$get(%parameter("SYSCLASS"))="" 1

	New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS", key = ""

	#dim class As %Dictionary.CompiledClass = ##class(%Dictionary.CompiledClass).%OpenId(%parameter("SYSCLASS"))

    For  {
        Set property = class.Properties.GetNext(.key)
        Quit:key="" 
		Set $NAMESPACE = ns, canContinue = ##class(Api.Config.Developers.Helper).skipProperty(property), $NAMESPACE = "%SYS"
		CONTINUE:canContinue
        Do %code.WriteLine($CHAR(9)_$$$FormatText("Set properties(""%1"") = pObj.%1",property.Name))
    }
	Set $NAMESPACE = ns
	Quit 1
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<ForceGenerate>1</ForceGenerate>
<Implementation><![CDATA[
	;Quit:$lf($lfs(%parameter("NOTIN"),","),%class.Name)>0 1
    Quit:$get(%parameter("SYSCLASS"))="" 1

	New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS", key = ""
    
    
    #dim class As %Dictionary.CompiledClass = ##class(%Dictionary.CompiledClass).%OpenId(%parameter("SYSCLASS"))

    For  {
        Set property = class.Properties.GetNext(.key)
        Quit:key="" 
        Set $NAMESPACE = ns, canContinue = ##class(Api.Config.Developers.Helper).skipProperty(property), $NAMESPACE = "%SYS"
		CONTINUE:canContinue
        Set line = $CHAR(9) _ $$$FormatText("Set:$$$CanSetProperty(model,""%1"") properties(""%1"") = model.%1", property.Name)
        Do %code.WriteLine(line)
    }

    Set $NAMESPACE = ns
	
	Quit 1
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<ForceGenerate>1</ForceGenerate>
<Implementation><![CDATA[
	Quit:$get(%parameter("SYSCLASS"))="" 1

	#define GETTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"number",:"string")
    #define GETSWAGGERTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"integer",:"string")

	New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS", key = ""
    
    
    #dim class As %Dictionary.CompiledClass = ##class(%Dictionary.CompiledClass).%OpenId(%parameter("SYSCLASS"))
	Do %code.WriteLine($CHAR(9) _ "Set model = {}")
    For  {
        Set property = class.Properties.GetNext(.key)
        Quit:key="" 
        Set $NAMESPACE = ns, canContinue = ##class(Api.Config.Developers.Helper).skipProperty(property), $NAMESPACE = "%SYS"
		CONTINUE:canContinue
        Set jsonType = $$$GETTYPE($Replace(property.Type, "Library.",""))
        Do %code.WriteLine($CHAR(9) _ $$$FormatText("Do:$Data(properties(""%1"")) model.%Set(""%1"", properties(""%1""), ""%2"")", property.Name, jsonType))
    }
    Do %code.WriteLine($CHAR(9) _ "Quit model")
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Common.Single">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.MethodsObjectGenerator</Super>
<TimeChanged>66011,29867.315817</TimeChanged>
<TimeCreated>66011,29867.315817</TimeCreated>

<Parameter name="SYSCLASS">
</Parameter>

<Parameter name="ISSINGLE">
<Default>1</Default>
</Parameter>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	$$$ThrowOnError($CLASSMETHOD(..#SYSCLASS, "Get", .properties))
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit $CLASSMETHOD(..#SYSCLASS, "Modify", .properties)
]]></Implementation>
</Method>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Common.SwaggerGenerator">
<Description>
Description</Description>
<TimeChanged>66011,29867.334993</TimeChanged>
<TimeCreated>66011,29867.334993</TimeCreated>

<Method name="GetSwaggerDefinition">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<ReturnType>%DynamicObject</ReturnType>
<ForceGenerate>1</ForceGenerate>
<Implementation><![CDATA[
    Set className = $Get(%parameter("SYSCLASS"))
    Quit:className="" 1

    #define GETTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"number",:"string")
    #define GETSWAGGERTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"integer",:"string")

    Set swaggerDef = {
        "type" : "object",
        "properties" : {},
        "required" : []
    }

    Set template = {}, key=""
    Set swaggerDef.example = template
    New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS"
    
    Set obj = $CLASSMETHOD(className, "%New")
    
    #dim class As %Dictionary.CompiledClass = ##class(%Dictionary.CompiledClass).%OpenId(className)

    For  {
        Set property = class.Properties.GetNext(.key)
        Quit:key="" 
        
        Set $NAMESPACE = ns, skip = ##class(Api.Config.Developers.Helper).skipProperty(property), $NAMESPACE = "%SYS"
        Continue:skip
        Set jsonType = $$$GETTYPE($Replace(property.Type, "Library.",""))
        Set swaggerType = $$$GETSWAGGERTYPE($Replace(property.Type, "Library.",""))
    
        Set dflt = $PROPERTY(obj,property.Name)
        Set:$ISOBJECT(dflt) dflt=""
        ;If dflt=""&&property.Required {
            Do:property.Required swaggerDef.required.%Push(property.Name)
            Do template.%Set(property.Name, dflt, jsonType)
        ;}

        Set $NAMESPACE = ns, description = ##class(Api.Config.Developers.Helper).getPropertyDescription(property.Name, className), $NAMESPACE = "%SYS"

        Do swaggerDef.properties.%Set(property.Name, {
            "type" : (swaggerType),
            "default" : (dflt),
            "description" : (description)
        })
    
    }
    
    

    Set $NAMESPACE = ns

    Set defObj = {}
    Set pName = $tr(className,"%.")
    Do defObj.%Set(pName,swaggerDef)

    If '$Get(%parameter("ISSINGLE"),0) {
        Do defObj.%Set("ListOf"_pName,{
            "type":"object",
            "properties":{
                "list" : {
                    "type":"array",
                    "items": {
                        "$ref": ("#/definitions/" _ pName)
                    }
                }
            }
        })
    }
    Do ##class(Api.Config.Developers.Utils).FormatJSON(defObj,.formatted)
    
    Do %code.WriteLine($char(9) _ "Quit "_$Piece(formatted,$$$NL,1))
    For i=2:1:$l(formatted,$$$NL) {
        Do %code.WriteLine($char(9) _ $Piece(formatted,$$$NL,i))
    }
    
    Quit 1
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.ConfigFile">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29867.009815</TimeChanged>
<TimeCreated>66011,29867.009815</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.ConfigFile</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Version="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Version property is mandatory."))
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Databases">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.034557</TimeChanged>
<TimeCreated>66011,29867.034557</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.Databases</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Directory="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Directory property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Debug">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.044653</TimeChanged>
<TimeCreated>66011,29867.044653</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.Debug</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.DeviceSubTypes">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.067526</TimeChanged>
<TimeCreated>66011,29867.067526</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.DeviceSubTypes</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Devices">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.059279</TimeChanged>
<TimeCreated>66011,29867.059279</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.Devices</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Set:model.PhysicalDevice="" sc = $$$ADDSC(sc,$$$ERROR(5001, "PhysicalDevice property is mandatory."))
	Set:model.SubType="" sc = $$$ADDSC(sc,$$$ERROR(5001, "SubType property is mandatory."))
	Set:model.Type="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Type property is mandatory."))
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.ECP">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29867.080889</TimeChanged>
<TimeCreated>66011,29867.080889</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.ECP</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.ECPServers">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.10247</TimeChanged>
<TimeCreated>66011,29867.10247</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.ECPServers</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Address="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Address property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.IO">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29867.092528</TimeChanged>
<TimeCreated>66011,29867.092528</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.IO</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.Journal">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29867.118342</TimeChanged>
<TimeCreated>66011,29867.118342</TimeCreated>

<Parameter name="SYSCLASS">
<Description>
Description</Description>
<Default>Config.Journal</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.Library.SQLConnection">
<Description>
Description</Description>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.322402</TimeChanged>
<TimeCreated>66011,29867.322402</TimeCreated>

<Parameter name="SYSCLASS">
<Default>%Library.SQLConnection</Default>
</Parameter>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
    Quit ##class(%Library.SQLConnection).NameIndexExists(Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Name) ""
	$$$switchNSSys
	Set obj = ##class(%Library.SQLConnection).NameIndexOpen(Name)
    Do ..ObjectToArray(obj,.properties)
    Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..Update(model)
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
    Set obj = ##class(%Library.SQLConnection).NameIndexOpen(model.Name)
    Set:'$ISOBJECT(obj) obj = ##class(%Library.SQLConnection).%New()
	Set:(model.%IsDefined("DSN")&&($Ascii(model.%Get("DSN"))'=0)) obj.DSN = model.DSN
	Set:(model.%IsDefined("Name")&&($Ascii(model.%Get("Name"))'=0)) obj.Name = model.Name
	Set:(model.%IsDefined("OnConnectStatement")&&($Ascii(model.%Get("OnConnectStatement"))'=0)) obj.OnConnectStatement = model.OnConnectStatement
	Set:(model.%IsDefined("ReverseOJ")&&($Ascii(model.%Get("ReverseOJ"))'=0)) obj.ReverseOJ = model.ReverseOJ
	Set:(model.%IsDefined("URL")&&($Ascii(model.%Get("URL"))'=0)) obj.URL = model.URL
	Set:(model.%IsDefined("Usr")&&($Ascii(model.%Get("Usr"))'=0)) obj.Usr = model.Usr
	Set:(model.%IsDefined("bUnicodeStream")&&($Ascii(model.%Get("bUnicodeStream"))'=0)) obj.bUnicodeStream = model.bUnicodeStream
	Set:(model.%IsDefined("bindTSasString")&&($Ascii(model.%Get("bindTSasString"))'=0)) obj.bindTSasString = model.bindTSasString
	Set:(model.%IsDefined("classpath")&&($Ascii(model.%Get("classpath"))'=0)) obj.classpath = model.classpath
	Set:(model.%IsDefined("driver")&&($Ascii(model.%Get("driver"))'=0)) obj.driver = model.driver
	Set:(model.%IsDefined("isJDBC")&&($Ascii(model.%Get("isJDBC"))'=0)) obj.isJDBC = model.isJDBC
	Set:(model.%IsDefined("needlongdatalen")&&($Ascii(model.%Get("needlongdatalen"))'=0)) obj.needlongdatalen = model.needlongdatalen
	Set:(model.%IsDefined("noconcat")&&($Ascii(model.%Get("noconcat"))'=0)) obj.noconcat = model.noconcat
	Set:(model.%IsDefined("nodefq")&&($Ascii(model.%Get("nodefq"))'=0)) obj.nodefq = model.nodefq
	Set:(model.%IsDefined("nofnconv")&&($Ascii(model.%Get("nofnconv"))'=0)) obj.nofnconv = model.nofnconv
	Set:(model.%IsDefined("nvl")&&($Ascii(model.%Get("nvl"))'=0)) obj.nvl = model.nvl
	Set:(model.%IsDefined("properties")&&($Ascii(model.%Get("properties"))'=0)) obj.properties = model.properties
	Set:(model.%IsDefined("pwd")&&($Ascii(model.%Get("pwd"))'=0)) obj.pwd = model.pwd
	Set:(model.%IsDefined("useCAST")&&($Ascii(model.%Get("useCAST"))'=0)) obj.useCAST = model.useCAST
	Set:(model.%IsDefined("useCASTCHAR")&&($Ascii(model.%Get("useCASTCHAR"))'=0)) obj.useCASTCHAR = model.useCASTCHAR
	Set:(model.%IsDefined("useCOALESCE")&&($Ascii(model.%Get("useCOALESCE"))'=0)) obj.useCOALESCE = model.useCOALESCE
	Set:(model.%IsDefined("xadriver")&&($Ascii(model.%Get("xadriver"))'=0)) obj.xadriver = model.xadriver
    Quit obj.%Save()
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
    Quit ##class(%Library.SQLConnection).NameIndexDelete(Name)
]]></Implementation>
</Method>

<Method name="ExecQry">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Names,&tmp]]></FormalSpec>
<Implementation><![CDATA[
	$$$switchNSSys
	Try{
		Set tStatement = ##class(%SQL.Statement).%New()
		Set sc = tStatement.%PrepareClassQuery(..#SYSCLASS,"ByName")
		If $$$ISERR(sc) $$$ThrowStatus(sc)
		Set tResult = tStatement.%Execute(Names)
		If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
		While tResult.%Next() {
			Set tmp($i(tmp))=tResult.%Get("Connection_Name")
		}
		Kill tResult,tStatement
	} Catch(ex) {
		Throw ex
	}

	Quit
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.LicenseServers">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.116361</TimeChanged>
<TimeCreated>66011,29867.116361</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.LicenseServers</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Loader">
<Description>
Description</Description>
<TimeChanged>66011,29867.135413</TimeChanged>
<TimeCreated>66011,29867.135413</TimeCreated>

<Method name="test">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    ;d ##class(Api.Config.Services.Loader).test()
    

    Set cfg2 = {
        "Defaults":{
            "DBDIR" : "${MGRDIR}",
            "WEBAPPDIR" : "${CSPDIR}",
            "DBDATA" : "${DBDIR}myappdata/",
            "DBARCHIVE" : "${DBDIR}myapparchive/",
            "DBCODE" : "${DBDIR}myappcode/",
            "DBLOG" : "${DBDIR}myapplog/"
        },
        "SYS.Databases":{
            "${DBDATA}" : {"ExpansionSize":128},
            "${DBARCHIVE}" : {},
            "${DBCODE}" : {},
            "${DBLOG}" : {}
        },
        "Databases":{
            "MYAPPDATA" : {
                "Directory" : "${DBDATA}"
            },
            "MYAPPCODE" : {
                "Directory" : "${DBCODE}"
            },
            "MYAPPARCHIVE" : {
                "Directory" : "${DBARCHIVE}"
            },
            "MYAPPLOG" : {
                "Directory" : "${DBLOG}"
            }
        },
        "Namespaces":{
            "MYAPP": {
                "Globals":"MYAPPDATA",
                "Routines":"MYAPPCODE"
            }
        },
        "Security.Applications": {
            "/csp/zrestapp": {
                "DispatchClas" : "my.dispatch.class",
                "Namespace" : "MYAPP",
                "Enabled" : "1",
                "AuthEnabled": "64",
                "CookiePath" : "/csp/zrestapp/"
            },
            "/csp/zwebapp": {
                "Path": "${WEBAPPDIR}",
                "Namespace" : "MYAPP",
                "Enabled" : "1",
                "AuthEnabled": "64",
                "CookiePath" : "/csp/zwebapp/"
            }
        },
        "MapGlobals":{
            "MYAPP": [{
                "Name" : "Archive.Data",
                "Database" : "MYAPPARCHIVE"
            },{
                "Name" : "App.Log",
                "Database" : "MYAPPLOG"
            }]
        },
        "MapPackages": {
            "MYAPP": [{
                "Namespace" : "MYAPP",
                "Name" : "PackageName",
                "Database" : "USER"
            }]
        },
        "MapRoutines": {
            "MYAPP": [{
                "Namespace" : "MYAPP",
                "Name" : "RoutineName",
                "Database" : "USER"
            }]
        },
        "Journal": {
            "FreezeOnError":1
        },
        "Security.Services":{   
            "%Service_Mirror": {
                "Enabled" : 0
            }
        },
        "SQL": {
            "LockThreshold" : 2500
        },
        "config": {
            "locksiz" : 33554432
        },
        "Startup":{
            "SystemMode" : "DEVELOPMENT"
        }
    }
    zw ..Load(cfg2)
]]></Implementation>
</Method>

<Method name="Load">
<Description>
Model can be : 
* a %String with the path to the JSON Document.
* a stream contain JSON Document
* a %DynamicObject</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[model:%DynamicObject,&params]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set params=""
    Set:'$d(params("IFEXISTS")) params("IFEXISTS")="Update"
    Try {
        Set sc = ..commonLoad(model, "Create",.params)
    } Catch(ex) {
        Set sc = ex.AsStatus()
        Do $SYSTEM.Status.DecomposeStatus(sc,.err)
        Zw err
    }
    
    Return sc
]]></Implementation>
</Method>

<Method name="LoadFromInvoke">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%DynamicObject,args...</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set params=""
    If +$g(args)>0 {
        For i=1:2:args {
            Set params(args(i))=$GET(args(i+1))
        }
    }
    ;Set:'$d(params("IFEXISTS")) params("IFEXISTS")="Update"
    Try {
        Set sc = ..commonLoad(model, "Create",.params)
    } Catch(ex) {
        Set sc = ex.AsStatus()
        Do $SYSTEM.Status.DecomposeStatus(sc,.err)
        Zw err
    }
    
    Return sc
]]></Implementation>
</Method>

<Method name="Delete">
<Description>
Delete all namespaces, database, mapping, ... in configuration document.
Be careful...  (return an error on System mode LIVE.)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set startup = ##class(Api.Config.Services.Startup).Get()
    If startup.SystemMode = "LIVE" {
        Quit $$$ERROR(5001, "Not allowed on LIVE system")
    }
    Set params = ""
    Quit ..commonLoad(model, "Delete", .params)
]]></Implementation>
</Method>

<Method name="commonLoad">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[model:%DynamicObject,action:%String,&params:%Binary]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #def1arg    log(%arg)       Do ..log(%arg)
    #define     CFGCLASS(%cls)  "Api.Config.Services."_%cls    
    New $NAMESPACE
    Set sc = $$$OK, sc2 = $$$OK

    If '$ISOBJECT(model) {  ; filename
        Do ..log("Load from file "_model_" ... ")
        If '##class(%File).Exists(model) {
            Do ..log("file not found.",0)
            Quit $$$ERROR(5001, "File not found.")
        }
        #dim file As %Stream.FileCharacter = ##class(%Stream.FileCharacter).%New()
        Do file.LinkToFile(model)
        Set model = {}.%FromJSON(file)
    } ElseIf model.%IsA("%Stream.Object") {
        Do ..log("Load from stream ... ")
        Set model = {}.%FromJSON(model)
    }

    
    ;If model.%IsA()
    
    $$$log("Start load configuration")
    
    Set processedConfig = ..processConfig(model,.params)

    Do ##class(Api.Config.Developers.Utils).FormatJSON(processedConfig, .swaggerString)
    
    $$$log(swaggerString)

    Set iter = processedConfig.%GetIterator()

    While iter.%GetNext(.key,.value) {
        $$$log(" * "_key)
        
        If '##class(%Dictionary.CompiledClass).%ExistsId($$$CFGCLASS(key)) {
            $$$log(" Class not found (skipped)",0)
            CONTINUE
        }
        
        If $$$LOWER(key) = "zpm" {
            Set iterLvl2 = value.%GetIterator()
            While iterLvl2.%GetNext(.keyLvl2,.valueLvl2) {
                Try {
                    Set iterLvl3 = valueLvl2.%GetIterator()
                    While iterLvl3.%GetNext(.keyLvl3,.valueLvl3) { 
                        If $ISOBJECT(valueLvl3) {
                            Set iterLvl4 = valueLvl3.%GetIterator()
                            While iterLvl4.%GetNext(.keyLvl4,.valueLvl4) {
                                $$$log("   + Execute "_keyLvl4 _" "_valueLvl4_" ... ")
                                Set sc2 = ##class(Api.Config.Services.ZPM).Execute(keyLvl2, keyLvl4, valueLvl4, $Get(args("pTerminateOnError"),0))
                                Set:$$$ISERR(sc2) sc = $$$ADDSC(sc,sc2)
                            }
                        } Else {
                            $$$log("   + Execute "_valueLvl3_" ... ")
                            Set sc2 = ##class(Api.Config.Services.ZPM).Execute(keyLvl2,"",valueLvl3, $Get(args("pTerminateOnError"), 0))
                        }
                        
                        Set:$$$ISERR(sc2) sc = $$$ADDSC(sc,sc2)
                    }

                } Catch(ex) {
                    Set sc = $$$ADDSC(sc,ex.AsStatus())
                }
                
            }
            CONTINUE
        }

        Set rAction = action
        Set isSingle = $PARAMETER($$$CFGCLASS(key),"ISSINGLE")=1
        Set isMap = $PARAMETER($$$CFGCLASS(key),"ISMAP")=1

        If isSingle { ; singleton params (only update allowed)
            
            Set:action="Create" rAction = "Update"

            $$$log("   + "_rAction _" "_key_" ... ")

            If action = "Delete" {
                $$$log("Not Allowed (skipping)",0)
                CONTINUE
            }
            
            Set sc2 = $CLASSMETHOD($$$CFGCLASS(key), rAction, value)
            Set sc = $$$ADDSC(sc,sc2)
            $$$log($SYSTEM.Status.GetOneErrorText(sc2),0)
            CONTINUE
        }

        If value.%IsA("%DynamicArray") {
            Set iterLvl2 = value.%GetIterator()
            While iterLvl2.%GetNext(.keyLvl3,.valueLvl2) {
                $$$log("   + "_rAction _" " _ valueLvl2.%ToJSON() _ " ... ")
                If rAction = "Delete" {
                    ; Set sc2 = $CLASSMETHOD($$$CFGCLASS(key), rAction, id1, id2)
                } Else {
                    Set sc2 = $CLASSMETHOD($$$CFGCLASS(key), rAction, valueLvl2)
                }
                Set sc = $$$ADDSC(sc,sc2)
                $$$log($SYSTEM.Status.GetOneErrorText(sc2),0)
            }
            CONTINUE
        }

        Set iterLvl2 = value.%GetIterator()
        While iterLvl2.%GetNext(.keyLvl2,.valueLvl2) {
            Set rAction = action

            If $PARAMETER($$$CFGCLASS(key),"UPDATEONLY") {
                Set:rAction="Create" rAction = "Update"
                If rAction="Delete" {
                    $$$log("Not Allowed (skipping)",0)
                     CONTINUE
                }
               
            }
            

            If isMap {  ; identifier with 2 properties
                
                Set pIDS = $PARAMETER($$$CFGCLASS(key),"PIDENTIFIER")
                ;Set id1 = valueLvl2.%Get($PIECE(pIDS,",",1))
                Set id1 = keyLvl2
                
                Set iterLvl3 = valueLvl2.%GetIterator()
                While iterLvl3.%GetNext(.keyLvl3,.valueLvl3) {
                    Do valueLvl3.%Set($PIECE(pIDS,",",1),id1)
                    Set id2 = valueLvl3.%Get($PIECE(pIDS,",",2))

                    $$$log("   + "_rAction _" " _ id1 _ " " _ id2 _ " ... ")
                    Set exists = $CLASSMETHOD($$$CFGCLASS(key),"Exists",id1, id2)

                    If rAction="Delete" && 'exists {
                        $$$log("Does not exists (skipping)",0)
                        CONTINUE
                    }

                    If rAction="Create" && exists {
                        If $Get(params("IFEXISTS"))="Update" {
                            $$$log("Already exists (updating) ",0)
                            Set rAction = "Update"
                        } Else {
                            $$$log("Already exists (skipping)",0)
                            CONTINUE
                        }
                    }

                    If rAction = "Delete" {
                        Set sc2 = $CLASSMETHOD($$$CFGCLASS(key), rAction, id1, id2)
                    } Else {
                        Set sc2 = $CLASSMETHOD($$$CFGCLASS(key), rAction, valueLvl3)
                    }
                    Set sc = $$$ADDSC(sc,sc2)
                    $$$log($SYSTEM.Status.GetOneErrorText(sc2),0)
                   
                }
                CONTINUE
            }

            Do ..SetName(key,.valueLvl2,keyLvl2)
            $$$log("   + "_rAction _" "_keyLvl2_" ... ")
            
            Set exists = $CLASSMETHOD($$$CFGCLASS(key),"Exists",keyLvl2)

            If rAction="Delete" && 'exists {
                $$$log("Does not exists (skipping)",0)
                CONTINUE
            }

            If rAction="Create" && exists {
                If $Get(params("IFEXISTS"))="Update" {
                    Set rAction = "Update"
                     $$$log("Already exists (updating) ",0)
                } Else {
                    $$$log("Already exists (skipping)",0)
                    CONTINUE
                }
            }
            
            If rAction = "Delete" {
                Set sc2 = $CLASSMETHOD($$$CFGCLASS(key), rAction, keyLvl2)
            } Else {
                Set sc2 = $CLASSMETHOD($$$CFGCLASS(key), rAction, valueLvl2)
            }
            Set sc = $$$ADDSC(sc,sc2)
            $$$log($SYSTEM.Status.GetOneErrorText(sc2),0)
        }
    }

    Return sc
]]></Implementation>
</Method>

<Method name="SetName">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[key:%String,&model:%DynamicObject,keyLvl2:%String]]></FormalSpec>
<Implementation><![CDATA[
    Set nameProperty = $PARAMETER("Api.Config.Services."_key,"PNAME")
    If nameProperty="" {
        Set model.Name = keyLvl2
        Quit
    }
    Do model.%Set(nameProperty, keyLvl2)
    Quit
]]></Implementation>
</Method>

<Method name="log">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>msg:%String,newLine:%Boolean=$$$YES,dtOnNewLine:%Boolean=$$$YES</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Write:newLine !
    Write:newLine&&dtOnNewLine $zdatetime($h,3,1), " "
    Write msg
    Return sc
]]></Implementation>
</Method>

<Method name="export">
<Description>
OnlyNotDefaultValue : properties with the default value won't exported.  
toFile : if you want to export to a file, fill toFile argument with the filepath.  </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filter:%DynamicObject={{}},OnlyNotDefaultValue:%Boolean=1,toFile:%String=""</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    ; Do ##class(Api.Config.Services.Loader).export()
    #define     CFGCLASS(%cls)  "Api.Config.Services."_%cls

    #dim export As %DynamicObject = {}

    #dim processedFilter As %DynamicObject = ..processConfig(filter)
    
    Set iter = processedFilter.%GetIterator()

    While iter.%GetNext(.key,.value) {
        $$$log(" * "_key)
        If '##class(%Dictionary.CompiledClass).%ExistsId($$$CFGCLASS(key)) {
            $$$log(" class not found (skipped)",0)
            CONTINUE
        }
        
        Set isSingle = $PARAMETER($$$CFGCLASS(key),"ISSINGLE")=1
        Set isMap = $PARAMETER($$$CFGCLASS(key),"ISMAP")=1

        If isSingle { ; 

            Set params = $CLASSMETHOD($$$CFGCLASS(key),"Get")
            Do:OnlyNotDefaultValue ..removeDefaultValue(key,.params)
            Do ..ApplyFilter(value,.params)
            Do export.%Set(key, params)
            CONTINUE

        }

        Set tmpObj = {}
        Do export.%Set(key,tmpObj)

        If isMap {
            Set lvl2keyProp = $PIECE($PARAMETER($$$CFGCLASS(key),"PIDENTIFIER"),",",1)
            
            If '$ISOBJECT(value) {
                Set listKey1 = $CLASSMETHOD($$$CFGCLASS(key),"ListKey1")
                Set ptr = 0
                While $LISTNEXT(listKey1,ptr,vlKey1)  {
                    Set lst = $CLASSMETHOD($$$CFGCLASS(key),"List",vlKey1) 
                    Do tmpObj.%Set(vlKey1, lst)
                }
            } Else {

                Set iterList = value.%GetIterator(), lst = []
                While iterList.%GetNext(.keylist,.vl) {
                    Set lst = $CLASSMETHOD($$$CFGCLASS(key),"List",keylist) 
                        Do tmpObj.%Set(keylist, lst)
                    
                }
            }
            CONTINUE
        }

        
        Set lst = [], lvl2keyProp = $PARAMETER($$$CFGCLASS(key),"PNAME")
        Set:lvl2keyProp="" lvl2keyProp="Name"
        
        If $ISOBJECT(value) {

            Set iterList = value.%GetIterator()
            While iterList.%GetNext(.keylist,.vl) {
                
                If $CLASSMETHOD($$$CFGCLASS(key),"Exists",keylist) {
                    Do lst.%Push($CLASSMETHOD($$$CFGCLASS(key),"Get",keylist))
                }
            }

        } Else {
            Set lst = $CLASSMETHOD($$$CFGCLASS(key),"List")
        }

        Set iterList = lst.%GetIterator()
        While iterList.%GetNext(.keylist,.vl) {
            Do tmpObj.%Set($Property(vl,lvl2keyProp), vl)
            Do:OnlyNotDefaultValue ..removeDefaultValue(key,.vl)
        }
    }

    Set formatter=##class(%JSON.Formatter).%New()
    Set exportStr = ""
    Do formatter.FormatToString(export, .exportStr)
    
    If toFile '= "" {
        Do ..toFile(export, toFile)
    }

    Quit export
]]></Implementation>
</Method>

<Method name="ApplyFilter">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[filter:%DynamicObject,&model:%DynamicObject]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    
    if '$ISOBJECT(filter) {
        Quit $$$OK
    }

    Set iter = model.%GetIterator()

    While iter.%GetNext(.key,.value) {
        Do:'filter.%IsDefined(key) model.%Remove(key)
    }

    Quit $$$OK
]]></Implementation>
</Method>

<Method name="removeDefaultValue">
<ClassMethod>1</ClassMethod>
<FormalSpec>key:%String,model:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    /*If key [ "." {
        Set className = key
        Set:$PIECE(className,".")="Library" $PIECE(className,".")="%Library"
    } Else {
        Set className = "Config."_key
    }*/

    Set className = $CLASSMETHOD("Api.Config.Services."_key,"%GetParameter","SYSCLASS")
    New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS"
    Set obj = $CLASSMETHOD(className,"%New")
    Try {
        Set iter = model.%GetIterator()
        While iter.%GetNext(.property,.value) {
            If ##class(%Dictionary.CompiledProperty).%ExistsId(className_"||"_property) {
                
                If $PROPERTY(obj,property)=$PROPERTY(model,property) {
                    Do model.%Remove(property)
                }
            }
        }
    } Catch(ex) {
        Set sc = ex.AsStatus()
    }
    Set $NAMESPACE = ns

    Quit sc
]]></Implementation>
</Method>

<Method name="processConfig">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[config:%DynamicObject,&params]]></FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set:'$ISOBJECT(config.Defaults) config.Defaults = {}
	
	Set processedConfig = config.%ToJSON()
	
	Set installDir = $SYSTEM.Util.InstallDirectory()
	
	Set replaceString("${MGRDIR}") = $SYSTEM.Util.ManagerDirectory()
	Set replaceString("${CSPDIR}") = ##class(%File).NormalizeDirectory("csp", installDir)
    Set replaceString("${BINDIR}") = $SYSTEM.Util.BinaryDirectory()
    Set replaceString("${LIBDIR}") = ##class(%File).NormalizeDirectory("lib", installDir)
    Set replaceString("${NAMESPACE}") = $NAMESPACE
    Set replaceString("${USERNAME}") = $USERNAME
    Set replaceString("${ROLES}") = $ROLES
    Set replaceString("${SYSTEM}") = $SYSTEM
    

    Set replaceString("${mgrdir}") = $SYSTEM.Util.ManagerDirectory()
	Set replaceString("${cspdir}") = ##class(%File).NormalizeDirectory("csp", installDir)
    Set replaceString("${bindir}") = $SYSTEM.Util.BinaryDirectory()
    Set replaceString("${libdir}") = ##class(%File).NormalizeDirectory("lib", installDir)
    Set replaceString("${namespace}") = $NAMESPACE
    Set replaceString("${username}") = $USERNAME
    Set replaceString("${roles}") = $ROLES
    Set replaceString("${system}") = $SYSTEM

    Set k = ""
    For  {
        Set k = $ORDER(params(k),1,value)
        Quit:k=""
        Set replaceString( "${"_k_"}" ) = value
    }

	#dim iter As %Iterator.Object = config.Defaults.%GetIterator()
	
	While iter.%GetNext(.property, .value) {
		Set:'$Data(params(property)) replaceString( "${"_property_"}" ) = value
	}
	
	Do {
		Set i = $Increment(i), var = ""
		
		For  {
			Set var = $Order(replaceString(var), 1, value)
			Quit:var=""
			Set processedConfig = $Replace(processedConfig, var, $zconvert(value,"O","JS"))
		}
		
	} While (i < 3)	
	
    Set model = {}.%FromJSON(processedConfig)
    Do model.%Remove("Defaults")
    Quit model
]]></Implementation>
</Method>

<Method name="toFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>object:%DynamicObject,filename:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set dir = ##class(%File).GetDirectory(filename)
    
    If '##class(%File).DirectoryExists(dir) {
        Set created = ##class(%File).CreateDirectoryChain(dir)
        Quit:'created $$$ERROR(5001, "Fail to create directory chain")
    }

    Set configString = ""
   
    Do ##class(Api.Config.Developers.Utils).FormatJSON(object, .configString)

    #dim file As %Stream.FileCharacter = ##class(%Stream.FileCharacter).%New()
    $$$QuitOnError(file.LinkToFile(filename))
    Do file.Write(configString)
    Quit file.%Save()
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.MagTapes">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.143006</TimeChanged>
<TimeCreated>66011,29867.143006</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.MagTapes</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Set:model.SystemDevice="" sc = $$$ADDSC(sc,$$$ERROR(5001, "SystemDevice property is mandatory."))
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.MapGlobals">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.MethodsObjectGenerator</Super>
<TimeChanged>66011,29867.157437</TimeChanged>
<TimeCreated>66011,29867.157437</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.MapGlobals</Default>
</Parameter>

<Parameter name="ISMAP">
<Default>1</Default>
</Parameter>

<Parameter name="PIDENTIFIER">
<Default>Namespace,Name</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Database="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Database property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Set:model.Namespace="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Namespace property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapGlobals).Create(model.Namespace,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapGlobals).Modify(model.Namespace,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapGlobals).Delete(Namespace,Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapGlobals).Exists(Namespace,Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Namespace,Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.MapGlobals).Get(Namespace,Name,.properties))
	Set properties("Name") = Name, properties("Namespace") = Namespace
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Names:%String="*"</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set tStatement = ##class(%SQL.Statement).%New()
		Set sc = tStatement.%PrepareClassQuery(..#SYSCLASS,"List")
		If $$$ISERR(sc) $$$ThrowStatus(sc)
		Set tResult = tStatement.%Execute(Namespace,Names)
		If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
		While tResult.%Next() {
			;Set tmp($i(tmp))=tResult.%Get("Name")
			Do list.%Push(..Get(Namespace, tResult.%Get("Name")))
		}
		Kill tResult,tStatement

		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ListKey1">
<ClassMethod>1</ClassMethod>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	Set l = ""
	Do ##class(Api.Config.Services.Namespaces).ExecQry("*",.tmp)
	Set key = ""
	For  {
		Set key = $Order(tmp(key),1,k1)
		Quit:key=""
		Set $list(l,key)=k1
	}
	Return l
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.MapMirrors">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.MethodsObjectGenerator</Super>
<TimeChanged>66011,29867.165103</TimeChanged>
<TimeCreated>66011,29867.165103</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.MapMirrors</Default>
</Parameter>

<Parameter name="ISMAP">
<Default>1</Default>
</Parameter>

<Parameter name="PIDENTIFIER">
<Default>ID,Name</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.GUID="" sc = $$$ADDSC(sc,$$$ERROR(5001, "GUID property is mandatory."))
	Set:model.ID="" sc = $$$ADDSC(sc,$$$ERROR(5001, "ID property is mandatory."))
	Set:model.InstanceDirectory="" sc = $$$ADDSC(sc,$$$ERROR(5001, "InstanceDirectory property is mandatory."))
	Set:model.MirrorAddress="" sc = $$$ADDSC(sc,$$$ERROR(5001, "MirrorAddress property is mandatory."))
	Set:model.MirrorSSPort="" sc = $$$ADDSC(sc,$$$ERROR(5001, "MirrorSSPort property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapMirrors).Create(model.ID,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapMirrors).Delete(ID,Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapMirrors).Exists(ID,Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(ID,Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.MapMirrors).Get(ID,Name,.properties))
	Set properties("ID") = ID, properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Names:%String="*"</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set tStatement = ##class(%SQL.Statement).%New()
		Set sc = tStatement.%PrepareClassQuery(..#SYSCLASS,"List")
		If $$$ISERR(sc) $$$ThrowStatus(sc)
		Set tResult = tStatement.%Execute(ID,Names)
		If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
		While tResult.%Next() {
			Do list.%Push(..Get(ID, tResult.%Get("Name")))
		}
		Kill tResult,tStatement
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapMirrors).Modify(model.ID,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="ListKey1">
<ClassMethod>1</ClassMethod>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	Set l = ""
	Do ##class(Api.Config.Services.Mirrors).ExecQry("*",.tmp)
	Set key = ""
	For  {
		Set key = $Order(tmp(key),1,k1)
		Quit:key=""
		Set $list(l,key)=k1
	}
	Return l
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.MapPackages">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.MethodsObjectGenerator</Super>
<TimeChanged>66011,29867.177274</TimeChanged>
<TimeCreated>66011,29867.177274</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.MapPackages</Default>
</Parameter>

<Parameter name="ISMAP">
<Default>1</Default>
</Parameter>

<Parameter name="PIDENTIFIER">
<Default>Namespace,Name</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Database="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Database property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Set:model.Namespace="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Namespace property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapPackages).Create(model.Namespace,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapPackages).Delete(Namespace,Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapPackages).Exists(Namespace,Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Namespace,Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.MapPackages).Get(Namespace,Name,.properties))
	Set properties("Namespace") = Namespace, properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Names:%String="*"</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set tStatement = ##class(%SQL.Statement).%New()
		Set sc = tStatement.%PrepareClassQuery(..#SYSCLASS,"List")
		If $$$ISERR(sc) $$$ThrowStatus(sc)
		Set tResult = tStatement.%Execute(Namespace,Names)
		If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
		While tResult.%Next() {
			Do list.%Push(..Get(Namespace, tResult.%Get("Name")))
		}
		Kill tResult,tStatement
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapPackages).Modify(model.Namespace,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="ListKey1">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Return ##class(Api.Config.Services.MapGlobals).ListKey1()
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.MapRoutines">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.MethodsObjectGenerator</Super>
<TimeChanged>66011,29867.182509</TimeChanged>
<TimeCreated>66011,29867.182509</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.MapRoutines</Default>
</Parameter>

<Parameter name="ISMAP">
<Default>1</Default>
</Parameter>

<Parameter name="PIDENTIFIER">
<Default>Namespace,Name</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Database="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Database property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Set:model.Namespace="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Namespace property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapRoutines).Create(model.Namespace,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapRoutines).Delete(Namespace,Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapRoutines).Exists(Namespace,Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Namespace,Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.MapRoutines).Get(Namespace,Name,.properties))
	Set properties("Namespace") = Namespace, properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Names:%String="*"</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set tStatement = ##class(%SQL.Statement).%New()
		Set sc = tStatement.%PrepareClassQuery(..#SYSCLASS,"List")
		If $$$ISERR(sc) $$$ThrowStatus(sc)
		Set tResult = tStatement.%Execute(Namespace,Names)
		If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
		While tResult.%Next() {
			Do list.%Push(..Get(Namespace, tResult.%Get("Name")))
		}
		Kill tResult,tStatement
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapRoutines).Modify(model.Namespace,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="ListKey1">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Return ##class(Api.Config.Services.MapGlobals).ListKey1()
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.MapShadows">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.MethodsObjectGenerator</Super>
<TimeChanged>66011,29867.201499</TimeChanged>
<TimeCreated>66011,29867.201499</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.MapShadows</Default>
</Parameter>

<Parameter name="ISMAP">
<Default>1</Default>
</Parameter>

<Parameter name="PIDENTIFIER">
<Default>ID,Name</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Directory="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Directory property is mandatory."))
	Set:model.ID="" sc = $$$ADDSC(sc,$$$ERROR(5001, "ID property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapShadows).Create(model.ID,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapShadows).Delete(ID,Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapShadows).Exists(ID,Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(ID,Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.MapShadows).Get(ID,Name,.properties))
	Set properties("ID") = ID, properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Names:%String="*"</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set tStatement = ##class(%SQL.Statement).%New()
		Set sc = tStatement.%PrepareClassQuery(..#SYSCLASS,"List")
		If $$$ISERR(sc) $$$ThrowStatus(sc)
		Set tResult = tStatement.%Execute(ID,Names)
		If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
		While tResult.%Next() {
			Do list.%Push(..Get(ID, tResult.%Get("Name")))
		}
		Kill tResult,tStatement
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapShadows).Modify(model.ID,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="ListKey1">
<ClassMethod>1</ClassMethod>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	Set l = ""
	Do ##class(Api.Config.Services.Shadows).ExecQry("*",.tmp)
	Set key = ""
	For  {
		Set key = $Order(tmp(key),1,k1)
		Quit:key=""
		Set $list(l,key)=k1
	}
	Return l
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.MirrorMember">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29867.191594</TimeChanged>
<TimeCreated>66011,29867.191594</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.MirrorMember</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.Mirrors">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.221948</TimeChanged>
<TimeCreated>66011,29867.221948</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.Mirrors</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="ExecQry">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Names,&tmp]]></FormalSpec>
<Implementation><![CDATA[
	$$$switchNSSys
	Try{
		Set rs = ##class(%ResultSet).%New(..#SYSCLASS_":List")
		Set sc = rs.Execute(Names)
		If $$$ISERR(sc) $$$ThrowStatus(sc)
		While rs.Next() {
			Set tmp($i(tmp))=rs.Get("Name")
		}
		Do rs.Close()
		Kill rs
	} Catch(ex) {
		Throw ex
	}

	Quit
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Miscellaneous">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29867.203646</TimeChanged>
<TimeCreated>66011,29867.203646</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.Miscellaneous</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.Monitor">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29867.218618</TimeChanged>
<TimeCreated>66011,29867.218618</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.Monitor</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.Namespaces">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.224768</TimeChanged>
<TimeCreated>66011,29867.224768</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.Namespaces</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Globals="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Globals property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Set:model.Routines="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Routines property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="ExecQry">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Names,&tmp]]></FormalSpec>
<Implementation><![CDATA[
	$$$switchNSSys
	Try{
		Set tStatement = ##class(%SQL.Statement).%New()
		Set sc = tStatement.%PrepareClassQuery(..#SYSCLASS,"List")
		If $$$ISERR(sc) $$$ThrowStatus(sc)
		Set tResult = tStatement.%Execute(Names)
		If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
		While tResult.%Next() {
			Set tmp($i(tmp))=tResult.%Get("Namespace")
		}
		Kill tResult,tStatement
	} Catch(ex) {
		Throw ex
	}

	Quit
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.SQL">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29867.246412</TimeChanged>
<TimeCreated>66011,29867.246412</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.SQL</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.SYS.Databases">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.MethodsObjectGenerator</Super>
<TimeChanged>66011,29867.352326</TimeChanged>
<TimeCreated>66011,29867.352326</TimeCreated>

<Parameter name="SYSCLASS">
<Default>SYS.Database</Default>
</Parameter>

<Parameter name="PNAME">
<Default>Directory</Default>
</Parameter>

<Parameter name="PIDENTIFIER">
<Default>Directory</Default>
</Parameter>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Do:'##class(%File).DirectoryExists(model.Directory) ##class(%File).CreateDirectoryChain(model.Directory)
    Set db=##Class(SYS.Database).%New()
    Set lbProperties = $$$DBSysCreateProperties
    Do ..ToArray(model, .properties)
    Set key = ""
    For  {
        Set key = $Order(properties(key),1,value)
        Quit:key=""
        If ''$LISTFIND(lbProperties,key) {  ; can set this property on create.
            Set $Property(db, key) = value
        }
    }
	Quit db.%Save()
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(SYS.Database).DeleteDatabase(Directory)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$switchNSSys
    Quit ##class(SYS.Database).%ExistsId(Directory)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Directory) ""
	$$$switchNSSys
    Set DBObj = ##class(SYS.Database).%OpenId(Directory,,.sc)
    If $$$ISERR(sc) $$$ThrowStatus(sc)
    Do ..ObjectToArray(DBObj, .properties)
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>mask:%String="*"</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
    $$$switchNSSys
    Set dbList = []
	Try{
        Set tStatement = ##class(%SQL.Statement).%New()
        Set sc = tStatement.%PrepareClassQuery(..#SYSCLASS,"CompactLocalList")
        If $$$ISERR(sc) $$$ThrowStatus(sc)
        Set tResult = tStatement.%Execute(mask)
        If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
		While tResult.%Next() {
            Do dbList.%Push(..Get(tResult.%Get("Directory")))
        }
		kill tStatement, tResult
        $$$restoreNS

	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return dbList
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
    Set db=##Class(SYS.Database).%OpenId(model.Directory,,.sc)
    If $$$ISERR(sc) $$$ThrowStatus(sc)
    
    Set lbProperties = $$$DBSysUpdateProperties

    Set key = ""
    For  {
        Set key = $Order(properties(key),1,value)
        Quit:key=""
        If ''$LISTFIND(lbProperties,key) {  ; can set this property on update.
            Set $Property(db, key) = value
        }
    }
	Quit db.%Save()
]]></Implementation>
</Method>

<Method name="Dismount">
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$switchNSSys
    Set db = ##class(SYS.Database).%OpenId(Directory,,.sc)
    If $$$ISERR(sc) $$$ThrowStatus(sc)
    Quit:'db.Mounted $$$OK
    Quit db.Dismount()
]]></Implementation>
</Method>

<Method name="Mount">
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String,readOnly:%Boolean=$$$NO</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$switchNSSys
    Set db = ##class(SYS.Database).%OpenId(Directory,,.sc)
    If $$$ISERR(sc) $$$ThrowStatus(sc)
    If db.Mounted && (db.ReadOnlyMounted'=readOnly) {
        $$$ThrowOnError(db.Dismount())
    }
    Quit db.Mount(+readOnly)
]]></Implementation>
</Method>

<Method name="GetMountState">
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    $$$switchNSSys
    Set db = ##class(SYS.Database).%OpenId(Directory,,.sc)
    If $$$ISERR(sc) {
        $$$ThrowStatus(sc)
    }

    #dim mountState As %Library.DynamicObject = {}
    Do mountState.%Set("Directory", db.Directory, "string")
    Do mountState.%Set("Mounted", db.Mounted, "boolean")
    Do mountState.%Set("ReadOnlyMounted", db.ReadOnlyMounted, "boolean")
    
    Quit mountState
]]></Implementation>
</Method>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.SYS.MirrorFailOver">
<Super>Api.Config.Services.Common.MethodsObjectGenerator</Super>
<TimeChanged>66011,29867.346998</TimeChanged>
<TimeCreated>66011,29867.346998</TimeCreated>

<Method name="JoinMirrorAsFailoverMember">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>config:%DynamicObject,localInfo:%DynamicObject,SSLConfig:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Do:$ISOBJECT($Get(localInfo)) ##class(Api.Config.Services.SYS.MirrorMaster).ToArray(localInfo, .pLocalInfo)
    Do:$ISOBJECT($Get(SSLConfig)) ##class(Api.Config.Services.SYS.MirrorMaster).ToArray(SSLConfig,.SSLInfo)
    
    $$$switchNSSys

    Set sc = ##class(SYS.Mirror).JoinMirrorAsFailoverMember(config.Name,config.SystemName,config.InstanceName,config.AgentAddress,config.AgentPort,.pLocalInfo, .SSLInfo)
    Return:$$$ISERR(sc) sc

    Do ##Class(Config.Mirrors).Get(config.Name,.Properties)
    $$$restoreNS

    If +Properties("UseSSL") {
        Do:$g(%zverbose,1) ##class(Api.Config.Services.Loader).log("   = This member must be approved on primary instance, check (while max 120 sec.)  ")
        Set end = $zh+120
        While $zh < end {
            Hang 2
            Set memberStatus = $SYSTEM.Mirror.GetStatus()
            Do:$g(%zverbose,1) ##class(Api.Config.Services.Loader).log("     - Current status "_memberStatus)
            Quit:"backupconnectedsynchronizing"[$$$LOWER(memberStatus)
        }
    }

    Return sc
]]></Implementation>
</Method>

<Method name="JoinMirrorAsAsyncMember">
<ClassMethod>1</ClassMethod>
<FormalSpec>config:%DynamicObject,localInfo:%DynamicObject,SSLConfig:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Do:$ISOBJECT($Get(localInfo)) ##class(Api.Config.Services.SYS.MirrorMaster).ToArray(localInfo, .pLocalInfo)
    Do:$ISOBJECT($Get(SSLConfig)) ##class(Api.Config.Services.SYS.MirrorMaster).ToArray(SSLConfig, .SSLInfo)
    Set type = $CASE($$$LOWER(config.AsyncMemberType),"disasterrecovery":0,"dr":0,"readonlyreporting":1,"roreporting":1,"ro":1,"readwritereporting":2,"rwreporting":2,"rw":2,:0)
    
    $$$switchNSSys
    
    Set sc =  ##class(SYS.Mirror).JoinMirrorAsAsyncMember(config.Name,config.SystemName,config.InstanceName,config.AgentAddress,config.AgentPort,type, .pLocalInfo, .SSLInfo)
    Return:$$$ISERR(sc) sc

    Do ##Class(Config.Mirrors).Get(config.Name,.Properties)
    $$$restoreNS

    If +Properties("UseSSL") {
        Do:$g(%zverbose,1) ##class(Api.Config.Services.Loader).log("   = This member must be approved on primary instance, check (while max 120 sec.)  ")
        Set end = $zh+120
        While $zh < end {
            Hang 2
            Set memberStatus = $SYSTEM.Mirror.GetStatus()
            Do:$g(%zverbose,1) ##class(Api.Config.Services.Loader).log("     - Current status "_memberStatus)
            Quit:"backupconnectedsynchronizing"[$$$LOWER(memberStatus)
        }
    }
    
    Return sc
]]></Implementation>
</Method>

<Method name="ActivateMirroredDBs">
<ClassMethod>1</ClassMethod>
<FormalSpec>DBList:%DynamicArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Set iter = DBList.%GetIterator()

    While iter.%GetNext(.key , .value ) {
        Hang 3
        $$$switchNSSys
        
        Set sc2 = ##class(SYS.Mirror).ActivateMirroredDatabase(value.Directory)
        Set:$$$ISERR(sc2) sc = $$$ADDSC(sc,sc2)
        $$$restoreNS
        Do:$g(%zverbose,1) ##class(Api.Config.Services.Loader).log($$$FormatText("   + Activate mirrored database %1 : %2",value.Directory, $SYSTEM.Status.GetOneErrorText(sc2)))
        
        Set sfn = +$zu(49, value.Directory)
        $$$switchNSSys
        set sc3 = ##class(SYS.Mirror).CatchupDB($lb(sfn))
        $$$restoreNS
        Do:$g(%zverbose,1) ##class(Api.Config.Services.Loader).log($$$FormatText("   + Catch up database %1 (sfn's %2) : %3",value.Directory, sfn, $SYSTEM.Status.GetOneErrorText(sc3)))
    
    }

    Return sc
]]></Implementation>
</Method>

<Method name="Create">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    If 'model.Config.AsyncMember {
        Set sc = ..JoinMirrorAsFailoverMember(model.Config, model.LocalInfo, model.SSLInfo)
    } Else {
        Set sc = ..JoinMirrorAsAsyncMember(model.Config, model.LocalInfo, model.SSLInfo)
    }
    Return:$$$ISERR(sc) sc
    Return ..ActivateMirroredDBs(model.Databases)
]]></Implementation>
</Method>

<Method name="Update">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Return $$$ERROR($$$NotImplemented)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[    Quit $$$NO
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.SYS.MirrorMaster">
<Description>
Description</Description>
<Super>Api.Config.Services.Common.MethodsObjectGenerator</Super>
<TimeChanged>66011,29867.346644</TimeChanged>
<TimeCreated>66011,29867.346644</TimeCreated>

<Method name="Update">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = ##class(Api.Config.Services.Mirrors).Update(model)
    Return:$$$ISERR(sc) sc

    Return ..AddDBToMirror(model.DataBases)
]]></Implementation>
</Method>

<Method name="CreateNewMirrorSet">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,SSLConfig:%Library.DynamicObject=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Hang 2 ; test waiting activation service mirror.
    Do ..ToArray(model,.properties)
    If $ISOBJECT($Get(SSLConfig)) {
        Do ..ToArray(SSLConfig,.SSLInfo)
    }
    $$$switchNSSys
    set sc = ##class(SYS.Mirror).CreateNewMirrorSet(model.Name, model.SystemName, .properties, .SSLInfo)
    
    Return:$$$ISERR(sc)

    $$$restoreNS

    Do:$g(%zverbose,1) ##class(Api.Config.Services.Loader).log("   = Wait became primary, checking while max 120 sec.  ")
    Set end = $zh+120
    While $zh < end {
        Hang 5
        Set memberStatus = $SYSTEM.Mirror.GetStatus()
        Do:$g(%zverbose,1) ##class(Api.Config.Services.Loader).log("     - Current status "_memberStatus)
        Quit:"primary"[$$$LOWER(memberStatus)
    }
    
    Do ##class(Api.Config.Services.Loader).log($$$FormatText("   + Create MirrorSet %1 : %2", model.Name, $SYSTEM.Status.GetOneErrorText(sc)))
    Return sc
]]></Implementation>
</Method>

<Method name="AddDBToMirror">
<ClassMethod>1</ClassMethod>
<FormalSpec>DBList:%DynamicArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Return:'$ISOBJECT(DBList) $$$OK
    Set sc = $$$OK
    Set iter = DBList.%GetIterator()
    
    While iter.%GetNext(.key , .value ) {
        Do ##class(Api.Config.Services.SYS.Databases).Mount(value.Directory)
        Hang 2
        $$$switchNSSys
        Set sc2 = ##class(SYS.Mirror).AddDatabase(value.Directory, value.MirrorDBName)
        Set:$$$ISERR(sc2) sc = $$$ADDSC(sc,sc2)
        Hang 2
        $$$restoreNS
        Do:$g(%zverbose,1) ##class(Api.Config.Services.Loader).log($$$FormatText("   + Add Database %1 to mirror with DB MirrorName %2 : %3",value.Directory, value.MirrorDBName, $SYSTEM.Status.GetOneErrorText(sc2)))    
    }

    Return sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = ..CreateNewMirrorSet(model.Config, model.SSLInfo)
    Return:$$$ISERR(sc) sc
    Return ..AddDBToMirror(model.Databases)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[    Quit ##class(Api.Config.Services.Mirrors).Exists(Name)
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
    Set iter = model.%GetIterator()

    While iter.%GetNext(.key , .value ) {
        Set properties(key) = value
    }

    Return
]]></Implementation>
</Method>

<Method name="AuthorizeNewMembers">
<ClassMethod>1</ClassMethod>
<FormalSpec>members:%String="backup,report",mirrorName:%String="DEMO",timeInSecond:%Integer=1800</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    ;Job ##class(Api.Config.Services.SYS.MirrorMaster).AuthorizeNewMembers()
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"

    Set sc = $$$OK, pProxy = { "Members":($zcvt(members,"u")),"MirrorName":($zcvt(mirrorName,"u"))}, end = $zh+timeInSecond
    While $zh < end {
        Do ##class(%CSP.UI.Portal.Mirror.EditFailover).AuthorizeNewMembers(pProxy)
        Hang 3
    }

    Return sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Security.Applications">
<Description>
Description</Description>
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.374386</TimeChanged>
<TimeCreated>66011,29867.374386</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Security.Applications</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.Security.GenericExport">
<Description>
Description</Description>
<TimeChanged>66011,29867.38457</TimeChanged>
<TimeCreated>66011,29867.38457</TimeCreated>

<Method name="ExportAll">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Directory:%String=..GetDefaultExportPath(),&Files:%Binary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Kill Files
    
    Set XData = ##class(%Dictionary.CompiledXData).%OpenId($CLASSNAME()_"||ExportAll")
    Set JsonList = {}.%FromJSON($REPLACE(XData.Data.Read(),"{ExportDir}",##class(%File).NormalizeDirectory(Directory)))

    Set iter = JsonList.%GetIterator()

    While iter.%GetNext(.key , .value ) {
        Set properties(key) = value
        Set sc = $CLASSMETHOD($CLASSNAME(),value.ClassMethod,value.Filename)
        Quit:$$$ISERR(sc)
        Set Files(value.ClassMethod) = value.Filename
    }

    Return sc
]]></Implementation>
</Method>

<Method name="Applications">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"ApplicationsExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.Applications).Export(Filename, , "*", 14)
]]></Implementation>
</Method>

<Method name="DocDBs">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"DocDBsExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.DocDBs).Export(Filename, , "*", "*")
]]></Implementation>
</Method>

<Method name="Users">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"UsersExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.Users).Export(Filename,,,,$$$YES)
]]></Implementation>
</Method>

<Method name="Roles">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"RolesExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.Roles).Export(Filename,,,,$$$YES)
]]></Implementation>
</Method>

<Method name="Resources">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"ResourcesExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.Resources).Export(Filename,,,,$$$YES)
]]></Implementation>
</Method>

<Method name="Services">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"ServicesExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.Services).Export(Filename,,"*")
]]></Implementation>
</Method>

<Method name="SSLConfigs">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"SSLConfigsExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.SSLConfigs).Export(Filename,,"*")
]]></Implementation>
</Method>

<Method name="X509Users">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"X509UsersExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.X509Users).Export(Filename)
]]></Implementation>
</Method>

<Method name="SQLPrivileges">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"SQLPrivilegesExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.SQLPrivileges).Export(Filename)
]]></Implementation>
</Method>

<Method name="SQLAdminPrivilegeSet">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"SQLAdminPrivilegesSetExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.SQLAdminPrivilegeSet).Export(Filename)
]]></Implementation>
</Method>

<Method name="SQLRoleGrantOption">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"SQLRoleGrantOptionExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.SQLRoleGrantOption).Export(Filename)
]]></Implementation>
</Method>

<Method name="System">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"SystemExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.System).Export(Filename)
]]></Implementation>
</Method>

<Method name="LDAPConfigs">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"LDAPConfigsExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.LDAPConfigs).Export(Filename)
]]></Implementation>
</Method>

<Method name="KMIPServer">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String=..GetDefaultExportPath()_"KMIPServerExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.KMIPServer).Export(Filename)
]]></Implementation>
</Method>

<Method name="DeleteExportDir">
<ClassMethod>1</ClassMethod>
<FormalSpec>exportDir:%String=..GetDefaultExportPath()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Do ##class(%File).RemoveDirectoryTree(exportDir)
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetDefaultExportPath">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    Set directory = ##class(%File).NormalizeDirectory($SYSTEM.Util.ManagerDirectory()_"tmp_export/")
    Do:'##class(%File).DirectoryExists(directory) ##class(%File).CreateDirectoryChain(directory)
    Return directory
]]></Implementation>
</Method>

<XData name="ExportAll">
<Description>
Description</Description>
<MimeType>application/json</MimeType>
<Data><![CDATA[
[
    {
        "ClassMethod" : "Roles",
        "Filename" : "{ExportDir}RolesExport.xml"
    },
    {
        "ClassMethod" : "Resources",
        "Filename" : "{ExportDir}ResourcesExport.xml"
    },
    {
        "ClassMethod" : "Users",
        "Filename" : "{ExportDir}UsersExport.xml"
    },
    {
        "ClassMethod" : "Applications",
        "Filename" : "{ExportDir}ApplicationsExport.xml"
    },
    {
        "ClassMethod" : "DocDBs",
        "Filename" : "{ExportDir}DocDBsExport.xml"
    },
    {
        "ClassMethod" : "Services",
        "Filename" : "{ExportDir}ServicesExport.xml"
    },
    {
        "ClassMethod" : "SSLConfigs",
        "Filename" : "{ExportDir}SSConfigsExport.xml"
    },
    {
        "ClassMethod" : "X509Users",
        "Filename" : "{ExportDir}X509UsersExport.xml"
    },
    {
        "ClassMethod" : "SQLPrivileges",
        "Filename" : "{ExportDir}SQLPrivilegesExport.xml"
    },
    {
        "ClassMethod" : "SQLAdminPrivilegeSet",
        "Filename" : "{ExportDir}SQLAdminPrivilegeSetExport.xml"
    },
    {
        "ClassMethod" : "SQLRoleGrantOption",
        "Filename" : "{ExportDir}SQLRoleGrantOptionExport.xml"
    },
    {
        "ClassMethod" : "System",
        "Filename" : "{ExportDir}SystemExport.xml"
    },
    {
        "ClassMethod" : "LDAPConfigs",
        "Filename" : "{ExportDir}LDAPConfigsExport.xml"
    },
    {
        "ClassMethod" : "KMIPServer",
        "Filename" : "{ExportDir}KMIPServerExport.xml"
    }
]
]]></Data>
</XData>
</Class>


<Class name="Api.Config.Services.Security.LDAPConfigs">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.392944</TimeChanged>
<TimeCreated>66011,29867.392944</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Security.LDAPConfigs</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.Security.Resources">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.379588</TimeChanged>
<TimeCreated>66011,29867.379588</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Security.Resources</Default>
</Parameter>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit $CLASSMETHOD(..#SYSCLASS, "Create",model.Name,model.Description, model.PublicPermission,model.Type)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Security.Roles">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.408323</TimeChanged>
<TimeCreated>66011,29867.408323</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Security.Roles</Default>
</Parameter>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit $CLASSMETHOD(..#SYSCLASS, "Create",model.Name,model.Description, model.Resources,model.GrantedRoles)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Security.SQLAdminPrivilegeSet">
<Description>
Description</Description>
<Super>Api.Config.Services.Common.MethodsObjectGenerator</Super>
<TimeChanged>66011,29867.413939</TimeChanged>
<TimeCreated>66011,29867.413939</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Security.SQLAdminPrivilegeSet</Default>
</Parameter>

<Parameter name="ISMAP">
<Default>1</Default>
</Parameter>

<Parameter name="PIDENTIFIER">
<Default>Namespace,Grantee</Default>
</Parameter>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Grantee:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Security.SQLAdminPrivilegeSet).IDKeyExists(Namespace, Grantee)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Grantee:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Namespace, Grantee) ""
	$$$switchNSSys
	Set obj = ##class(Security.SQLAdminPrivilegeSet).IDKeyOpen(Namespace, Grantee)
	Do ..ObjectToArray(.obj,.properties)
    Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..Update(model)
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	
    Set obj = ##class(Security.SQLAdminPrivilegeSet).IDKeyOpen(model.Namespace,model.Grantee)
    Set:'$ISOBJECT(obj) obj = ##class(Security.SQLAdminPrivilegeSet).%New()

    Set obj.Namespace = model.Namespace
    Set obj.Grantee = model.Grantee

    Set obj.AlterTable = model.AlterTable
	Set obj.AlterView = model.AlterView
	Set obj.CreateFunction = model.CreateFunction
	Set obj.CreateMethod = model.CreateMethod
	Set obj.CreateProcedure = model.CreateProcedure
	Set obj.CreateQuery = model.CreateQuery
	Set obj.CreateTable = model.CreateTable
	Set obj.CreateTrigger = model.CreateTrigger
	Set obj.CreateView = model.CreateView
	Set obj.DropFunction = model.DropFunction
	Set obj.DropMethod = model.DropMethod
	Set obj.DropProcedure = model.DropProcedure
	Set obj.DropQuery = model.DropQuery
	Set obj.DropTable = model.DropTable
	Set obj.DropTrigger = model.DropTrigger
	Set obj.DropView = model.DropView
	Set obj.NoCheck = model.NoCheck
	Set obj.NoIndex = model.NoIndex
	Set obj.NoLock = model.NoLock
	Set obj.NoTrigger = model.NoTrigger 
    Quit obj.%Save()
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Grantee:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Security.SQLAdminPrivilegeSet).IDKeyDelete(Namespace, Grantee)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String="*"</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	Set list = [], tmp=0
	Try{
		Do ..ExecQry(.tmp)
	}Catch(ex) {
		
		Throw ex
	}
	
	Set k = ""
	For  {
		Set k = $order(tmp(k),1,v)
		Quit:k=""
		
		If Namespace = "*" {
			Do list.%Push(..Get($lg(v,1),$lg(v,2)))
			
		} ElseIf Namespace = $lg(v,1) {
			Do list.%Push(..Get($lg(v,1),$lg(v,2)))
		}


	}
	Return list
]]></Implementation>
</Method>

<Method name="ExecQry">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&tmp]]></FormalSpec>
<Implementation><![CDATA[
	$$$switchNSSys
	Try{
		Set rs=##class(%Library.ResultSet).%New(..#SYSCLASS_":List")
		Do rs.Execute()
		While rs.Next() {
			Set tmp($i(tmp))=$lb(rs.Data("Namespace"),rs.Data("Grantee"))
		}
		Do rs.Close()
	}Catch(ex) {
		Throw ex
	}
	Kill rs
	Quit
]]></Implementation>
</Method>

<Method name="ListKey1">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Return ##class(Api.Config.Services.MapGlobals).ListKey1()
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/*ClassMethod ExecQry(ByRef tmp)
{
	$$$switchNSSys
	Try{
		Set tStatement = ##class(%SQL.Statement).%New()
		Set sc = tStatement.%PrepareClassQuery(..#SYSCLASS,"List")
		If $$$ISERR(sc) $$$ThrowStatus(sc)
		Set tResult = tStatement.%Execute()
		If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
		While tResult.%Next() {
			Set tmp($i(tmp))=$lb(tResult.%Get("Namespace"),tResult.%Get("Grantee"))
		}
		Kill tResult,tStatement
	} Catch(ex) {
		Throw ex
	}

	Quit
}*/
]]></Content>
</UDLText>
</Class>


<Class name="Api.Config.Services.Security.SQLPrivileges">
<Description>
Description</Description>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.42792</TimeChanged>
<TimeCreated>66011,29867.42792</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Security.SQLPrivileges</Default>
</Parameter>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace,SQLObject,Privilege,Grantee,Grantor</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    ;w ##class(Api.Config.Services.Security.SQLPrivileges).Exists("USER","1,Api_Config.TempStream","s","test1","_SYSTEM")
	$$$switchNSSys
	Quit ##class(Security.SQLPrivileges).IDKeyExists(Namespace, SQLObject, Privilege, Grantee, Grantor)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace,SQLObject,Privilege,Grantee,Grantor</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    ;zw ##class(Api.Config.Services.Security.SQLPrivileges).Get("USER","1,Api_Config.TempStream","s","test1","_SYSTEM")
    Quit:'..Exists(Namespace, SQLObject, Privilege, Grantee, Grantor) ""
    $$$switchNSSys
    Set obj = ##class(Security.SQLPrivileges).IDKeyOpen(Namespace, SQLObject, Privilege, Grantee, Grantor)
    Do ..ObjectToArray(.obj,.properties)
    Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set lst = [], sc = $$$OK, ns = $NAMESPACE
    Set:model.Grantor="" model.Grantor = "_SYSTEM"
    Set:model.Namespace="" model.Namespace = $NAMESPACE
    Set:model.Grantable="" model.Grantable = 0

    New $NAMESPACE
    If $EXTRACT(model.SQLObject , *)= "*" {
        Set arg = $EXTRACT(model.SQLObject, 3, *-1)
        Set sql = "SELECT SqlQualifiedNameQ from %Dictionary.CompiledClass WHERE SqlQualifiedNameQ %STARTSWITH(?) and ClassType = 'persistent'"
        Set tStatement = ##class(%SQL.Statement).%New()
        Set sc = tStatement.%Prepare(sql)
        If $$$ISERR(sc) $$$ThrowStatus(sc)
        Set tResult = tStatement.%Execute(arg)
        If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
        While tResult.%Next() {
            
            Set copyModel = {}.%FromJSON(model.%ToJSON())
            If model.%IsDefined("PrivList"), model.PrivList'="" {
                For i=1:1:$LENGTH(model.PrivList) {

                    CONTINUE:"adirsu"'[$$$LOWER($Extract(model.PrivList,i))

                    Set copyModel = {}.%FromJSON(model.%ToJSON())
                    Set copyModel.Privilege = $$$LOWER($Extract(model.PrivList,i))
                    Set copyModel.SQLObject = $e(model.SQLObject,1,2)_tResult.%Get("SqlQualifiedNameQ")
                    Do lst.%Push(copyModel)
                }
            } Else {
                Set copyModel = {}.%FromJSON(model.%ToJSON())
                Set copyModel.SQLObject = $e(model.SQLObject,1,2)_tResult.%Get("SqlQualifiedNameQ")
                Do lst.%Push(model)
            }
        }
    } ElseIf model.%IsDefined("PrivList") && (model.PrivList'="") {
        For i=1:1:$LENGTH(model.PrivList) {
            CONTINUE:"adirsu"'[$$$LOWER($Extract(model.PrivList,i))
            Set copyModel = {}.%FromJSON(model.%ToJSON())
            Set copyModel.Privilege = $$$LOWER($Extract(model.PrivList,i))
            Do lst.%Push(copyModel)
        }
    } Else {
        Do lst.%Push(model)
    }

    Set iter = lst.%GetIterator()
    Set $NAMESPACE="%SYS"
    While iter.%GetNext(.key,.value) {
        
        Set namespace = value.Namespace, sqlobject=value.SQLObject, privilege=value.Privilege, grantee = value.Grantee
        &SQL(DELETE Security.SQLPrivileges WHERE Namespace=:namespace AND SQLObject=:sqlobject AND Privilege=:privilege and Grantee=:grantee)
        If (SQLCODE'=0)&&(SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, SQLCODE)) 
        Set sp = ##class(Security.SQLPrivileges).%New()
        Set:value.%IsDefined("Grantable") sp.Grantable = value.Grantable
        Set sp.Grantee = value.Grantee
        Set sp.Grantor = value.Grantor
        Set sp.Namespace = value.Namespace
        Set sp.Privilege = value.Privilege
        Set sp.SQLObject = value.SQLObject
        Set sc2 = sp.%Save()
        Set:$$$ISERR(sc2) sc = $$$ADDSC(sc,sc2)
        
    }
    Set $NAMESPACE=ns

    Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit ..Update(model)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace,SQLObject,Privilege,Grantee,Grantor</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    ;zw ##class(Api.Config.Services.Security.SQLPrivileges).Get("USER","1,Api_Config.TempStream","s","test1","_SYSTEM")
    Quit:'..Exists(Namespace, SQLObject, Privilege, Grantee, Grantor) $$$OK
    $$$switchNSSys
    Set obj = ##class(Security.SQLPrivileges).IDKeyDelete(Namespace, SQLObject, Privilege, Grantee, Grantor)
    Do ..ObjectToArray(.obj,.properties)
    Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Grantee:%String</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	Set list = [], tmp=0
	Try{
		Do ..ExecQry($$$LOWER(Namespace),$$$LOWER(Grantee),.tmp)
	}Catch(ex) {
		
		Throw ex
	}
	
	Set k = ""
	For  {
		Set k = $order(tmp(k),1,v)
		Quit:k=""
		Do list.%Push(v)
	}
	Return list
]]></Implementation>
</Method>

<Method name="ExecQry">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Namespace,Grantee,&tmp]]></FormalSpec>
<Implementation><![CDATA[
    $$$switchNSSys
	Try{
		Set rs=##class(%Library.ResultSet).%New(..#SYSCLASS_":List")
		Do rs.Execute()
		While rs.Next() {
            Set tNS = $$$LOWER(rs.Data("Namespace")), tGrantee = $$$LOWER(rs.Data("Grantee"))
            
            If Namespace '= "*" && (tNS '= Namespace) {
                CONTINUE
            }
            If Grantee '= "*" && (tGrantee '= Grantee) {
                CONTINUE
            }
            
			Set tmp($i(tmp))= {
                "Grantable" : (rs.Data("Grantable")),
                "Grantee" : (rs.Data("Grantee")),
                "Grantor" : (rs.Data("Grantor")),
                "Namespace" : (rs.Data("Namespace")),
                "Privilege" : (rs.Data("Privilege")),
                "SQLObject" : (rs.Data("SQLObject"))
            }
		}
		Do rs.Close()

        /*Set tStatement = ##class(%SQL.Statement).%New()
        Set sc = tStatement.%PrepareClassQuery(..#SYSCLASS,"List")
        If $$$ISERR(sc) $$$ThrowStatus(sc)
        Set tResult = tStatement.%Execute()
        If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 

		While tResult.%Next() {
            Set tNS = $$$LOWER(tResult.%Get("Namespace")), tGrantee = $$$LOWER(tResult.%Get("Grantee"))
            
            If Namespace '= "*" && (tNS '= Namespace) {
                CONTINUE
            }
            If Grantee '= "*" && (tGrantee '= Grantee) {
                CONTINUE
            }
            
			Set tmp($i(tmp))= {
                "Grantable" : (tResult.%Get("Grantable")),
                "Grantee" : (tResult.%Get("Grantee")),
                "Grantor" : (tResult.%Get("Grantor")),
                "Namespace" : (tResult.%Get("Namespace")),
                "Privilege" : (tResult.%Get("Privilege")),
                "SQLObject" : (tResult.%Get("SQLObject"))
            }
		}
		Kill tResult,tStatement*/

	}Catch(ex) {
		Throw ex
	}
	Kill rs
	Quit
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Security.SSLConfigs">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.433817</TimeChanged>
<TimeCreated>66011,29867.433817</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Security.SSLConfigs</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.Security.Services">
<Description>
Description</Description>
<IncludeCode>Api.Config.inc</IncludeCode>
<TimeChanged>66011,29867.405028</TimeChanged>
<TimeCreated>66011,29867.405028</TimeCreated>

<Parameter name="UPDATEONLY">
<Default>1</Default>
</Parameter>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Security.Services).Exists(Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Security.Services).Get(Name,.properties))
	Set properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Security.Services).Modify(model.Name,.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Names:%String="*"</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set rs=##class(%Library.ResultSet).%New("Security.Services:List")
		Do rs.Execute(Names)
		While rs.Next() {
			Do list.%Push(..Get(rs.Data("Name")))
		}
		Do rs.Close()
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("AutheEnabled") = pObj.AutheEnabled
	Set properties("ClientSystems") = pObj.ClientSystems
	Set properties("Description") = pObj.Description
	Set properties("Enabled") = pObj.Enabled
	Set properties("Name") = pObj.Name
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"AutheEnabled") properties("AutheEnabled") = model.AutheEnabled
	Set:$$$CanSetProperty(model,"ClientSystems") properties("ClientSystems") = model.ClientSystems
	Set:$$$CanSetProperty(model,"Description") properties("Description") = model.Description
	Set:$$$CanSetProperty(model,"Enabled") properties("Enabled") = model.Enabled
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("AutheEnabled")) model.%Set("AutheEnabled", properties("AutheEnabled"), "string")
	Do:$Data(properties("ClientSystems")) model.%Set("ClientSystems", properties("ClientSystems"), "string")
	Do:$Data(properties("Description")) model.%Set("Description", properties("Description"), "string")
	Do:$Data(properties("Enabled")) model.%Set("Enabled", properties("Enabled"), "boolean")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Quit model
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Security.Users">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.438696</TimeChanged>
<TimeCreated>66011,29867.438696</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Security.Users</Default>
</Parameter>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
    kill properties("Name")
	Quit $CLASSMETHOD(..#SYSCLASS, "Create",model.Name,.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Shadows">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.246379</TimeChanged>
<TimeCreated>66011,29867.246379</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.Shadows</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Address="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Address property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.SqlSysDatatypes">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.253533</TimeChanged>
<TimeCreated>66011,29867.253533</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.SqlSysDatatypes</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Datatype="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Datatype property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.SqlUserDatatypes">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Methods</Super>
<TimeChanged>66011,29867.250029</TimeChanged>
<TimeCreated>66011,29867.250029</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.SqlUserDatatypes</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Datatype="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Datatype property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Startup">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29867.287601</TimeChanged>
<TimeCreated>66011,29867.287601</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.Startup</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.Telnet">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29867.287464</TimeChanged>
<TimeCreated>66011,29867.287464</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.Telnet</Default>
</Parameter>
</Class>


<Class name="Api.Config.Services.ZPM">
<Description>
Description</Description>
<TimeChanged>66011,29867.272407</TimeChanged>
<TimeCreated>66011,29867.272407</TimeCreated>

<Method name="Execute">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,command:%String,args:%String="",pTerminateOnError:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = namespace
    Quit ##class(%ZPM.PackageManager).Shell(command _ " " _ args, pTerminateOnError)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.config">
<IncludeCode>Api.Config.inc</IncludeCode>
<Super>Api.Config.Services.Common.Single</Super>
<TimeChanged>66011,29867.012507</TimeChanged>
<TimeCreated>66011,29867.012507</TimeCreated>

<Parameter name="SYSCLASS">
<Default>Config.config</Default>
</Parameter>
</Class>


<Class name="Api.Config.TempStream">
<Description>
Description</Description>
<Super>%Persistent</Super>
<TimeChanged>66011,29866.864473</TimeChanged>
<TimeCreated>66011,29866.864473</TimeCreated>

<Property name="created">
<Type>%TimeStamp</Type>
<InitialExpression>$zdatetime($HOROLOG,3,1)</InitialExpression>
</Property>

<Property name="name">
<Type>%String</Type>
</Property>

<Property name="charStream">
<Type>%Stream.GlobalCharacter</Type>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Api.Config.TempStreamD</DataLocation>
<DefaultData>TempStreamDefaultData</DefaultData>
<IdLocation>^Api.Config.TempStreamD</IdLocation>
<IndexLocation>^Api.Config.TempStreamI</IndexLocation>
<StreamLocation>^Api.Config.TempStreamS</StreamLocation>
<Data name="TempStreamDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>created</Value>
</Value>
<Value name="3">
<Value>name</Value>
</Value>
<Value name="4">
<Value>charStream</Value>
</Value>
</Data>
</Storage>
</Class>


<Routine name="Api.Config.inc" type="INC" timestamp="66011,29866.82753"><![CDATA[

#Define SRVPKG              Api.Config.Services
/// HTTP Status Code

#Define HTTP200                     ##class(%CSP.REST).%GetParameter("HTTP200OK")
#Define HTTP201                     ##class(%CSP.REST).%GetParameter("HTTP201CREATED")
#Define HTTP204                     ##class(%CSP.REST).%GetParameter("HTTP204NOCONTENT")
#Define HTTP400                     ##class(%CSP.REST).%GetParameter("HTTP400BADREQUEST")
#Define HTTP404                     ##class(%CSP.REST).%GetParameter("HTTP404NOTFOUND")
#Define HTTP409                     ##class(%CSP.REST).%GetParameter("HTTP409CONFLICT")


/// OTHERS

#Define switchNSSys                             New $NAMESPACE  Set ns = $NAMESPACE, $NAMESPACE = "%SYS"
#Define restoreNS                               Set $NAMESPACE = ns
#Define CanSetProperty(%json,%property)         (%json.%IsDefined(%property)&&($Ascii(%json.%Get(%property))'=0))
#Define fillJSONFromArray(%array,%json)         Do ##class(dc.deploy.Utils).fillJSONFromArray(.%array,.%json)
#Define fillArrayFromJSON(%json,%array)         Do ##class(dc.deploy.Utils).fillArrayFromJSON(.%json,.%array)

#Define DBSysUpdateProperties       $LISTBUILD("ReadOnly","Size","ExpansionSize","MaxSize","GlobalJournalState","NewGlobalCollation","NewGlobalIsKeep","NewGlobalGrowthBlock","NewGlobalPointerBlock","ClusterMountMode","ResourceName","CompressionEngine")
#Define DBSysCreateProperties       $LISTBUILD("Directory","BlockSize","EncryptedDB","EncryptionKeyID","Size","ExpansionSize","MaxSize","MirrorDBName","MirrorSetName","GlobalJournalState","NewGlobalCollation","NewGlobalIsKeep","NewGlobalGrowthBlock","NewGlobalPointerBlock","ClusterMountMode","ResourceName","CompressionEngine")
]]></Routine>


<Routine name="IORedirect" type="INC" timestamp="66011,29866.136284"><![CDATA[

#Define OldIO                   %zIORedirect("OldIO")
#Define OldMnemonic             %zIORedirect("OldMnemonic")
#Define OldState                %zIORedirect("OldState")
#Define KillOldStateData        Kill $$$OldState, $$$OldMnemonic, $$$OldIO

#Define RedirectOutputHandler   %zIORedirect("OutputHandler")
#Define LastOutputHandler       %zIORedirect("LastOutputHandler")
#Define RedirectInputHandler    %zIORedirect("InputHandler")

#Define RedirectGbl             %zIORedirect("OutputGlobalName")
#Define RedirectGblName         $Get($$$RedirectGbl, $Name(^||IORedirect))

#Define RedirectStream          %zIORedirect("OutStream")
#Define RedirectInputStream     %zIORedirect("InputStream")

#Define RedirectString          %zIORedirect("OutString")
#Define RedirectInputString     %zIORedirect("InputString")

#Define ClearConfig             Kill %zIORedirect

#Define InputHandlerUTimeout    ($CLASSMETHOD($$$RedirectInputHandler,"%GetParameter","USETIMETOUT")=1)

#Define CallReadChar(%timeout)          $SELECT($$$InputHandlerUTimeout:$CLASSMETHOD($$$RedirectInputHandler,"InChar", %timeout),1:$CLASSMETHOD($$$RedirectInputHandler,"InChar"))
#Define CallReadString(%size,%timeout)  $SELECT($$$InputHandlerUTimeout:$CLASSMETHOD($$$RedirectInputHandler,"InString",%size,%timeout),1:$CLASSMETHOD($$$RedirectInputHandler,"InString",%size))
]]></Routine>


<Class name="IORedirect.InputHandler">
<Abstract>1</Abstract>
<IncludeCode>IORedirect</IncludeCode>
<TimeChanged>66011,29866.090343</TimeChanged>
<TimeCreated>66011,29866.090343</TimeCreated>

<Parameter name="USETIMEOUT">
<Default>0</Default>
</Parameter>

<Method name="InChar">
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[    $$$ThrowStatus($$$ERROR($$$NotImplemented))
]]></Implementation>
</Method>

<Method name="InString">
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>size:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[    $$$ThrowStatus($$$ERROR($$$NotImplemented))
]]></Implementation>
</Method>
</Class>


<Class name="IORedirect.InputStream">
<IncludeCode>IORedirect</IncludeCode>
<Super>InputHandler</Super>
<TimeChanged>66011,29866.08774</TimeChanged>
<TimeCreated>66011,29866.08774</TimeCreated>

<Method name="InChar">
<Description>
Timeout parameter won't used in this subclass.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
    Quit:'$ISOBJECT($Get($$$RedirectInputStream)) -1
    Quit $ASCII($$$RedirectInputStream.Read(1))
]]></Implementation>
</Method>

<Method name="InString">
<Description>
Timeout parameter won't used in this subclass.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>size:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    Quit:'$ISOBJECT($Get($$$RedirectInputStream)) ""
    Quit:size="" $$$RedirectInputStream.ReadLine()
    Quit $$$RedirectInputStream.Read(size)
]]></Implementation>
</Method>

<Method name="SetStream">
<Deprecated>1</Deprecated>
<ClassMethod>1</ClassMethod>
<FormalSpec>stream:%Stream.Object=##class(%Stream.GlobalCharacter).%New()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit ..Set(stream)
]]></Implementation>
</Method>

<Method name="Set">
<ClassMethod>1</ClassMethod>
<FormalSpec>stream:%Stream.Object=##class(%Stream.GlobalCharacter).%New()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set $$$RedirectInputStream = stream
    Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="IORedirect.InputString">
<IncludeCode>IORedirect</IncludeCode>
<Super>InputHandler</Super>
<TimeChanged>66011,29866.085193</TimeChanged>
<TimeCreated>66011,29866.085193</TimeCreated>

<Method name="InChar">
<Description>
Timeout parameter won't used in this subclass.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
    Set char = $ASCII($Extract(..Get()))
    Do ..Set($Extract(..Get(), 2, *))
    Quit char
]]></Implementation>
</Method>

<Method name="InString">
<Description>
Timeout parameter won't used in this subclass.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>size:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    If size '= "" {
        Set buffer = $Extract(..Get(), 1, size)
        Do ..Set($Extract(..Get(), size+1, *))
        Quit buffer
    }

    Set buffer = $Piece(..Get(), $$$NL, 1)
    Do ..Set($Piece(..Get(), $$$NL, 2, *))
    Quit buffer
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$Get($$$RedirectInputString)
]]></Implementation>
</Method>

<Method name="Set">
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set $$$RedirectInputString = string
    Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="IORedirect.OutputGlobal">
<IncludeCode>IORedirect</IncludeCode>
<Super>IORedirect.OutputHandler</Super>
<TimeChanged>66011,29866.117895</TimeChanged>
<TimeCreated>66011,29866.117895</TimeCreated>

<Method name="Clear">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Kill @$$$RedirectGblName
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="SetRedirectLocation">
<Deprecated>1</Deprecated>
<ClassMethod>1</ClassMethod>
<FormalSpec>globalName:%String=$Name(^||IORedirect)</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit ..Set(globalName)
]]></Implementation>
</Method>

<Method name="Set">
<ClassMethod>1</ClassMethod>
<FormalSpec>globalName:%String=$Name(^||IORedirect)</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set $$$RedirectGbl = globalName
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$RedirectGblName
]]></Implementation>
</Method>

<Method name="OutChar">
<ClassMethod>1</ClassMethod>
<FormalSpec>char:%Integer</FormalSpec>
<Implementation><![CDATA[    Do ..OutString($Char(char))
]]></Implementation>
</Method>

<Method name="OutString">
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String</FormalSpec>
<Implementation><![CDATA[
    Set gbl = $$$RedirectGblName
    Set:'$Data(@gbl) @gbl = 1
    Set @gbl@(@gbl) =  $Get(@gbl@(@gbl)) _ string
    Quit
]]></Implementation>
</Method>

<Method name="OutFormFeed">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString($Char(12))
    Quit
]]></Implementation>
</Method>

<Method name="OutNewLine">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<Implementation><![CDATA[$Increment(@$$$RedirectGblName)
]]></Implementation>
</Method>

<Method name="OutTab">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString($Char(9))
    Quit
]]></Implementation>
</Method>
</Class>


<Class name="IORedirect.OutputHandler">
<Description>
Description</Description>
<Abstract>1</Abstract>
<TimeChanged>66011,29866.119919</TimeChanged>
<TimeCreated>66011,29866.119919</TimeCreated>

<Method name="OutChar">
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>char:%Integer</FormalSpec>
<Implementation><![CDATA[    $$$ThrowStatus($$$ERROR($$$NotImplemented))
]]></Implementation>
</Method>

<Method name="OutString">
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String</FormalSpec>
<Implementation><![CDATA[    $$$ThrowStatus($$$ERROR($$$NotImplemented))
]]></Implementation>
</Method>

<Method name="OutFormFeed">
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[    $$$ThrowStatus($$$ERROR($$$NotImplemented))
]]></Implementation>
</Method>

<Method name="OutNewLine">
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[    $$$ThrowStatus($$$ERROR($$$NotImplemented))
]]></Implementation>
</Method>

<Method name="OutTab">
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[    $$$ThrowStatus($$$ERROR($$$NotImplemented))
]]></Implementation>
</Method>

<Method name="OnStopRedirect">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="IORedirect.OutputStream">
<IncludeCode>IORedirect</IncludeCode>
<Super>IORedirect.OutputHandler</Super>
<TimeChanged>66011,29866.109597</TimeChanged>
<TimeCreated>66011,29866.109597</TimeCreated>

<Method name="Clear">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set stream = $$$RedirectStream
    Do:$Isobject(stream) stream.Clear()
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="SetStream">
<Description>
Description</Description>
<Deprecated>1</Deprecated>
<ClassMethod>1</ClassMethod>
<FormalSpec>stream:%Stream.Object=##class(%Stream.GlobalCharacter).%New()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit ..Set(stream)
]]></Implementation>
</Method>

<Method name="Set">
<ClassMethod>1</ClassMethod>
<FormalSpec>stream:%Stream.Object=##class(%Stream.GlobalCharacter).%New()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set $$$RedirectStream = stream
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
    Quit:$ISOBJECT($Get($$$RedirectStream)) $$$RedirectStream
    Do ..SetStream()
    Quit $$$RedirectStream
]]></Implementation>
</Method>

<Method name="OutChar">
<ClassMethod>1</ClassMethod>
<FormalSpec>char:%Integer</FormalSpec>
<Implementation><![CDATA[
    Do ..OutString($Char(char))
    Quit
]]></Implementation>
</Method>

<Method name="OutString">
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String</FormalSpec>
<Implementation><![CDATA[
    Do ..Get().Write(string)
    Quit
]]></Implementation>
</Method>

<Method name="OutFormFeed">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString($Char(12))
    Quit
]]></Implementation>
</Method>

<Method name="OutNewLine">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString(..Get().LineTerminator)
    Quit
]]></Implementation>
</Method>

<Method name="OutTab">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString($Char(9))
    Quit
]]></Implementation>
</Method>

<Method name="OnStopRedirect">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim sc As %Status = $$$OK
    #dim stream As %Stream.Object = ..Get()
    If stream.%IsA("%Stream.FileBinary") { 
        Set sc = stream.%Save()
    }
    Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="IORedirect.OutputString">
<IncludeCode>IORedirect</IncludeCode>
<Super>IORedirect.OutputHandler</Super>
<TimeChanged>66011,29866.125237</TimeChanged>
<TimeCreated>66011,29866.125237</TimeCreated>

<Method name="Clear">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit ..Set("")
]]></Implementation>
</Method>

<Method name="Set">
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set $$$RedirectString = string
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[    Quit $Get($$$RedirectString)
]]></Implementation>
</Method>

<Method name="OutChar">
<ClassMethod>1</ClassMethod>
<FormalSpec>char:%Integer</FormalSpec>
<Implementation><![CDATA[
    Do ..OutString($Char(char))
    Quit
]]></Implementation>
</Method>

<Method name="OutString">
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String</FormalSpec>
<Implementation><![CDATA[
    Set $$$RedirectString = $$$RedirectString _ string
    Quit
]]></Implementation>
</Method>

<Method name="OutFormFeed">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString($Char(12))
    Quit
]]></Implementation>
</Method>

<Method name="OutNewLine">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString($$$NL)
    Quit
]]></Implementation>
</Method>

<Method name="OutTab">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString($Char(9))
    Quit
]]></Implementation>
</Method>

<Method name="OnStopRedirect">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="IORedirect.Redirect">
<IncludeCode>IORedirect</IncludeCode>
<TimeChanged>66011,29866.133223</TimeChanged>
<TimeCreated>66011,29866.133223</TimeCreated>

<Parameter name="OUTPUTSTREAM">
<Default>IORedirect.OutputStream</Default>
</Parameter>

<Parameter name="OUTPUTGLOBAL">
<Default>IORedirect.OutputGlobal</Default>
</Parameter>

<Parameter name="OUTPUTSTRING">
<Default>IORedirect.OutputString</Default>
</Parameter>

<Parameter name="INPUTSTREAM">
<Default>IORedirect.InputStream</Default>
</Parameter>

<Parameter name="INPUTSTRING">
<Default>IORedirect.InputString</Default>
</Parameter>

<Method name="RedirectIO">
<Description><![CDATA[
Class this method to Enable the redirect<br/>
OutputHandler must be a subclass name of IORedirect.OutputHandler<br/>
If you want to handle Input, you can fill InputHandler with a subclass name of IORedirect.InputHandler<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>OutputHandler:%String,InputHandler:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set $$$OldIO = $IO
    Set $$$OldMnemonic = ##class(%Library.Device).GetMnemonicRoutine()
    Set $$$OldState = ##class(%Library.Device).ReDirectIO()

    Do ..SetInputHandler(InputHandler), ..SetOuputHandler(OutputHandler)

    Use $IO::("^"_$ZNAME)

    Do ##class(%Library.Device).ReDirectIO(1)

    Quit $$$OK
]]></Implementation>
</Method>

<Method name="RestoreIO">
<Description><![CDATA[
Stop the redirect and restore original IO Setting.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Quit:'$Data($$$OldState) $$$OK
    
    If $Get($$$OldMnemonic) '= "" {
        Use $$$OldIO::("^"_$$$OldMnemonic)
    } Else {
        Use $$$OldIO
    }

    Do ##class(%Library.Device).ReDirectIO($$$OldState)
    $$$KillOldStateData

    Do $CLASSMETHOD($$$RedirectOutputHandler, "OnStopRedirect")
    
    Do ..SetInputHandler(""), ..SetOuputHandler("")
    
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<Description>
Return the output value depending the last used output hander:
OutputGlobal : String with the global name.
OutputString : String with the output value.
OutputStream : Stream with the output value.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[    Quit $CLASSMETHOD($$$LastOutputHandler, "Get")
]]></Implementation>
</Method>

<Method name="ToStream">
<Description>
Enable Output Redirection to a Stream object.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>stream:%Stream.Object=##class(%Stream.GlobalCharacter).%New()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$QuitOnError(..RedirectIO(..#OUTPUTSTREAM))
    $$$QuitOnError($CLASSMETHOD(..#OUTPUTSTREAM, "Set", stream))
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="ToString">
<Description>
Enable output redirect to a string.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$QuitOnError(..RedirectIO(..#OUTPUTSTRING))
    $$$QuitOnError($CLASSMETHOD(..#OUTPUTSTRING, "Set", ""))
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="ToFileCharacter">
<Description>
Enable output redirect to a file.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>fileName:%String</FormalSpec>
<Implementation><![CDATA[
    #dim fcs As %Stream.FileCharacter = ##class(%Stream.FileCharacter).%New()
    Set dir = ##class(%File).GetDirectory(fileName)
    Do:'##class(%File).DirectoryExists(dir) ##class(%File).CreateDirectoryChain(dir)
    Do fcs.LinkToFile(fileName)
    $$$QuitOnError(..RedirectIO(..#OUTPUTSTREAM))

    Quit $CLASSMETHOD(..#OUTPUTSTREAM, "SetStream", fcs)
]]></Implementation>
</Method>

<Method name="ToGlobal">
<Description>
Enable Output redirection to a global.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>global:%String=$Name(^||IORedirect)</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$QuitOnError(..RedirectIO(..#OUTPUTGLOBAL))
    $$$QuitOnError($CLASSMETHOD(..#OUTPUTGLOBAL, "Set", global))
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="InputStream">
<Description>
Enable Read from a stream.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>stream:%Stream.Object=##class(%Stream.GlobalCharacter).%New()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Do ..SetInputHandler(..#INPUTSTREAM), $CLASSMETHOD(..#INPUTSTREAM, "Set", stream)
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="InputString">
<Description>
Enable Read from a string.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>inputString:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Do ..SetInputHandler(..#INPUTSTRING), $CLASSMETHOD(..#INPUTSTRING, "Set", inputString)
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="SetOuputHandler">
<ClassMethod>1</ClassMethod>
<FormalSpec>OutputHandler:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set:OutputHandler'="" $$$LastOutputHandler = OutputHandler
    Set $$$RedirectOutputHandler = OutputHandler
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetOuputHandler">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$RedirectOutputHandler
]]></Implementation>
</Method>

<Method name="SetInputHandler">
<ClassMethod>1</ClassMethod>
<FormalSpec>OutputHandler:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set $$$RedirectInputHandler = OutputHandler
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetInputHandler">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$RedirectInputHandler
]]></Implementation>
</Method>

<Method name="ClearConfig">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$ClearConfig
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="labels">
<ClassMethod>1</ClassMethod>
<ProcedureBlock>0</ProcedureBlock>
<Implementation><![CDATA[
    Quit
rchr(c)      Quit:$Get($$$RedirectInputHandler)=""  Quit $$$CallReadChar($Get(c))
rstr(sz,to)  Quit:$Get($$$RedirectInputHandler)=""  Quit $$$CallReadString($g(sz),$g(to))
wchr(s)      Do $CLASSMETHOD($$$RedirectOutputHandler,"OutChar",s)  Quit
wstr(s)      Do $CLASSMETHOD($$$RedirectOutputHandler,"OutString",s)  Quit
wff()        Do $CLASSMETHOD($$$RedirectOutputHandler,"OutFormFeed")  Quit
wnl()        Do $CLASSMETHOD($$$RedirectOutputHandler,"OutNewLine")  Quit
wtab(s)      Do $CLASSMETHOD($$$RedirectOutputHandler,"OutTab")  Quit
]]></Implementation>
</Method>
</Class>


<Class name="lscalese.configcopy.ExportFilterTemplate">
<Description>
Description</Description>
<TimeChanged>66011,29869.133511</TimeChanged>
<TimeCreated>66011,29869.133511</TimeCreated>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String="Default"</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set XData = ##class(%Dictionary.CompiledXData).%OpenId($CLASSNAME()_"||"_Name)
    Return {}.%FromJSON(XData.Data)
]]></Implementation>
</Method>

<XData name="Default">
<MimeType>application/json</MimeType>
<Data><![CDATA[
{
    "Databases": "",
    "Namespaces":"",
    "MapGlobals":"",
    "MapPackages": "",
    "MapRoutines":"",
    "Journal":"",
    "Startup":"",
    "config":"",
    "Miscellaneous":"",
    "LicenseServers":"",
    "Monitor":"",
    "IO":"",
    "SQL":"",
    "SQLSysDatatypes":"",
    "SQLUserDatatypes":"",
    "Telnet":""
}
]]></Data>
</XData>
</Class>


<Class name="lscalese.configcopy.ImportFromRemote">
<Description>
Export configuration from the remote instance and import this instance.</Description>
<TimeChanged>66011,50198.416874</TimeChanged>
<TimeCreated>66011,44578.305571</TimeCreated>

<Method name="All">
<Description>
Set sc = ##class(lscalese.configcopy.ImportFromRemote).All()</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK

    Set scO = ..Security()
    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)
    
    Set scO = ..Globals()
    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)

    Set scO = ..CPFData()
    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)

    Return sc
]]></Implementation>
</Method>

<Method name="Security">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, Filename = ##class(%File).TempFilename()

    Try {
        $$$TOE(sc,##class(lscalese.configcopy.RemoteExport).Security(Filename))
        $$$TOE(sc,##class(lscalese.configcopy.LocalImport).Security(Filename))
    } Catch (ex) {
        Set sc = ex.AsStatus()
    }
    
    Do ##class(%File).Delete(Filename)

    Return sc
]]></Implementation>
</Method>

<Method name="Globals">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, Filename = ##class(%File).TempFilename()

    Try {
        $$$TOE(sc,##class(lscalese.configcopy.RemoteExport).Globals(Filename))
        $$$TOE(sc,##class(lscalese.configcopy.LocalImport).Globals(Filename))
    } Catch (ex) {
        Set sc = ex.AsStatus()
    }
    
    Do ##class(%File).Delete(Filename)

    Return sc
]]></Implementation>
</Method>

<Method name="CPFData">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, Filename = ##class(%File).TempFilename()

    Try {
        $$$TOE(sc,##class(lscalese.configcopy.RemoteExport).CPFData(Filename))
        $$$TOE(sc,##class(lscalese.configcopy.LocalImport).CPFData(Filename))
    } Catch (ex) {
        Set sc = ex.AsStatus()
    }
    
    Do ##class(%File).Delete(Filename)

    Return sc
]]></Implementation>
</Method>
</Class>


<Class name="lscalese.configcopy.LocalExport">
<Description>
Export configuration of this instance</Description>
<TimeChanged>66012,26469.81149</TimeChanged>
<TimeCreated>66011,29869.102331</TimeCreated>

<Method name="All">
<Description>
d ##class(lscalese.configcopy.LocalExport).All()</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String={ $zu(12,"config-copy-local/")}</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Set Directory = ##class(%File).NormalizeDirectory(Directory)

    Do:'##class(%File).DirectoryExists(Directory) ##class(%File).CreateDirectoryChain(Directory)

    
    Set scO = ..Security(Directory_"SecurityExport.xml")
    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)

    Set scO = ..Tasks(Directory_"TasksExport.xml")
    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)

    Set scO = ..Globals(Directory_"GlobalsExport.xml")
    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)

    Set scO = $$$OK
    Set config =  ..CPFDataTemplate(.scO, "Default")

    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)

    Return:$$$ISERR(scO) sc
    
    Set scO = ##class(Api.Config.Services.Loader).toFile(config, Directory_"config-api.json")
    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)

    Return sc
]]></Implementation>
</Method>

<Method name="Security">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String="SecurityExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.System).ExportAll(Filename)
]]></Implementation>
</Method>

<Method name="Tasks">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String="TasksExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set TaskListId="", id=999 

    For  { 
        Set id = $Order(^["%SYS"]SYS("Task","TaskD",id)) 
        Quit:id=""  
        Set $List(TaskListId,*+1)=id 
    }

    If $LISTLENGTH(TaskListId) = 0 {
        Return $$$OK  ; Nothing to export
    }

    Return ##class(%SYS.TaskSuper).ExportTasks(TaskListId)
]]></Implementation>
</Method>

<Method name="Globals">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String="GlobalsExport.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    ; zw ##class(lscalese.configcopy.Export).ExportGlobals()
    $$$QuitOnError(..GlobalsToStream(.stream))
    
    Do:##class(%File).Exists(Filename) ##class(%File).Delete(Filename)
    Set file = ##class(%Stream.FileBinary).%New()
    $$$QuitOnError(file.LinkToFile(Filename))
    
    Do file.CopyFrom(.stream)
    Quit file.%Save()
]]></Implementation>
</Method>

<Method name="GlobalsToStream">
<ClassMethod>1</ClassMethod>
<FormalSpec>GblStream:%Stream.GlobalBinary=##class(%Stream.GlobalBinary).%New()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Lock +^ExportTmp
    Kill ^ExportTmp
    Try {
        Merge ^ExportTmp($Name(^%SYS("sql","ODBCCONNECTION"))) = ^%SYS("sql","ODBCCONNECTION")
        Set sc = $SYSTEM.OBJ.ExportToStream("ExportTmp.GBL", .GblStream, "-d")
    } Catch(ex) {
        Set sc = ex.AsStatus()
    }
    Lock -^ExportTmp
    Return sc
]]></Implementation>
</Method>

<Method name="CPFDataTemplate">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&sc:%Status,TemplateName:%String,ToFile:%String="",IncludeSystem:%Boolean=$$$NO]]></FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set Filter = ##class(lscalese.configcopy.ExportFilterTemplate).Get(TemplateName)
    Return ..CPFData(.sc, Filter, ToFile, IncludeSystem)
]]></Implementation>
</Method>

<Method name="CPFData">
<Description>
Export CPF Section using config-api tools.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&sc:%Status=$$$OK,Filter:%DynamicObject,ToFile:%String="",IncludeSystem:%Boolean=$$$NO]]></FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    #dim config As %DynamicObject = {}
    
    Try {
        Set config = ##class(Api.Config.Services.Loader).export(Filter, $$$YES, ToFile)
    } Catch (ex) {
        Set sc = ex.AsStatus()
    }

    Return:$$$ISERR(sc) ""

    Return:IncludeSystem config

    If $Isobject(config.Namespaces) {

        Set excludeNS("%SYS")=""
        Set excludeNS("HSLIB")=""
        Set excludeNS("HSSYS")=""
        Set excludeNS("DOCBOOK")=""
        Set excludeNS("ENSEMBLE")=""
        Set excludeNS("ENSDEMO")=""
        Set excludeNS("HSCUSTOM")=""
        
        Set ns = ""
        For  {
            
            Set ns = $Order(excludeNS(ns))
            Quit:ns=""

            Do config.Namespaces.%Remove(ns)
        }

    }

    Return:'$Isobject(config.Databases) config

    Set excludeDB("IRISSYS")=""
    Set excludeDB("IRISLIB")=""
    Set excludeDB("IRISTEMP")=""
    Set excludeDB("IRISLOCALDATA")=""
    Set excludeDB("IRISAUDIT")=""
    Set excludeDB("ENSLIB")=""
    Set excludeDB("ENSDEMO")=""
    Set excludeDB("ENSEMBLE")=""
    Set excludeDB("HSCUSTOM")=""
    Set excludeDB("HSSYS")=""
    Set excludeDB("HSLIB")=""
    Set excludeDB("USER")=""
    Set excludeDB("CACHESYS")=""
    Set excludeDB("CACHELIB")=""
    Set excludeDB("CACHETEMP")=""
    Set excludeDB("CACHEAUDIT")=""
    Set excludeDB("CACHE")=""
    Set excludeDB("USER")=""
    
    Set db = ""

    For  {
        Set db = $Order(excludeDB(db))
        Quit:db=""
        
        Set dbObj = config.Databases.%Get(db)
        
        Continue:'$Isobject(dbObj)
        
        If $Isobject(config."SYS.Databases"), dbObj.Directory'="" {
            Do config."SYS.Databases".%Remove(dbObj.Directory)
        }
        
        Do config.Databases.%Remove(db)
    }

    Return config
]]></Implementation>
</Method>
</Class>


<Class name="lscalese.configcopy.LocalImport">
<Description>
Description</Description>
<TimeChanged>66012,26372.407129</TimeChanged>
<TimeCreated>66011,29869.123266</TimeCreated>

<Method name="CPFData">
<Description>
Load CPF configuration data from a json format config-api</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>CPFConfig:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Return ##class(Api.Config.Services.Loader).Load(CPFConfig)
]]></Implementation>
</Method>

<Method name="Security">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Return ##class(Security.System).ImportAll(Filename)
]]></Implementation>
</Method>

<Method name="Tasks">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Return ##class(%SYS.Task).ImportTasks(Filename)
]]></Implementation>
</Method>

<Method name="Globals">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim FileBinary As %Stream.FileBinary = ##class(%Stream.FileBinary).%New()
    Do FileBinary.LinkToFile(Filename)
    Return ..GlobalsStream(.FileBinary)
]]></Implementation>
</Method>

<Method name="GlobalsStream">
<ClassMethod>1</ClassMethod>
<FormalSpec>GblStream:%Stream.GlobalBinary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Lock +^ExportTmp
    
    Kill:$Data(^ExportTmp) ^ExportTmp

    Try{
        $$$TOE(sc,$SYSTEM.OBJ.LoadStream(GblStream))
        
        Set dt = $zdt($h,3,1)

        If $Data(^ExportTmp($Name(^%SYS("sql","ODBCCONNECTION")))) {
            Merge ^configcopy.backup(dt, $Name(^%SYS("sql","ODBCCONNECTION"))) = ^%SYS("sql","ODBCCONNECTION")
            Kill ^%SYS("sql","ODBCCONNECTION")
            Merge ^%SYS("sql","ODBCCONNECTION") = ^ExportTmp($Name(^%SYS("sql","ODBCCONNECTION")))
        }

    } Catch(ex) {

        Set sc = ex.AsStatus()
            
    }
    
    Kill ^ExportTmp

    Lock -^ExportTmp
    
    Return sc
]]></Implementation>
</Method>
</Class>


<Class name="lscalese.configcopy.RemoteExport">
<Description>
Export configuration from a remote instance using a REST api.
config-copy tools must be also installed on the remote instance.</Description>
<TimeChanged>66012,24493.089908</TimeChanged>
<TimeCreated>66011,29869.159783</TimeCreated>

<Method name="All">
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String={$zu(12,"config-copy-remote/")}</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Set Directory = ##class(%File).NormalizeDirectory(Directory)

    Do:'##class(%File).DirectoryExists(Directory) ##class(%File).CreateDirectoryChain(Directory)

    Set scO =..Security(Directory_"SecurityExport.xml")
    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)

    Set scO = ..Tasks(Directory_"TasksExport.xml")
    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)

    Set scO = ..Globals(Directory_"GlobalsExport.xml")
    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)

    Set scO = ..CPFData(Directory_"config-api.json")
    Set:$$$ISERR(scO) sc = $$$ADDSC(sc,scO)

    Return sc
]]></Implementation>
</Method>

<Method name="CPFData">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String="",*config:%DynamicObject=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    ; zw ##class(lscalese.configcopy.RemoteExport).ExportCPFData(,.cfg)
    Set client = ##class(lscalese.configcopy.client.HttpClient).%New()
    Set pRequest = ##class(lscalese.configcopy.client.msg.ExportConfigRequest).%New()
    $$$QuitOnError(client.GETExportConfig(pRequest,.pResponse))
    
    Return:pResponse.httpStatusCode'=200 $$$ERROR(5001, "Return http status code "_pResponse.httpStatusCode)
    
    Set config = {}.%FromJSON(pResponse.body)
    
    Set:Filename'="" sc = ##class(Api.Config.Services.Loader).toFile(config, Filename)
    
    Return sc
]]></Implementation>
</Method>

<Method name="Tasks">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String="",*TasksStream:%Stream.GlobalBinary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    ; d ##class(lscalese.configcopy.RemoteExport).ExportTasks(,.ts)
    Set sc = $$$OK
    Set client = ##class(lscalese.configcopy.client.HttpClient).%New()
    Set pRequest = ##class(lscalese.configcopy.client.msg.ExportTasksRequest).%New()
    $$$QuitOnError(client.GETExportTasks(pRequest,.pResponse))
    
    Return:pResponse.httpStatusCode'=200 $$$ERROR(5001, "Return http status code "_pResponse.httpStatusCode)
    
    Set TasksStream = pResponse.body
    Do TasksStream.Rewind()
    
    Return:Filename="" sc

    Set fbs = ##class(%Stream.FileBinary).%New()
    $$$QuitOnError(fbs.LinkToFile(Filename))
    Do fbs.CopyFrom(pResponse.body)
    $$$QuitOnError(fbs.%Save())
    
    Return sc
]]></Implementation>
</Method>

<Method name="Security">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String="",*SecurityStream:%Stream.GlobalBinary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    ; zw ##class(lscalese.configcopy.RemoteExport).ExportSecurity(,.ss)
    Set sc = $$$OK
    Set client = ##class(lscalese.configcopy.client.HttpClient).%New()
    Set pRequest = ##class(lscalese.configcopy.client.msg.ExportSecurityRequest).%New()
    $$$QuitOnError(client.GETExportSecurity(pRequest,.pResponse))
    
    Return:pResponse.httpStatusCode'=200 $$$ERROR(5001, "Return http status code "_pResponse.httpStatusCode)
    
    Set SecurityStream = pResponse.body
    Do SecurityStream.Rewind()
    
    Return:Filename="" sc

    Set fbs = ##class(%Stream.FileBinary).%New()
    $$$QuitOnError(fbs.LinkToFile(Filename))
    Do fbs.CopyFrom(pResponse.body)
    $$$QuitOnError(fbs.%Save())
    
    Return sc
]]></Implementation>
</Method>

<Method name="Globals">
<ClassMethod>1</ClassMethod>
<FormalSpec>Filename:%String="",*GlobalsStream:%Stream.GlobalBinary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    ; zw ##class(lscalese.configcopy.RemoteExport).ExportGlobals(,.gs)
    Set sc = $$$OK
    Set client = ##class(lscalese.configcopy.client.HttpClient).%New()
    Set pRequest = ##class(lscalese.configcopy.client.msg.getexportsysglobalsRequest).%New()
    $$$QuitOnError(client.GETgetexportsysglobals(pRequest,.pResponse))
    
    Return:pResponse.httpStatusCode'=200 $$$ERROR(5001, "Return http status code "_pResponse.httpStatusCode)
    
    Set GlobalsStream = pResponse.body
    Do GlobalsStream.Rewind()
    
    Return:Filename="" sc

    Set fbs = ##class(%Stream.FileBinary).%New()
    $$$QuitOnError(fbs.LinkToFile(Filename))
    Do fbs.CopyFrom(pResponse.body)
    $$$QuitOnError(fbs.%Save())
    
    Return sc
]]></Implementation>
</Method>
</Class>


<Class name="lscalese.configcopy.Utils">
<Description>
Description</Description>
<TimeChanged>66012,27904.424308</TimeChanged>
<TimeCreated>66011,42392.534365</TimeCreated>

<Method name="Install">
<Description>
Do ##class(lscalese.configcopy.Utils).Install("localhost",52773)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>RemoteHost:%String="localhost",RemotePort:%Integer=52773,SSLConfig:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    Do ..SetCredential(,,$$$NO)
    Do ..SetRemoteSettings(RemoteHost, RemotePort, SSLConfig)
    Return ..SetWebApp()
]]></Implementation>
</Method>

<Method name="SetRemoteSettings">
<Description>
Do ##class(lscalese.configcopy.Utils).SetRemoteSettings("localhost",52773)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>RemoteHost:%String="localhost",RemotePort:%Integer=52773,SSLConfig:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set ^configcopy.RemoteExport("server") = RemoteHost
	Set ^configcopy.RemoteExport("port") = RemotePort
	Set ^configcopy.RemoteExport("sslconfig") = SSLConfig
    Return $$$OK
]]></Implementation>
</Method>

<Method name="SetCredential">
<ClassMethod>1</ClassMethod>
<FormalSpec>Username:%String="_system",Password:%String="SYS",Override:%Boolean=$$$YES</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set credentialId = ##class(lscalese.configcopy.client.HttpClient).%GetParameter("CREDENTIALID")
    Return ##class(Ens.Config.Credentials).SetCredential(credentialId, Username, Password, Override)
]]></Implementation>
</Method>

<Method name="SetWebApp">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set config = {
        "Security.Applications":{
            "/csp/lscalese/configcopy":{
                "AutheEnabled":"32",
                "CookiePath":"/csp/lscalese/configcopy/",
                "DispatchClass":"lscalese.configcopy.rest.disp",
                "Name":"/csp/lscalese/configcopy",
                "NameSpace":"${NAMESPACE}"
            }
        }
    }
    
    Return ##class(Api.Config.Services.Loader).Load(config)
]]></Implementation>
</Method>

<Method name="buildXmlRelease">
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String="/irisrun/repo/dist/config-copy_for_IRIS.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    Do:##class(%File).Exists(filename) ##class(%File).Delete(filename)
    Set items = ""
    Set items("Api.Config.inc.INC")=""
    Set items("IORedirect.INC")=""
    Set items("Api.Config.*.CLS")=""
    Set items("IORedirect.*.CLS")=""
    Set items("lscalese.configcopy.*.CLS")=""
    Quit $SYSTEM.OBJ.Export(.items,filename)
]]></Implementation>
</Method>
</Class>


<Class name="lscalese.configcopy.client.HttpClient">
<ProcedureBlock>1</ProcedureBlock>
<Super>%RegisteredObject</Super>
<TimeChanged>66011,51151.476043</TimeChanged>
<TimeCreated>66011,29869.135177</TimeCreated>

<Parameter name="CREDENTIALID">
<Default>config-copy</Default>
</Parameter>

<Method name="GETExportConfig">
<Description>
Export configuration in config-api format : https://github.com/lscalese/iris-config-api .</Description>
<FormalSpec>pRequest:lscalese.configcopy.client.msg.ExportConfigRequest,*pResponse:lscalese.configcopy.client.msg.GenericResponse,pHttpRequestIn:%Net.HttpRequest=..GetRequest(pRequest),*pHttpResponse:%Net.HttpResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK, pURL = "/csp/lscalese/configcopy/export/config/"
	Set pHttpRequestIn = ..GetRequest(pRequest)
	Set pHttpRequestIn.ContentType = pRequest.consume
	$$$QuitOnError(pHttpRequestIn.Send("GET", pURL))
	Set pHttpResponse=pHttpRequestIn.HttpResponse
	Set pResponse = ##class(lscalese.configcopy.client.msg.GenericResponse).%New()
	Set sc = ..genericProcessResponse(pRequest, pResponse, "GETExportConfig", sc, $Get(pHttpResponse),"")
	Return sc
]]></Implementation>
</Method>

<Method name="GETExportSecurity">
<Description>
Export all security settings in XML format</Description>
<FormalSpec>pRequest:lscalese.configcopy.client.msg.ExportSecurityRequest,*pResponse:lscalese.configcopy.client.msg.GenericResponse,pHttpRequestIn:%Net.HttpRequest=..GetRequest(pRequest),*pHttpResponse:%Net.HttpResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK, pURL = "/csp/lscalese/configcopy/export/security/"
	Set pHttpRequestIn = ..GetRequest(pRequest)
	Set pHttpRequestIn.ContentType = pRequest.consume
	$$$QuitOnError(pHttpRequestIn.Send("GET", pURL))
	Set pHttpResponse=pHttpRequestIn.HttpResponse
	Set pResponse = ##class(lscalese.configcopy.client.msg.GenericResponse).%New()
	Set sc = ..genericProcessResponse(pRequest, pResponse, "GETExportSecurity", sc, $Get(pHttpResponse),"")
	Return sc
]]></Implementation>
</Method>

<Method name="GETExportTasks">
<Description>
Export all users defined tasks in XML format.</Description>
<FormalSpec>pRequest:lscalese.configcopy.client.msg.ExportTasksRequest,*pResponse:lscalese.configcopy.client.msg.GenericResponse,pHttpRequestIn:%Net.HttpRequest=..GetRequest(pRequest),*pHttpResponse:%Net.HttpResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK, pURL = "/csp/lscalese/configcopy/export/tasks/"
	Set pHttpRequestIn = ..GetRequest(pRequest)
	Set pHttpRequestIn.ContentType = pRequest.consume
	$$$QuitOnError(pHttpRequestIn.Send("GET", pURL))
	Set pHttpResponse=pHttpRequestIn.HttpResponse
	Set pResponse = ##class(lscalese.configcopy.client.msg.GenericResponse).%New()
	Set sc = ..genericProcessResponse(pRequest, pResponse, "GETExportTasks", sc, $Get(pHttpResponse),"")
	Return sc
]]></Implementation>
</Method>

<Method name="GETGetSpec">
<FormalSpec>pRequest:lscalese.configcopy.client.msg.GetSpecRequest,*pResponse:lscalese.configcopy.client.msg.GenericResponse,pHttpRequestIn:%Net.HttpRequest=..GetRequest(pRequest),*pHttpResponse:%Net.HttpResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK, pURL = "/csp/lscalese/configcopy/"
	Set pHttpRequestIn = ..GetRequest(pRequest)
	Set pHttpRequestIn.ContentType = pRequest.consume
	$$$QuitOnError(pHttpRequestIn.Send("GET", pURL))
	Set pHttpResponse=pHttpRequestIn.HttpResponse
	Set pResponse = ##class(lscalese.configcopy.client.msg.GenericResponse).%New()
	Set sc = ..genericProcessResponse(pRequest, pResponse, "GETGetSpec", sc, $Get(pHttpResponse),"")
	Return sc
]]></Implementation>
</Method>

<Method name="GETgetexportsysglobals">
<Description>
Copy the node ^%SYS("sql","ODBCCONNECTION") into ^ExportTmp and export it.</Description>
<FormalSpec>pRequest:lscalese.configcopy.client.msg.getexportsysglobalsRequest,*pResponse:lscalese.configcopy.client.msg.GenericResponse,pHttpRequestIn:%Net.HttpRequest=..GetRequest(pRequest),*pHttpResponse:%Net.HttpResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK, pURL = "/csp/lscalese/configcopy/export/sysglobals/"
	Set pHttpRequestIn = ..GetRequest(pRequest)
	Set pHttpRequestIn.ContentType = pRequest.consume
	$$$QuitOnError(pHttpRequestIn.Send("GET", pURL))
	Set pHttpResponse=pHttpRequestIn.HttpResponse
	Set pResponse = ##class(lscalese.configcopy.client.msg.GenericResponse).%New()
	Set sc = ..genericProcessResponse(pRequest, pResponse, "GETgetexportsysglobals", sc, $Get(pHttpResponse),"")
	Return sc
]]></Implementation>
</Method>

<Method name="GetRequest">
<FormalSpec>pRequest:%RegisteredObject</FormalSpec>
<ReturnType>%Net.HttpRequest</ReturnType>
<Implementation><![CDATA[
	#dim pHttpRequestIn As %Net.HttpRequest = ##class(%Net.HttpRequest).%New()
	Do:##class(%Dictionary.CompiledProperty).%ExistsId(pRequest.%ClassName(1)_"||accept") pHttpRequestIn.SetHeader("accept", pRequest.accept)
	Set pHttpRequestIn.Server = $Get(^configcopy.RemoteExport("server"),"localhost")
	Set pHttpRequestIn.Port = $Get(^configcopy.RemoteExport("port"),52773)
	Set pHttpRequestIn.Https = $Get(^configcopy.RemoteExport("sslconfig"))'=""
	
    If ##class(Ens.Config.Credentials).%ExistsId(..#CREDENTIALID) {
        Set user = ##class(Ens.Config.Credentials).GetValue(..#CREDENTIALID, "Username")
        Set password = ##class(Ens.Config.Credentials).GetValue(..#CREDENTIALID, "Password")
        Do pHttpRequestIn.SetHeader("Authorization","Basic "_$SYSTEM.Encryption.Base64Encode(user_":"_password))
    }

	Return pHttpRequestIn
]]></Implementation>
</Method>

<Method name="genericProcessResponse">
<FormalSpec>pRequest:%RegisteredObject,pResponse:lscalese.configcopy.client.msg.GenericResponse,caller:%String,status:%Status,pHttpResponse:%Net.HttpResponse,parsedResponseClassName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set pResponse.operation = caller
	Set pResponse.operationStatusText = $SYSTEM.Status.GetOneErrorText(status)
	If $Isobject(pHttpResponse) {
		Set pResponse.httpStatusCode = pHttpResponse.StatusCode
		Do pResponse.body.CopyFrom(pHttpResponse.Data)
		Set key = ""
		For  {
			Set key = $Order(pHttpResponse.Headers(key),1 , headerValue)
			Quit:key=""
			Do pResponse.headers.SetAt(headerValue, key)
		}
		Set sc = ##class(lscalese.configcopy.client.HttpClient).processParsedResponse(pHttpResponse, parsedResponseClassName, caller, pRequest, pResponse)
	}
	Return sc
]]></Implementation>
</Method>

<Method name="processParsedResponse">
<ClassMethod>1</ClassMethod>
<FormalSpec>pHttpResponse:%Net.HttpResponse,responseClass:%String,caller:%String,pRequest:%RegisteredObject,pResponse:lscalese.configcopy.client.msg.GenericResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Return:responseClass="" $$$OK
    Set parsedResponse = "", sc = $$$OK
    
    If (pHttpResponse.ContentType="application/json") {
        Set httpStatusCode = pHttpResponse.StatusCode
        
        Set parsedResponse = $ClassMethod(responseClass, "%New")
        
        Quit:parsedResponse.%GetParameter(httpStatusCode _ "MODEL")="" sc

        #define zIsList httpStatusCode _ "ISLIST"
        #define zModelType httpStatusCode _ "MODELTYPE"
        #define zModel httpStatusCode _ "MODEL"

        Try {
            If parsedResponse.%GetParameter( $$$zIsList ) {
                Set list = [].%FromJSON(pHttpResponse.Data)
                Set iter = list.%GetIterator()
                While iter.%GetNext(.keyParam, .value) {
                    Set model = $ClassMethod(parsedResponse.%GetParameter( $$$zModelType ), "%New")
                    Do model.%JSONImport(value)
                    Do $Method($Property(parsedResponse, parsedResponse.%GetParameter( $$$zModel )), "Insert", model)
                }
            } Else {
                Set model = $ClassMethod(parsedResponse.%GetParameter( $$$zModelType ), "%New")
                Do model.%JSONImport(pHttpResponse.Data)
                Set $Property(parsedResponse, parsedResponse.%GetParameter( $$$zModel )) = model
            }
            Set pResponse.parsedResponse = parsedResponse
        } Catch(ex) {
            Set sc = ex.AsStatus()
        }
    }

    Return sc
]]></Implementation>
</Method>

<Method name="SaveCredential">
<ClassMethod>1</ClassMethod>
<FormalSpec>Username:%String,Password:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	; Do ##class(lscalese.configcopy.client.HttpClient).SaveCredential("_system","SYS")
    Return ##class(Ens.Config.Credentials).SetCredential(..#CREDENTIALID, Username, Password, $$$YES)
]]></Implementation>
</Method>
</Class>


<Class name="lscalese.configcopy.client.model.spec">
<ProcedureBlock>1</ProcedureBlock>
<Super>%RegisteredObject</Super>
<TimeChanged>66011,29869.21978</TimeChanged>
<TimeCreated>66011,29869.21978</TimeCreated>

<XData name="OpenAPI">
<MimeType>application/json</MimeType>
<Data><![CDATA[
{
  "swagger":"2.0",
  "basePath":"/lscalese/configcopy",
  "schemes":[
    "http",
    "https"
  ],
  "info":{
    "title":"config-copy api",
    "version":"0.0.1",
    "description":"",
    "contact":{
      "name":"Lorenzo Scalese",
      "email":"lorenzo.scalese@gmail.com",
      "url":"https://github.com/lscalese/iris-config-copy/"
    },
    "license":{
      "name":"MIT",
      "url":"https://github.com/lscalese/iris-config-copy/blob/master/LICENSE"
    }
  },
  "produces":[
    "application/json",
    "application/xml"
  ],
  "paths":{
    "/":{
      "get":{
        "summary":"Swagger 2.0 specification",
        "operationId":"GetSpec",
        "produces":[
          "application/json"
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      }
    },
    "/export/sysglobals":{
      "get":{
        "description":"Copy the node ^%SYS(\"sql\",\"ODBCCONNECTION\") into ^ExportTmp and export it.",
        "parameters":[
        ],
        "produces":[
          "application/xml"
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        },
        "operationId":"getexportsysglobals"
      }
    },
    "/export/config":{
      "get":{
        "description":"Export configuration in config-api format : https://github.com/lscalese/iris-config-api .",
        "operationId":"ExportConfig",
        "parameters":[
        ],
        "produces":[
          "application/json"
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      }
    },
    "/export/tasks/":{
      "get":{
        "description":"Export all users defined tasks in XML format.",
        "operationId":"ExportTasks",
        "parameters":[
        ],
        "produces":[
          "application/xml"
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      }
    },
    "/export/security/":{
      "get":{
        "description":"Export all security settings in XML format",
        "operationId":"ExportSecurity",
        "parameters":[
        ],
        "produces":[
          "application/xml"
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      }
    }
  },
  "definitions":{
  }
}
]]></Data>
</XData>
</Class>


<Class name="lscalese.configcopy.client.msg.ExportConfigRequest">
<Description><![CDATA[
Request Object for application : lscalese.configcopy.client
<br/>Service : ExportConfig]]></Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent</Super>
<TimeChanged>66011,29869.206779</TimeChanged>
<TimeCreated>66011,29869.206779</TimeCreated>
<Inheritance>left</Inheritance>

<Property name="accept">
<Description><![CDATA[
accept : <ul>
<li>application/json</li>
</ul>]]></Description>
<Type>%String</Type>
<InitialExpression>"application/json"</InitialExpression>
</Property>

<Property name="consume">
<Type>%String</Type>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^lscalese.cD0BB.ExportConfi9065D</DataLocation>
<DefaultData>ExportConfigRequestDefaultData</DefaultData>
<IdLocation>^lscalese.cD0BB.ExportConfi9065D</IdLocation>
<IndexLocation>^lscalese.cD0BB.ExportConfi9065I</IndexLocation>
<StreamLocation>^lscalese.cD0BB.ExportConfi9065S</StreamLocation>
<Data name="ExportConfigRequestDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>accept</Value>
</Value>
<Value name="3">
<Value>consume</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="lscalese.configcopy.client.msg.ExportSecurityRequest">
<Description><![CDATA[
Request Object for application : lscalese.configcopy.client
<br/>Service : ExportSecurity]]></Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent</Super>
<TimeChanged>66011,29869.177994</TimeChanged>
<TimeCreated>66011,29869.177994</TimeCreated>
<Inheritance>left</Inheritance>

<Property name="accept">
<Description><![CDATA[
accept : <ul>
<li>application/xml</li>
</ul>]]></Description>
<Type>%String</Type>
<InitialExpression>"application/xml"</InitialExpression>
</Property>

<Property name="consume">
<Type>%String</Type>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^lscalese.cD0BB.ExportSecur6E11D</DataLocation>
<DefaultData>ExportSecurityRequestDefaultData</DefaultData>
<IdLocation>^lscalese.cD0BB.ExportSecur6E11D</IdLocation>
<IndexLocation>^lscalese.cD0BB.ExportSecur6E11I</IndexLocation>
<StreamLocation>^lscalese.cD0BB.ExportSecur6E11S</StreamLocation>
<Data name="ExportSecurityRequestDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>accept</Value>
</Value>
<Value name="3">
<Value>consume</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="lscalese.configcopy.client.msg.ExportTasksRequest">
<Description><![CDATA[
Request Object for application : lscalese.configcopy.client
<br/>Service : ExportTasks]]></Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent</Super>
<TimeChanged>66011,29869.223291</TimeChanged>
<TimeCreated>66011,29869.223291</TimeCreated>
<Inheritance>left</Inheritance>

<Property name="accept">
<Description><![CDATA[
accept : <ul>
<li>application/xml</li>
</ul>]]></Description>
<Type>%String</Type>
<InitialExpression>"application/xml"</InitialExpression>
</Property>

<Property name="consume">
<Type>%String</Type>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^lscalese.cD0BB.ExportTasksE4E2D</DataLocation>
<DefaultData>ExportTasksRequestDefaultData</DefaultData>
<IdLocation>^lscalese.cD0BB.ExportTasksE4E2D</IdLocation>
<IndexLocation>^lscalese.cD0BB.ExportTasksE4E2I</IndexLocation>
<StreamLocation>^lscalese.cD0BB.ExportTasksE4E2S</StreamLocation>
<Data name="ExportTasksRequestDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>accept</Value>
</Value>
<Value name="3">
<Value>consume</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="lscalese.configcopy.client.msg.GenericResponse">
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent</Super>
<TimeChanged>66011,29869.219463</TimeChanged>
<TimeCreated>66011,29869.219463</TimeCreated>
<Inheritance>left</Inheritance>

<Property name="body">
<Type>%Stream.GlobalBinary</Type>
</Property>

<Property name="headers">
<Type>%String</Type>
<Collection>array</Collection>
<Parameter name="MAXLEN" value="128"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="httpStatusCode">
<Type>%Integer</Type>
</Property>

<Property name="operation">
<Type>%String</Type>
<Parameter name="MAXLEN" value="128"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="operationStatusText">
<Type>%String</Type>
<Parameter name="MAXLEN" value="128"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="parsedResponse">
<Type>lscalese.configcopy.client.msg.ParsedResponse</Type>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^lscalese.cD0BB.GenericResp16D5D</DataLocation>
<DefaultData>GenericResponseDefaultData</DefaultData>
<IdLocation>^lscalese.cD0BB.GenericResp16D5D</IdLocation>
<IndexLocation>^lscalese.cD0BB.GenericResp16D5I</IndexLocation>
<StreamLocation>^lscalese.cD0BB.GenericResp16D5S</StreamLocation>
<Data name="GenericResponseDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>body</Value>
</Value>
<Value name="3">
<Value>httpStatusCode</Value>
</Value>
<Value name="4">
<Value>operation</Value>
</Value>
<Value name="5">
<Value>operationStatusText</Value>
</Value>
<Value name="6">
<Value>parsedResponse</Value>
</Value>
</Data>
<Data name="headers">
<Attribute>headers</Attribute>
<Structure>subnode</Structure>
<Subscript>"headers"</Subscript>
</Data>
</Storage>
</Class>


<Class name="lscalese.configcopy.client.msg.GetSpecRequest">
<Description><![CDATA[
Request Object for application : lscalese.configcopy.client
<br/>Service : GetSpec]]></Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent</Super>
<TimeChanged>66011,29869.291142</TimeChanged>
<TimeCreated>66011,29869.291142</TimeCreated>
<Inheritance>left</Inheritance>

<Property name="accept">
<Description><![CDATA[
accept : <ul>
<li>application/json</li>
</ul>]]></Description>
<Type>%String</Type>
<InitialExpression>"application/json"</InitialExpression>
</Property>

<Property name="consume">
<Type>%String</Type>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^lscalese.coD0BB.GetSpecRequestD</DataLocation>
<DefaultData>GetSpecRequestDefaultData</DefaultData>
<IdLocation>^lscalese.coD0BB.GetSpecRequestD</IdLocation>
<IndexLocation>^lscalese.coD0BB.GetSpecRequestI</IndexLocation>
<StreamLocation>^lscalese.coD0BB.GetSpecRequestS</StreamLocation>
<Data name="GetSpecRequestDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>accept</Value>
</Value>
<Value name="3">
<Value>consume</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="lscalese.configcopy.client.msg.ParsedResponse">
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent,%XML.Adaptor</Super>
<TimeChanged>66011,29869.275549</TimeChanged>
<TimeCreated>66011,29869.275549</TimeCreated>
<Inheritance>right</Inheritance>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^lscalese.coD0BB.ParsedResponseD</DataLocation>
<DefaultData>ParsedResponseDefaultData</DefaultData>
<IdLocation>^lscalese.coD0BB.ParsedResponseD</IdLocation>
<IndexLocation>^lscalese.coD0BB.ParsedResponseI</IndexLocation>
<StreamLocation>^lscalese.coD0BB.ParsedResponseS</StreamLocation>
<Data name="ParsedResponseDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="lscalese.configcopy.client.msg.getexportsysglobalsRequest">
<Description><![CDATA[
Request Object for application : lscalese.configcopy.client
<br/>Service : getexportsysglobals]]></Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent</Super>
<TimeChanged>66011,29869.245045</TimeChanged>
<TimeCreated>66011,29869.245045</TimeCreated>
<Inheritance>left</Inheritance>

<Property name="accept">
<Description><![CDATA[
accept : <ul>
<li>application/xml</li>
</ul>]]></Description>
<Type>%String</Type>
<InitialExpression>"application/xml"</InitialExpression>
</Property>

<Property name="consume">
<Type>%String</Type>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^lscalese.cD0BB.getexportsy745AD</DataLocation>
<DefaultData>getexportsysglobalsRequestDefaultData</DefaultData>
<IdLocation>^lscalese.cD0BB.getexportsy745AD</IdLocation>
<IndexLocation>^lscalese.cD0BB.getexportsy745AI</IndexLocation>
<StreamLocation>^lscalese.cD0BB.getexportsy745AS</StreamLocation>
<Data name="getexportsysglobalsRequestDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>accept</Value>
</Value>
<Value name="3">
<Value>consume</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="lscalese.configcopy.rest.impl">
<Description><![CDATA[
Business logic class defined by OpenAPI in lscalese.configcopy.rest.spec<br/>
Updated Sep 24, 2021 14:11:29]]></Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%REST.Impl</Super>
<TimeChanged>66011,51089.195541</TimeChanged>
<TimeCreated>66011,29869.272707</TimeCreated>

<Parameter name="ExposeServerExceptions">
<Description>
If ExposeServerExceptions is true, then details of internal errors will be exposed.</Description>
<Default>0</Default>
</Parameter>

<Method name="GetSpec">
<Description>
Swagger 2.0 specification</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    //(Place business logic here)
    //Do ..%SetStatusCode(<HTTP_status_code>)
    //Do ..%SetHeader(<name>,<value>)
    //Quit (Place response here) ; response may be a string, stream or dynamic object
    Return {}.%FromJSON(##class(%Dictionary.CompiledXData).%OpenId("lscalese.configcopy.rest.spec||OpenAPI").Data)
]]></Implementation>
</Method>

<Method name="ExportSysglobals">
<Description>
Copy the node ^%SYS("sql","ODBCCONNECTION") into ^ExportTmp and export it.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
    //(Place business logic here)
    //Do ..%SetStatusCode(<HTTP_status_code>)
    //Do ..%SetHeader(<name>,<value>)
    //Quit (Place response here) ; response may be a string, stream or dynamic object

    Set sc = $$$OK
    Set Filename = ##class(%File).TempFilename()
    Set sc = ##class(lscalese.configcopy.LocalExport).Globals(Filename)
    
    If $$$ISERR(sc) {
        Do:##class(%File).Exists(Filename) ##class(%File).Delete(Filename)
        $$$ThrowStatus(sc)
    }

    Set fcs = ##class(%Stream.FileCharacter).%New()
    Set sc = fcs.LinkToFile(Filename)
    If $$$ISERR(sc) $$$ThrowStatus(sc)
    #dim cs As %Stream.GlobalCharacter = ##class(%Stream.GlobalCharacter).%New()
    Do cs.CopyFrom(fcs)

    Do ##class(%File).Delete(Filename)

    Return cs
]]></Implementation>
</Method>

<Method name="ExportConfig">
<Description>
Export configuration in config-api format : https://github.com/lscalese/iris-config-api .</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Set config = ##class(lscalese.configcopy.LocalExport).CPFDataTemplate(.sc, "Default")
    
    If $$$ISERR(sc) {
        $$$ThrowStatus(sc)
    }

    Return config
]]></Implementation>
</Method>

<Method name="ExportTasks">
<Description>
Export all users defined tasks in XML format.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Set Filename = ##class(%File).TempFilename()
    Set sc = ##class(lscalese.configcopy.LocalExport).Tasks(Filename)
    
    If $$$ISERR(sc) {
        Do:##class(%File).Exists(Filename) ##class(%File).Delete(Filename)
        $$$ThrowStatus(sc)
    }

    Set fcs = ##class(%Stream.FileCharacter).%New()
    Set sc = fcs.LinkToFile(Filename)
    If $$$ISERR(sc) $$$ThrowStatus(sc)
    #dim cs As %Stream.GlobalCharacter = ##class(%Stream.GlobalCharacter).%New()
    Do cs.CopyFrom(fcs)

    Do ##class(%File).Delete(Filename)

    Return cs
]]></Implementation>
</Method>

<Method name="ExportSecurity">
<Description>
Export all security settings in XML format</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
    //(Place business logic here)
    //Do ..%SetStatusCode(<HTTP_status_code>)
    //Do ..%SetHeader(<name>,<value>)
    //Quit (Place response here) ; response may be a string, stream or dynamic object

    Set sc = $$$OK
    Set Filename = ##class(%File).TempFilename()
    Set sc = ##class(lscalese.configcopy.LocalExport).Security(Filename)
    
    If $$$ISERR(sc) {
        Do:##class(%File).Exists(Filename) ##class(%File).Delete(Filename)
        $$$ThrowStatus(sc)
    }

    Set fcs = ##class(%Stream.FileCharacter).%New()
    Set sc = fcs.LinkToFile(Filename)
    If $$$ISERR(sc) $$$ThrowStatus(sc)
    #dim cs As %Stream.GlobalCharacter = ##class(%Stream.GlobalCharacter).%New()
    Do cs.CopyFrom(fcs)

    Do ##class(%File).Delete(Filename)

    Return cs
]]></Implementation>
</Method>
</Class>


<Class name="lscalese.configcopy.rest.spec">
<ProcedureBlock>1</ProcedureBlock>
<Super>%REST.Spec</Super>
<TimeChanged>66011,51089.092916</TimeChanged>
<TimeCreated>66011,29869.313226</TimeCreated>

<XData name="OpenAPI">
<MimeType>application/json</MimeType>
<Data><![CDATA[
{
  "swagger": "2.0",
  "basePath" : "/lscalese/configcopy",
  "schemes" : [
    "http",
    "https"
  ],
  "info":{
    "title":"config-copy api",
    "version":"0.0.1",
    "description":"",
    "contact": {
      "name" : "Lorenzo Scalese",
      "email": "lorenzo.scalese@gmail.com",
      "url": "https://github.com/lscalese/iris-config-copy/"
    },
    "license": {
      "name": "MIT",
      "url": "https://github.com/lscalese/iris-config-copy/blob/master/LICENSE"
    }
  },
  "produces": [
      "application/json",
      "application/xml"
  ],
  "paths": {
    "/": {
      "get": {
        "summary": "Swagger 2.0 specification",
        "operationId":"GetSpec",
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/export/sysglobals/": {
      "get": {
        "description": "Copy the node ^%SYS(\"sql\",\"ODBCCONNECTION\") into ^ExportTmp and export it.",
        "operationId":"ExportSysglobals",
        "parameters": [],
        "produces": [
          "application/xml"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
      "/export/config/": {
          "get": {
              "description": "Export configuration in config-api format : https://github.com/lscalese/iris-config-api .",
              "operationId":"ExportConfig",
              "parameters": [],
              "produces": [
                "application/json"
              ],
              "responses": {
                  "200": {
                      "description": "OK"
                  }
              }
          }
      },
      "/export/tasks/": {
          "get": {
              "description": "Export all users defined tasks in XML format.",
              "operationId":"ExportTasks",
              "parameters": [],
              "produces": [
                "application/xml"
              ],
              "responses": {
                  "200": {
                      "description": "OK"
                  }
              }
          }
      },
      "/export/security/": {
          "get": {
              "description": "Export all security settings in XML format",
              "operationId":"ExportSecurity",
              "parameters": [],
              "produces": [
                "application/xml"
              ],
              "responses": {
                  "200": {
                      "description": "OK"
                  }
              }
          }
      }
    }
}
]]></Data>
</XData>
</Class>
</Export>
